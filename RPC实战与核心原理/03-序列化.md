#### 概览

1. 序列化的原因
2. 序列化的种类
3. 序列化的最佳实践



#### 序列化的原因

网络传输只能传二进制流。对象转二进制流这个过程称为序列化。



#### 序列化的种类

##### jdk原生序列化

- 实现方式

  - ObjectOutputStream屏蔽了实现细节。
  
- 优缺点

  - 优点是实现简单
  - 缺点是空间利用率较低https://blog.csdn.net/canot/article/details/53750443这个文章给出了序列化时间和空间的对比，对网络传输而言，空间就是时间。
  
  
  
  
##### json

- json格式化的额外空间开销较大
- json没有类型，这里有个有趣的问题就是，json在反序列化时，如何确定每个字段的类型呢？这个以后可以发散。



##### Hessian

- 优点
  - 空间紧凑，同样一个对象，序列化之后字节数最少。
- 缺点
  - Linked系列的集合对象不支持，可通过扩展CollectionDeserializer解决
  - Locale不支持，扩展ContextSerializerFactory
  - Byte/Short反序列化时会变成Integer



##### Protobuf

- 优点
  - 字节数更少，空间利用更紧凑
  - 太灵活了，开发人员想要比较无脑的，这个算不上优点，算不上缺点



##### Protostuff

- 优点
  - 把Protobuf中需要配置的部分去了，性能损耗不大的情况下，非常易用。





#### 序列化方式的选择考量

安全性是第一位的。

通用性，兼容性，性能。

通用性： 

- 支持多种数据类型
- 是否可以跨平台
- 是否可以跨语言

兼容性：

- 因为一些原因我们需要对序列化协议进行升级，那之前老版本的内容是否还可以正常解析。



性能：

- 其实就是快，空间小网络传输快。



#### rpc下序列化的最佳实战

1. 不要构造过于复杂的对象
2. 不要使用过度庞大的对象（大list，大map）
3. 不要使用序列号协议不支持的类型
4. 对象之间不要有过于复杂的耦合关系





  

  

  





