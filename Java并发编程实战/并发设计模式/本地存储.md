多线程读写同一个共享变量有并发问题。

线程可以自己带一个专属自己的空间- ThreadLocal

避免共享是最快最省事的方式。



```java
 public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + "-" + ThreadId.get());
            }
        });
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + "-" + ThreadId.get());
            }
        });

        t1.start();
        t2.start();
        System.out.println(t1.getName());
        System.out.println(t2.getName());
    }

    static class ThreadId {
        static final AtomicInteger at = new AtomicInteger(1);

        static ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> {
            return at.getAndIncrement();
        });

        static int get() {
            return threadLocal.get();
        }
    }
```





#### 如何实现

- 既然每个线程都有一个单独的属于自己的对象。
- 我们使用一个Map来实现是否会好一点，Map的key就是线程对象，Value是ThreadLocal的对象

Map<Thread, T> ThreadLocalMap;

这还得是个线程安全的map。

线程在启动的时候，就往这个map中put需要的ThreadLocal对象。

然后后续使用的时候，直接get

这种有个问题就是，如果这个线程运行结束了，如果没有做清理工作的话，这个全局的静态变量里的数值是不会被删除的。

也就是内存泄漏问题。

其实只要这个全局的ThreadLocalMap还存在，这个线程对象也不会被回收。





java是如何实现的呢？

![img](https://static001.geekbang.org/resource/image/3c/02/3cb0a8f15104848dec63eab269bac302.png)

