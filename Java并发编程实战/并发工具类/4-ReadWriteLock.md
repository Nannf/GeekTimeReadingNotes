#### 背景

无论是lock还是synchronized都是独占锁。

但是如果我只是读，我不改，就不会有线程安全问题。

读多写少的场景使用已有的同步策略都显得有点笨拙。



于是读写锁应运而生。

- 读写锁的写锁和读锁写锁都互斥
- 读写锁的读锁之间是共享的
- 读写锁不能升级（一个线程持有读锁，在不释放读锁的情况下接着获取写锁）



