#### 背景

无论是lock还是synchronized都是独占锁。

但是如果我只是读，我不改，就不会有线程安全问题。

读多写少的场景使用已有的同步策略都显得有点笨拙。



于是读写锁应运而生。

- 读写锁的写锁和读锁写锁都互斥
- 读写锁的读锁之间是共享的
- 读写锁不能升级（一个线程持有读锁，在不释放读锁的情况下接着获取写锁）



#### 读写锁与缓存

##### 缓存的内容在启动时一次性加载

- 这种情况其实在不考虑更新缓存的时候无需读写锁入场。
- 常见的使用场景是程序启动的开始就加载数据到内存，或者redis这样的中间件中，被加载的数据一般不会再更新。
- 此时多线程操作缓存只有读操作，不涉及修改，就不存在并发安全问题。



##### 缓存的内容要按需加载

- 场景出现的原因是因为我们要缓存的数据是大量的，不能全部加载再内存中
- 就涉及到缓存的淘汰和加载
- 读写锁是不能升级的（持有读锁的线程，如果想要获取写锁，必须释放自己持有的读锁）
- 读写锁是可以降级的（持有写锁的线程，如果想要获取读锁，是可以直接获取的）
