#### 概览

纵观下来，这个和多线程的关系也不大。只是多线程时的一个解决方案。

使用了其中避免共享的思想。

核心还是Reactor Pattern.

本文尝试对 Reactor Pattern 进行一个初步的了解。

了解包括这个的使用场景，和具体的解决措施。

具体的可以参照Doug Lea的论文来细读。



#### 发展过程

##### 阻塞阶段

这个阶段的特征是：

- 对每一个客户端的请求而言，服务端都使用一个单独的线程去处理
- 这边作者说了会阻塞，其实阻塞是有事件的，比如等待io时阻塞
- 总的来说，就是客户端一个连接，服务端一个线程，这个线程会因为等待磁盘io或者网络io而处于不可用状态。

![img](https://static001.geekbang.org/resource/image/e7/e2/e712c37ea0483e9dde0d6efe76e687e2.png)



这个阶段的业务驱动点是用户的增加，即客户端数的增加。还有一个潜在的问题就是在一个线程的生命周期中，其大部分时间都是在等待，这也符合我们的场景，大部分时候，我们都是在等待着数据库查询。

我们可不可以实现类似于OS中的时间片轮转的调度算法呢？即一个线程对应多个客户端的请求，当请求在等待io的时候，进行切换，或者按照时间片进行切换。

![img](https://static001.geekbang.org/resource/image/ea/1f/eafed0787b82b0b428e1ec0927029f1f.png)

这个时候另一个矛盾点出现了，就是原先java的io都是BIO，即阻塞型IO，这个IO的含义是我一个线程在read的时候，会阻塞在那边，虽然我不用但是我也不能给别人用。

一种新的io交互方式的出现在情理之中了。NIO登场。NIO的出现就是为了解决这种一个线程处置多个连接的场景。

NIO只是提供了非阻塞处置请求的方法，但是具体要怎么使用这些方法来满足我们的需求，这还需要来分析。

一个常见的处置可伸缩性的网络服务的方式是Reactor Pattern。







