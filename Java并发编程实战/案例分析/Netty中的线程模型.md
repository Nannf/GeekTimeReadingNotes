#### 概览

纵观下来，这个和多线程的关系也不大。只是多线程时的一个解决方案。

使用了其中避免共享的思想。

核心还是Reactor Pattern.

本文尝试对 Reactor Pattern 进行一个初步的了解。

了解包括这个的使用场景，和具体的解决措施。

具体的可以参照Doug Lea的论文来细读。



#### 发展过程

##### 阻塞阶段

这个阶段的特征是：

- 对每一个客户端的请求而言，服务端都使用一个单独的线程去处理
- 这边作者说了会阻塞，其实阻塞是有事件的，比如等待io时阻塞
- 总的来说，就是客户端一个连接，服务端一个线程，这个线程会因为等待磁盘io或者网络io而处于不可用状态。

![img](https://static001.geekbang.org/resource/image/e7/e2/e712c37ea0483e9dde0d6efe76e687e2.png)



这个阶段的业务驱动点是用户的增加，即客户端数的增加。还有一个潜在的问题就是在一个线程的生命周期中，其大部分时间都是在等待，这也符合我们的场景，大部分时候，我们都是在等待着数据库查询。

我们可不可以实现类似于OS中的时间片轮转的调度算法呢？即一个线程对应多个客户端的请求，当请求在等待io的时候，进行切换，或者按照时间片进行切换。

![img](https://static001.geekbang.org/resource/image/ea/1f/eafed0787b82b0b428e1ec0927029f1f.png)

这个时候另一个矛盾点出现了，就是原先java的io都是BIO，即阻塞型IO，这个IO的含义是我一个线程在read的时候，会阻塞在那边，虽然我不用但是我也不能给别人用。

一种新的io交互方式的出现在情理之中了。NIO登场。NIO的出现就是为了解决这种一个线程处置多个连接的场景。

NIO只是提供了非阻塞处置请求的方法，但是具体要怎么使用这些方法来满足我们的需求，这还需要来分析。

一个常见的处置可伸缩性的网络服务的方式是Reactor Pattern。



#### 初识Reactor Pattern

![img](https://static001.geekbang.org/resource/image/a7/40/a7ba3c8d6c49e50d9288baf0c03fa240.png)



- Handler IO句柄，其实就是网络连接
- Synchronous Event Demutiplexer 操作系统提供的多路复用的API，这个存在的目的是监听网络事件，当网络事件准备就绪的时候，会通知Reactor,反应器做出的反应就是遍历自己所有的事件处理器去处理准备就绪的网络事件
- Event Handler 就是对应的网络事件的处理器
- Reactor 这个就是核心，是一个任务分发器，从SED那边接收网络请求，在遍历所有注册的事件处理器对网络事件进行处理。



#### Netty中的Reactor

EventLoop(事件循环) --> Reactor





