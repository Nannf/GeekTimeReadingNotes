#### 死锁条件

- 线程占用资源之后会等待，并不释放
- 线程持有的资源不能被抢占
- 出现了循环等待
- 互斥

这个互斥我没搞懂，我们来分析一下，为什么死锁一定要互斥呢？

首先我们要明白什么叫互斥，就是关于一个资源，最多只有一个线程可以持有，这个是必须的，就是不能同时持有，然后才有循环等待的问题。



只要破坏四个条件的任何一个，就能破坏死锁。



因为我们的synchronized关键词就是互斥的，所以我们得从另外三个条件下功夫：

- 可以给等待时间设置超时时间，也可以一下子获取所有的资源，不然就不执行代码
- 抢占有点流氓了，而且抢占对原有的线程造成的影响不好评估，首先原因线程如何感知到被抢占了是一个问题，抢占了之后，如何清理又是一个问题
- 循环等待，这个因为申请资源没有顺序，我们可以按照顺序来申请，这个也只是理论上的可行性。









