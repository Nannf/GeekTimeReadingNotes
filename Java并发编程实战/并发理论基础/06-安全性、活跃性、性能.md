缓存导致的可见性，指令重排导致的有序性，时间片轮转导致的原子性。

是所有并发安全问题的罪魁祸首。

就并发编程而言，我们首先考虑的是什么？

就是安全，之所以有安全问题，因为涉及到对共享资源的读写操作。

共享资源的读写会涉及到

- 竞态条件： 程序运行的结果有随机性，取决于线程的调度顺序。

```java
private int i = 0;

public void addOne() {
    i++;
}
```

当我们有两个线程同时调用`addOne()`方法，那么要取得我们预期结果（i=2），我们必须依赖于运气。

为了保证对共享资源的读写操作的正确性，我们需要引入临界区的概念，即同一时间，关于一组共享变量的操作，只能有一个线程在操作，且在线程退出临界区之前，其他线程不能进入临界区。

我们为了性能引入了多线程，又因为安全问题，把其中关于共享变量的操作部分改为了串行操作。

不考虑实现，我们知道，最大粒度的锁就是全局锁，即单线程时代。

我们还可以细化锁的粒度，一个共享资源一把锁，但是当我们细化了锁的粒度，一个操作需要的锁的种类变多

- 死锁
- 得不到锁资源



#### 思考

```java
void addIfNotExist(Vector v, 
    Object o){
  if(!v.contains(o)) {
    v.add(o);
  }
}
```

是否有线程安全问题？



```text
答： 我们要判断是否有线程安全问题，需要先对线程安全问题进行一个定义。
最简单的就是当多个线程同时调用这个方法时，这个方法能否和声明的语义一样正常工作？
我们发现是不可以的，Vector只保证在add或者contains的时候，只有一个线程在工作，但是这个不是原子操作，是会有线程切换导致的原子性问题。

```



