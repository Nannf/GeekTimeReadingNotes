#### 延迟 & 吞吐量

延迟是一个请求的响应时间；

吞吐量是一个时间段内一共处理了多少请求。

假设每个请求的延迟都是一样的，那么我们单纯的考虑如何降低延迟就可以提高吞吐量。

但是这个只是一个美好的愿望。

我们知道java的垃圾收集器，就有以降低单次延迟的处理器，以及提高一段时间内回收内存（即吞吐量）的处理器。

所以很大意义上来说，延迟和吞吐量是背道而驰的。



我们的程序设置多少线程数才是好的呢？

其实这个只是一个理论值，因为jvm自己会启动很多后台的线程，整个os也不是只有我们一个程序在跑，所以既然我们的cpu不是独占的，所以这就注定了我们的估算只是一个大概。



#### 线程数越高越好吗

我们程序在启动的时候从数据库里或者文件里读了一次数据，然后后续的所有操作都是在cpu中计算的，如果此时的线程数很多，我们就发现很多的时间都被用来做线程切换了，本来线程切换是因为比起等待io的时间来说，我们的线程切换耗时可以忽略不计，当我们不在等待io的时候，此时的线程切换成本就是我们的最大开销了。

综上，我们要区分我们的程序是计算密集型还是io密集型。

这个主要看我们的业务，是读数据库读网络的比较多，还是数据处理比较多；

这还要求我们的程序给出日志打印，表示出我们耗在io上的时间，以及计算上的时间。最好的状态是，一个线程在执行io等待的时候，别的线程全部都在进行cpu运算。

这种理想情况下cpu和io的利用率都是100%。

所以，假设我们的cpu是单核的。

T(I/O) / T (cpu) 就是最大的值。

考虑到cpu执行的时候，可能有的会因为访问的数据页不在内存中，而进行磁盘读取，所以我们需要在这个基础上 新增一个线程数

1 + T(I/O) / T(CPU)





#### 思考题

> 有些同学对于最佳线程数的设置积累了一些经验值，认为对于 I/O 密集型应用，最佳线程数应该为：2 * CPU 的核数 + 1，你觉得这个经验值合理吗？



```text
答： 默认认为io和cpu的耗时比是2：1，不做评价。
```

