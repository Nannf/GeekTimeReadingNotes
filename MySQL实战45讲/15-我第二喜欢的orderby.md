#### 前言

到了我第二喜欢的order by 环节

看之前有个问题，如果表里有一亿条数据，难道排序也是把所有的记录全处理吗？写完这个问题，我感觉我像个脑残，不然呢。



#### 排序的地方

##### 是内存还是磁盘？

如果内存够用的话，就在内存中排，不够的话就用磁盘归并排序。

##### 够不够用是相对于什么来说的？

这取决于排序需要用到的字段。

##### 排序用到哪些字段呢？

取决于我们最后返回的字段是否大于一个参数`max_length_for_sort_data`，这个会把要返回的字段(个人感觉，这边也要加上排序的字段)的定义长度加起来判断是否大于这个，如果大于这个参数，只会把排序字段和主键id放到排序内存中用来排序，否则会把要返回的字段和排序的所有字段全部加载进内存排序。

##### 排序字段要不是索引怎么办

那就是全表扫描，建议所有的排序字段最后都是索引。

##### 排序的步骤是什么样子的

我们假定排序的字段已经建了索引，且我们是单条件查询，我们首先会找到那个索引树，为了方便叙述，我们使用如下的例子来说明。

```mysql

CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `city` varchar(16) NOT NULL,
  `name` varchar(16) NOT NULL,
  `age` int(11) NOT NULL,
  `addr` varchar(128) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `city` (`city`)
) ENGINE=InnoDB;
```

```mysql

select city,name,age from t where city='杭州' order by name limit 1000  ;
```

![img](https://static001.geekbang.org/resource/image/53/3e/5334cca9118be14bde95ec94b02f0a3e.png)

1. 初始化sort_buffer 确定放入name、city、age三个字段。sort_buffer是mysql未每个线程分配的用来排序的内存。
2. 第一步查询city对应的索引树，找到杭州出现的第一个位置，记录下它的id
3. 到主键索引上去除id对应的name，city，age三个字段，放到sort_buffer中
4. 到city索引上接着去下一条记录判断是否满足条件，如果满足重复2、3步骤，知道遇到第一个city不是杭州的为止。
5. 对sort_buffer中的字段按照name排序
6. 返回给服务器端

其中第五步，排序的时候，因为sort_buffer的大小是确定的，是通过参数控制的，但是我们实际排序需要的大小是未知的，如果超过了给的的sort_buffer的大小，我们就会把本次排序的内容写到磁盘的文件上，进行外部归并排序，这边我猜测的逻辑是先都放在sortbuffer中，发现放不下了之后在写到磁盘上，这个操作也是比较耗时的，随意有了一个参数控制，就是要放到sort_buffer中的字段的定义长度加起来是否超过某个阈值，如果超过了某个阈值，就可能导致sort_buffer 放不下的概率比较大，为了减少从内存中再落盘这一步操作，我们就不把所有要返回的字段都放进 sort_buffer中了，而仅仅是把排序用到的字段和能唯一定位记录的主键id放到sort_buffer 放进缓存，这就是另外一种**rowid排序**。



我们发现这种只是一个预估，只是代表一个概率，为了减少磁盘排序出现的一种概率，当然当我们的表数据很小的时候，但是我们的字段长度定义的比较大的时候，这个时候会增加一个根据主键id去回表的操作，算是一种逆优化。

> 这边其实我有个问题，是根据字段定义的长度吗？我在数据库中经常定义字段的长度是varchar0 这个是怎么算的呢？还有text？

我们都知道，使用磁盘进行外部排序的速度有点慢，而导致这个问题的原因就是我们放到sort_buffer中的字段太多了，我们可以只把order by用到的字段以及定位一条记录的主键id放到sort_buffer中，这样就可以节省了内存，但是这样有个什么问题，就是一旦我们这样做，我们最后还有一个根据主键id回表的操作，查询返回字段的操作，当然这个可以使用覆盖索引优化。



我们看到这边是一个权衡，在内存中的排序速度是优于磁盘上的排序的，但是内存的空间有限，我们为了能够使用内存排序，只把排序用到的字段，以及定位记录的字段放到sort_buffer中，当然这种虽然减少了排序的开销，在没有使用覆盖索引的情况下，会多一步回表的操作，但是覆盖索引并不能为了每一种查询都建一个，因为磁盘空间有限。



当然如果数据量达到亿级，甚至更多，我们就算只用一个字段，可能sort_buffer也存储不下而使用磁盘进行外部排序。

这种有咩有办法优化呢？

其实是有的，就是排序的字段和条件字段是联合索引。

```mysql
select city,name,age from t where city='杭州' order by name limit 1000  ;
```

如果我们在这个表上建立了(city,name)的联合索引，那么当city字段是杭州的时候，name字段天然有序，只要一直往后读就行，知道遇到不满足条件的。

但是无论是覆盖索引也好，联合索引也罢，基本上只能针对热点查询的一种优化，可在特定场合使用。

一般而言，rowid排序会导致更多的回表查询操作，这就意味着更多的磁盘访问，一般不推荐使用这种方式。



#### 思考题

假设你的表里面已经有了 city_name(city, name) 这个联合索引，然后你要查杭州和苏州两个城市中所有的市民的姓名，并且按名字排序，显示前 100 条记录。如果 SQL 查询语句是这么写的 ：

```mysql
mysql> select * from t where city in ('杭州',"苏州") order by name limit 100;
```

那么，这个语句执行的时候会有排序过程吗，为什么？

如果业务端代码由你来开发，需要实现一个在数据库端不需要排序的方案，你会怎么实现呢？

进一步地，如果有分页需求，要显示第 101 页，也就是说语句最后要改成 “limit 10000,100”， 你的实现方法又会是什么呢？



答：

1. 语句执行的时候会有排序过程吗？
   - in 会走索引吗？百度得到的是走的，我们猜测这边是会走的，最理想的情况是把杭州的以及苏州的全部取出来放到sort_buffer中，然后这两个之间还要角逐取出前100条的
   - 因为联合索引只保证当city一样的时候，name有序，并不保证city不一样的时候name有序，所以这个是会走排序的。
2. 如果我开发会怎么做？
   - 把排序的放到服务端自己做
   - 具体而言就是使用union分别获取杭州和苏州的100条数据，然后排序放到服务端，这种数据库端就无需排序了
3. 我的实现方法是什么？
   - 我歇逼了，我是废物。
   - 这个问题就在如果我要选前100条，那么我两个城市最多都取100条，前100条一定出现在两个城市各自对应的100条呢，但是第101页，这个就不一定了，之所以不一定是因为前10000条数据可能全是苏州的或者全是杭州的，如果是这样的话，我们根本没有办法union。这边其实是一样的，就是第101页的数据一定是杭州的前101页和苏州的前101页一起的，然后unionall得出来的，我之所以没有这样想是因为我在业务上根本不会这样去写，这样从客户端返回的数据就特别多了，当然我们也可以只返回id和排序需要的字段，然后再根据id去获取需要的记录信息，但是这种为了不让数据库排序而引入的网络传输量的增加，似乎也不是一个恰当的解决方案，而且实际中极难遇到客户需要翻看100页之后的数据的情况，这种极少遇见的情况我觉得对性能的要求可以不是很高。



#### 课后补充

##### sort buffer 是再哪边的

server 层，每次取数据都需要调存储引擎的接口取获取数据，特别的，如果是rowid排序，会调用两次





