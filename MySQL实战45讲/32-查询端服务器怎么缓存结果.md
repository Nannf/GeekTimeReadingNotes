#### 前言

本文的大致行文思路是从`如果服务器端的内存小于服务器端的磁盘，那么我进行全表扫描的时候会不会把服务器的内存打爆`这个问题出发，引出了查询时服务器端和客户端进行交互的核心流程。



#### 全表扫描时服务器端都做了什么

>  innodb的数据都是存储在主键索引上的



##### 服务器端的发送数据流程

跟java8的流一样，不是全部加载进内存，而是用多少取多少。

1. 获取数据到net_buffer中，net_buffer可以配置，默认16kb
2. 重复获取满足条件的行，直到把net_buffer打满，调用网络接口发送数据
3. 如果发送成功，就清空net_buffer，重复上面的操作
4. 如果发送函数返回EAGAIN或者WSAEWOULDBLOCK，表示本地网络栈socket_send_buffer写满了，需要等待本地网络栈重新可用。

![img](https://static001.geekbang.org/resource/image/a0/bd/a027c300d7dde8cea4fad8f34b670ebd.jpg)

从上述流程我们可以得知：

1. 一个连接，最多只会占用net_buffer_size个内存
2. socket send buffer也不会很大。



总的来说，mysql是边读边发的。这边有个生产者消费者的模型。socket_send_buffer就充当消息队列，如果客户端消费的慢了，会导致服务端的发送被卡住，会导致连接耗时比较长，会导致mysql性能的下降。

![img](https://static001.geekbang.org/resource/image/18/c3/183a704d4495bebbc13c524695b5b6c3.png)

show processlist 看到state处于 Sending to client 状态的连接就是服务端网络栈写满的状态。

我们在上一节提到的-quick参数，开启之后，服务端传一条数据，客户端处理一条，根本不使用本地缓存，假如客户端处理的非常慢，那么就会导致服务端发送阻塞。

这个用到了两个参数

mysql_use_result和mysql_store_result。前者就是单线程处理，后者是用客户端返回所有的查询结果，虽然服务端还是分批传送的，但是不会被卡住。



这里有个问题：如果你在执行show processlist的时候，看到很多的state都是处于Sending to client状态，此时你要怎么优化？

1. 很多连接，但是我们用的是一个socket吗？应该不是吧说明是多个连接都出现这种情况了，这种情况不是因为客户端的消费速度跟不上服务端的发送速度了吗?我们可以让服务端少发点，这样就能均衡二者的速度
2. 或者让客户端处理的快一点比如使用mysql_store_result
3. 或者把net_buffer size调大，这个完全是无奈之举，调大之后，最后一次服务端发送的时候，本次查询结束，会释放本次查询占用的锁之类的资源，但是效果并不好。



##### Sending to client 和Sending data是什么关系

这个涉及到一个查询连接在执行过程中的state变化。

1. 当mysql进入查询阶段之后，就会把状态改为Sending data
2. 发送查询结果的元数据信息给客户端
3. 执行发送流程
4. 发送结束后，把状态设置为空字符串。

Sending data 可以出现在发送开始到完成的任意时间点。这个状态表示查询正在执行。

如果是Sending to client 表示线程处在等待客户端接受结果的状态。





#### 全表扫描对InnoDB的影响

作者的行文为啥到了这边呢？

作者的行文一开始是说如果我对一个很大的表进行全表扫描，会不会把服务端的内存打爆，后来一波论证得出结论，说是不会。

论证中提到了很重要的一点，就是全表扫描大数据量的情况下会导致连接的存活时间很长，连接时间一旦长起来，会导致连接占用的资源得不到释放，可能还 会有其他的影响。



