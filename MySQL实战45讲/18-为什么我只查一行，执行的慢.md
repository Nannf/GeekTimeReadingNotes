#### 前言

我返回的记录数不多，意味着存储引擎和服务端，已经服务端和客户端的网络通信耗时不长，执行的慢应该就出在存储引擎定位这条语句的时间了。

但是我们知道，如果不出意外的话，我们查询时使用了索引，就算没有覆盖索引，我们也仅仅是回一次表，这其实都是不咋耗时的，我想这里的耗时一定是非查询耗时，还加上了一些等待，比如等待某个锁。



通读一遍文章之后，发现大部分都跟锁有关，还有一部分是跟一致性读有关的，是我之前没有想过的，下面我们就一个一个来阐述下吧。

```mysql
-- 假设我们有表t，如下
mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

delimiter ;;
create procedure idata()
begin
  declare i int;
  set i=1;
  while(i<=100000) do
    insert into t values(i,i);
    set i=i+1;
  end while;
end;;
delimiter ;

call idata();
```

#### 锁导致的查询慢

##### 表级锁

```mysql
select * from t where id = 1;
```

这行语句正常情况下返回的很快，倘若一直没有返回，我们就可以使用

`show processlist`命令查看，是否请求在等待MDL锁，这个复现的场景是另开一个查询连接，执行 lock table t write;

我们执行show 命令后，可以看到这个连接的 **state **行展示的是Waiting for table metadata lock；

解决方案是，我们首先要定位到占用锁的pid是啥，然后评估长时间占用不释放的原因，和相应的开发人员商量是否可以直接kill掉连接，如果可以的话就直接kill掉。



#### 等flush

其实这个的原理和锁是类似的，也是一个锁，就是当我们对表进行flush操作的时候，会等待要关闭的锁上的操作全部执行完成，如果我们在一个表上的执行时间过久，那么就会导致flush被阻塞，而后续的关于这个表的其他请求都会等待flush的执行完成才能执行。





##### 行锁

这个之前说锁的时候也知道，就是我开启一个事务，我执行update 语句 ，但是我事务不提交，我就一直占着行锁，后面的所有关于这一行的其他操作都会被阻塞。



#### 其他原因

##### 扫描行数很多

```mysql
select * from t where c = 50000 limit 1;
```

因为我们在c上没有索引，会按照自增主键的索引来扫描表，最后会扫描50000行。



##### 一致性读导致的查询慢

```mysql
select * from t where id = 1;
```

当我们执行这个语句的时候需要耗时800ms；

```mysql
select * from t where id = 1 lock in share mode;
```

当我们执行这个语句的时候，仅需要0.2ms，这个速度才是正常的速度；

但是第二个明明还多了一个加锁操作，为什么还比第一个快那么多，第二个加锁之后，读的是最新值，除非当前的事务隔离级别是一致性读，而且我们开启事务和我们读取直接有别的连接做了很多更新操作，让我们在读取的时候需要根据undolog一级一级去回退。

事实也确实如此。





#### 思考题

我们在举例加锁读的时候，用的是这个语句，

select * from t where id=1 lock in share mode。

由于 id 上有索引，

所以可以直接定位到 id=1 这一行，

因此读锁也是只加在了这一行上。

但如果是下面的 SQL 语句，

```mysql
begin;
select * from t where c=5 for update;
commit;
```

这个语句序列是怎么加锁的呢？加的锁又是什么时候释放呢？



解： 因为c不是主键，也不是索引，可能需要先从主键索引上，遍历得到所有c=5的行，然后把这些行全部锁上，但是有个问题，这个c字段因为没有唯一性约束，所以可能有多个，加行锁的时候，可能会等待，我猜测这个如果没有全加成功，会导致这个事务回滚。

