#### 前言

从来没有过这种操作。



#### kill 语句的分类

1. kill query + 线程id
2. kill connection + 线程id 直接杀死连接，如果当前连接有正在执行的语句，那么会先终止这个正在执行的语句。



##### kill 语句的使用场景

###### 查询语句执行时间很长，我们不想执行了，直接kill

###### 语句遇到锁等待，直接kill



#### kill语句的背后发生了什么

告诉这个执行语句，你可以准备结束了。执行语句接受到这个信号之后就做一些结束动作。

我们想象的kill，这个执行语句应该瞬间去世，就当从没有出现过，但是这个执行语句在执行的过程中申请了一些资源，需要释放掉。

准确说来做了两件事：

1. 把这个线程的状态改为需要被终止THD::KILL_QUERY
2. 发个信号给这个线程

发信号的原因是因为线程可以处于锁等待状态，它需要一个机制去离开这个状态，并进行状态的判断。

这也有几个前提：

1. 这个等待是可以被唤醒的
2. 唤醒之后是有状态判断的
3. 从检测到终止状态的信号到实际终止是有过程的。

如果一个等待是不可被唤醒的，或者唤醒之后不会去检测，或者检测到终止信号到实际的停止耗时较长，都会出现kill不掉的情况

下面逐个来说明

#### kill失败的场景

set global innodb_thread_concurrency=2

![img](https://static001.geekbang.org/resource/image/32/6e/32e4341409fabfe271db3dd4c4df696e.png)

![img](https://static001.geekbang.org/resource/image/91/53/915c20e4c11b104d7bcf9d3457304c53.png)



这个对应的就是我们说的唤醒之后不会去检测状态的场景。

如果我们的查询是因为等待行锁而阻塞，使用的是pthread_cond_timedwait，这个等待可以被唤醒，唤醒之后也会去检测线程的状态。

而在这里，使用的是nanosleep函数，每10ms执行一次，看看能否进入innodb执行，如果不行就接着睡10ms，这个睡眠-睡醒的过程中，没有去判断状态，只有这个查询实际获取到innodb执行调度的时候，才可能去检测线程状态。

这种可以概括成没有执行到线程的判断逻辑。



还有就是耗时过长，就是我线程已经检测到停止的状态了，但是清理操作耗时较久。

比如什么超大的事务执行期间被kill，大查询回滚要删除临时文件等。



#### 掩耳盗铃

##### 客户端的ctrl c 可以对服务端造成影响

这个命令的执行顺序是开启一个新的连接，然后执行kill connection 把自己给断开。

根本不会对服务端造成任何影响。



##### 库表数量大，会导致客户端连接变慢

比如出现下图所示的场景

![img](https://static001.geekbang.org/resource/image/7e/83/7e4666bfd580505180c77447d1f44c83.png)

我们知道客户端连接的时候只是单纯的tcp握手，跟你服务器有多少表一点关系都没有。

但是除了这个连接之外客户端还做了一些别的工作：就是可以让你在输入表名或者字段名的时候进行自动补全，这个的步骤是：

1. show database
2. 切换到db1库，show tables
3. 构建一个本地的类似hash表的结构，目标就是完成内容的补全

主要的耗时操作在第三步，这个已经是连接上之后做的事情，所以我们说连接慢不太对，这个可以通过在连接语句中使用-A取消这个功能。



##### mysql -quick 贼猛，可以加速

加什么速？ -quick 做了什么事情？ 

1. 跟上面的-A一样，跳过了补全功能
2. 不使用本地缓存
3. 不会把命令记录到本地的命令历史文件

关于第二条，发生在服务器给客户端返回数据的阶段。

服务器端给客户端生产数据和客户端消费数据，如果客户端处理的贼慢，且不使用缓存的话，会导致服务器的返回数据都卡在服务器的内存里，还会占用其他的资源。

这个本地缓存跟消息队列差不多，解决生产者和消费者速度不一的问题。



