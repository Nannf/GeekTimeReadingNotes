#### 前言

我没看懂这个题目其实

看了作者的描述我发现这个就是字面意思，如何从数据库里随机的返回一部分数据。

我在实际的工作场景中没有遇到这种需求，做个简单的了解吧，等有需求的时候再回来看具体的使用。



##### order by rand()实现

```mysql
mysql> select word from words order by rand() limit 3;
```

![img](https://static001.geekbang.org/resource/image/59/50/59a4fb0165b7ce1184e41f2d061ce350.png)

执行计划如上图所示，其中我们需要关注的是`Extra`列的Using temporary; 和 Using filesort 前者表明了这个需要用到临时表，后者表明需要进行排序。

排序就用到我们上节说的内容了，这个时rowid排序还是全字段排序呢？

在上节中，我们说因为rowid排序会有更多的磁盘io，对InnoDB而言是不会选择的，除非要返回的字段的字段的长度超过了一个参数配置的阈值。

但是这个默认的是1024字节，如果返回的字段长度加上排序的字段长度超过了这个就会使用rowid排序。

以上说的内容是基于InnoDb引擎的表，我们避免使用rowid是因为最后会回表，回表是磁盘i/o;

但是我们这里用到的是临时表，临时表是存放在内存中（准确的说使用的memory引擎），但是内存的容量也是有限的，如果表的数据量大还是会在磁盘进行外部排序的。

memory引擎不是索引组织的表，更像是一个数组，根据下标定位数据。

就跟我们上面说的那样，也是有一个参数控制临时表的大小，如果超过这个大小，会把文件转移到磁盘上，构成磁盘临时表。

我们假设内存不够用，使用的磁盘，我们把需要返回的字段和排序的字段，全部加载进内存临时表，但是发现数据量比较大，超过了设置的阈值，我们就把数据持久化到磁盘上。

上一步说错了，这个其实是先写到sort_buffer中。

上一步我仍然理解错了，sort_buffer是排序就会用到的，并不是一个单独出现的内存。

所以数据是先加载进内存临时表的，但是表中存放的不是全部数据，而是