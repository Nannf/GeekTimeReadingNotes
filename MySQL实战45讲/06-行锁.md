### 行锁

#### 行锁的实现位置

存储引擎，之前MySQL自带的存储引擎MyISAM是不支持的，如果需要改一张表的数据，需要锁表，代价比较大。

> MyISAM被InnoDB替换的两个原因：1. 不支持事务；2，不支持行锁。



#### 行锁的定义

线程在修改表中一个记录的时候，会先申请锁，后续对改行的修改会被阻塞，直到我事务结束。

**注意这里的释放时机，不是修改完成，而是事务执行完成，如果有长事务的存在，还是会有那种后续更新全部失败的情况。**



#### 死锁

因为一个事务的修改不一定只修改一条记录，这种就极可能出现，A事务先修改了记录一，接着修改记录二，而B事务是恰好相反的。

这就意味着他们可能出现死锁。

解决方案主要是有两个：

一个是设置超时时间，如果事务运行超时了，就直接回滚之前的操作，这个需要客户端进行重试处理。这种的问题是，超时的时间不好设置，因为如果超时时间过短，我们就会把一些正常的锁等待给回滚了；如果超时时间过长，而他确实存在死锁，这时候再回滚，对业务而言不可接受（MySQL的默认超时时间是50s）;

还有一种就是做死锁检测，比如没有一个事务，在查询之前都会去检测我的加入会不会导致死锁，这需要分析所有事务的锁依赖关系，如果有1000个事务，那每个事务都要检测1000次（其实这边有个疑惑，因为第一个运行的事务不用检测，后面的应该是0+1+2+....+999）等差数列求和，复杂度是O(N^2),比较耗时，正常的情况是，事务一旦躲起来，会把CPU直接拉满。

