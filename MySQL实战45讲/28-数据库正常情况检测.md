#### 前言

我们要怎么判断一个数据库是不是正常在运行呢? 

我们为什么要问这个问题呢？因为主备切换主要发生在HA系统检测到主库出问题了的时候主动发生的切换。



我觉得是要对这个正常的边界进行一个明确。



读完本章之后发现就是这个边界的问题，导致了不同的判断方式。



#### 主库进程还在，就是好的

select 就是在这个边界下产生的。

我们看如下的一段sql序列

```mysql
set global innodb_thread_concurrency=3;

CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

 insert into t values(1,1)
```

![img](https://static001.geekbang.org/resource/image/35/55/35076dd3d0a0d44d22b76d2a29885255.png)

###### innodb_thread_concurrency

这个参数控制的是innodb并发线程的上限。当达到这个上限的时候，如果服务器接收到新的查询请求，会被放到等待队列，直到有查询线程返回。当是0的时候，表示不限制查询并发线程数，服务器的资源有限，这个不限制会导致cpu进行频繁的上下文切换，没有起到加速的效果。

###### 并发连接和并发查询

show processlist 结果可以有数千个连接，这个是并发连接，但是当前处于执行状态的语句才是并发查询。

并发连接数是存放在内存中，并发查询耗费的是cpu。



当线程进入锁等待之后，并发线程数会减一。

这个其实很好理解，并发线程出现的目的是为了加速查询的效率，极端情况下，我一个线程持有一个行锁不释放，后续来的线程恰好都要修改这一行，而这些查询线程数量达到了并发线程的上限，这样数据库服务器就停止对外提供服务，这样cpu的使用率很低，但是没办法处理请求。

这个是不合理的，所以要减一。



###### 问题

这个问题是当并发线程达到上限后，因为select 1并没有实际的查表操作，所以检测不出这种异常。





##### 数据库没有达到并发查询的上限

这个的操作是查一张实际的表。这个存在的目的就是为了解决select 1 解决不了的并发线程满的问题。



但是我们查哪张表好呢？能查业务表吗？不大好吧，不好在哪呢？万一有锁怎么办，什么锁能阻挠select ，我来想想，行锁可以吗，查询会被锁住吗？卧槽我忘记了，我猜测是不会的，除非显式的加了表锁，这个我明天去验证一下。

所以我们可以专门建一个空表，每次都查询这个空表来判断并发线程有没有到达设置的阈值的场景。



###### 问题

我们知道空间满了之后，binlog这些都没办法写了，但是查询语句是不记录binlog的，所以这个解决不了空间满的问题。







