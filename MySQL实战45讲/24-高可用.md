#### 前言

高可用。

上文我们在谈主备的时候，我们知道了主库在执行一条影响数据库状态的sql后，会把这个记录的binlog传给备库，备库接受这个binlog然后转换成中转日志，接着解析落库。

这一套执行下来就算是跑通的，就是主库和备库之间能达到最终一致性。

问题就在备库什么时候能达到和主库一致的状态，不然假设此时主库断电，你的备库和主库还差了数小时，那我们不能说主备就是高可用的。



所以高可用应该包含 最终一致性，而且主备之间的延迟要低。



##### 主备延迟

![img](https://static001.geekbang.org/resource/image/89/cc/89290bbcf454ff9a3dc5de42a85a69cc.png)

高可用意味着什么，意味着我们就算主库宕机了，无论是主动的还是被动的，我们的服务依然可以对外服务，这就要求主备之间的延迟不能太长，最好不要有。

那主备延迟是由什么引起的呢？

我们在上一章讲主备的时候，我们知道，主库写完binlog的时间，我们记为T1，备库把binlog转换为relaylog的时间点我们记为T2,备库把中转日志完成入库的时间点，我们记为T3。

主备的延迟时间，就是 T3 - T1。

如果我们在备库上执行 `show slave status`命令，会看到一个参数seconds_behind_master。

这个参数是怎么算出来的呢

![img](https://static001.geekbang.org/resource/image/c3/c2/c342cf480d23b05d30a294b114cebfc2.png)

拿到我们上一讲中的binlog的内容，当时我们忽略了一个东西，就是时间。

备库在解析中转日志的时候，会提取到这个时间字段，并和自己的时间做对比，算出的差值，就是最后的结果。



1. 结果就是我们刚刚说的T3-T1;
2. 两个系统的时间不一致怎么办？这个不强求一样，只是备库在连接到主库的时候，会算出主库的时间，然后再算自己的时间，计算其中的差值，然后再计算T3-T1的时候把这个差值考虑进去，就是最后的结果。



T3 - T1 = T3 - T2 + (T2 - T1);

当网络状况良好的时候，T2-T1耗时是很短的，可以忽略不记。

即T3 - T1 = T3  - T2,这个时间段是什么，就是备库执行binlog还原数据的时间。

让我们回到mysql服务刚开始运行，这时候没有任何日志，此时主库开始产生binlog，产生完之后传给了备库，经过我们刚刚的分析，传输的耗时基本可以忽略不记，倘若如此，那么备库在主库完成binlog的一刹那就开始执行恢复任务，倘若备库执行时间也可以忽略不计，那么二者之间就是没有时间差的。此时A源源不断的产生binlog，B都消费的很快。A负责写binlog,B负责读binlog,一个生产者消费者，当有延迟的时候，就说明消费能力赶不上生产能力了。



#### 原因探究

##### 备库性能不行

一般这种情况很少见，这种主要是搞错了备库的角色定位，以为备库只是简单的做做查询。没有意识到主备切换的意义。一般备库的机器配置与主库都相去甚远，更有甚者还会把很多个主库的备库都放到一个服务器上。

更新操作对IOPS的压力在主库和备库都是一样的。

我们在再谈可靠性一文中描述过，最好的安全性就是binlog的落盘参数和redolog的落盘参数都定为双一。这个就意味着完全放弃了缓存的优化，无论是文件系统提供的pagecache还是mysql服务本身提供的缓存，这种是最慢的，但是是最可靠的。

假设主库开启了双一，备库的性能跟不上主库的情况下，似乎备库只有使用缓存，不使用双一来赶上主库的速度。

不过目前这种情况越来越少了，基本主库和备库都是对称配置，不分彼此。

做了对称部署，主备还是会有延迟

##### 备库压力大

一般而言都是主库提供写能力，大家觉得备库的压力不大，就再备库上疯狂执行一些查询语句，造成备库的压力变大。

这种的解决方案是，既然你想跑些查询任务，如果对时间的要求不是很苛刻，可以再用几个从库出来，专门用作查询，从库和备库的区别就是，当发生主备切换时，会变成主库的那个就是备库，其他的是从库。

或者把binlog同步到hdfs上，然后再那个上面执行查询分析任务。



如果采用一主一备多从，使得备库的压力不大了，还有什么会导致主备延迟吗？

##### 大事务

###### 删除大量数据

我们知道binlog写入事务的逻辑是一次性全部写入的。如果采用的是row 格式的binlog，如果要执行删除操作，当删除的数据量比较大的时候，会导致要记录很多的数据，我们知道binlog的事务的时间是执行的时间，如果一个事务再A上执行了几分钟，那么当B拿到这个binlog的时候，主备的延迟就已经有了几分钟，如果这个时间超过了检测预警的主备延迟的时间线，那么就会产生预警信息。

###### 对大表做DDL

做ddl涉及到重建表，拷贝数据重放等一系列操作，会比较耗时。



###### 备库的并行复制能力

产生binlog和消费binlog不是一个程序，二者之间的时间并不是完全等同的，实际上我们再上一张主备的时候考虑过，最后一步解析中转日志到数据库中的时候，那一步是可以多线程并行的，这个消费速度如果跟不上生产速度也是会产生延迟的。





##### 关于高可用性和主备延迟的关系

刚刚突然想到这个话题，我们觉得高可用性达到极致，就是可以存在数台状态一致的服务，无论哪一台或者哪几台宕机了，剩下的机器都可以无损的对外提供服务，所以极致的主备延迟就是0，就意味着极致的高可用。



##### 当主备一定存在延迟的时候，我们如何进行主备切换呢？

我们的讨论先暂定在主动的主备切换，这意味着我们可以控制中断和切换的时机。

一般思考的方向就是数据的可靠性，和服务的可用性，两个方面是两个极端。我们先分别述之。



###### 可靠性优先的主备切换策略

**背景**

双M架构。主动切换

**步骤**

1. 判断备库B现在的seconds_behind_master，如果小于某个值（比如5s），如果没有继续重试
2. 把主库A改为只读状态
3. 判断B的seconds_behind_master的值，直到变成0为止
4. 把B的状态改为可读写状态
5. 把业务请求切换到B

一般这个由专门的HA（双机集群）系统来完成。

**我的问题**

1. 第一步可能永远卡死在那边，一般而言主备 对称的状态下，备机的延迟时间不会很长，而且主机也不是一直有binlog在产生，我们主备切换的时间一定是系统用的最少的时间，而这个时间，主备的延迟会随着生产者的停滞与消费者的持续消费而减少，为什么不设置成0呢？这个时间点比较难找，这个设置的时间点，就是第三步要等的时间点，其实不尽然，备库延迟了三秒，这个三秒不是说需要三秒才能入库。
2. 从第二步到第五步，服务处于暂停状态，这对业务而言是否可以接受

基于服务有不可用的问题，我们提出了可用性优先的主备切换策略。

###### 可用性优先的主备切换策略

把可靠性优先的步骤的4和5强行提前执行。并且不判断了，把A直接变成只读，把b变成可读写。

但是这种会出现数据不一致的例子

假设有表如下：

```mysql

mysql> CREATE TABLE `t` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `c` int(11) unsigned DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

insert into t(c) values(1),(2),(3);
```

此时主库A上和备库B上都有三条数据。

假设此时我要执行如下两条插入语句

```mysql
insert into t(c) values(4);
insert into t(c) values(5);
```

当我们插入4的时候，A已经插入完成，但是binlog还没有同步给B。

此时发生了主备切换，那么此时，B收到了插入c=5的语句。

这里分两种情况讨论。

1. binlog日志是mixed或者statement
   - 此时B中插入的是（4，5），然后B收到A的binlog，插入了（5，4）
   - A收到B的binlog，插入了（5，5）
   - 此时A和B的数据就不一致。且无法发现
2. 是row类型
   - B插入了（4，5），然后B收到了A的binlog（4，4）此时主键冲突报错
   - A收到了B的（4，5）主键冲突报错
   - 结果就是A插入了（4，4），B插入了（4，5）然后报错暂停。

由此我们可以看出，可用性优先会导致数据不一致，而且row格式的binlog能及时的发现这种数据不一致。

所以一般不推荐可用性优先的主备切换策略，推荐row格式的binlog。



是否可用性优先就一无是处了呢？

如果我们的服务需要记录一些日志类的操作，这些操作不会影响业务的正常运行，短暂的不一致我们也可以分析修正过来，那我们是否就可以把这个设置成可用性优先呢？是可以的但是不建议。



##### 异常情况下的主备切换

假设A和B的延迟时间是半小时，那此时A突然宕机，如何切换呢？

可不可以直接切换成B呢？

因为可靠性优先的情况下，第一步就会卡死，因为此时二者的时间不会减少（因为A宕机，所以B收不到A发来的binlog文件）

那可不可以直接切换呢？

也不行，因为此时数据的不一致比较大，对业务而言，比如我冲了100w，但是你没同步过来，我如果强行切换，发现我的100w没了，那我不是要骂娘。此时的可用性时候会成为麻烦的根源。



##### 思考题

![img](https://static001.geekbang.org/resource/image/cf/71/cf5ea52aa3b26ef56c567125197fa171.png)



图中发生了什么？

图中的主备延迟时间稳步提升。

生产者消费者的理论而言，要么生产的太快，要么消费的太慢。

生产的太快是什么场景，就是突然有大量的日志涌入，超过了备库的消费能力，消费的时候就已经慢了。

或者消费变慢了，变慢了可能是系统资源被占满了，导致一直需要等待资源。

但是这两个都解释不了图中的线性增长。

2021.3.27看完主备延迟后，我又回来了

确实我说的这个都无法造成这种线性的曲线。

因为是45度的曲线，说明随着时间的增加，备库一点都没有动，说明备库的更新不是跟不上，是完全被卡住了。

卡住的原因常见的有：

1. 备库起了一个长事务，就是没有提交的事务，比如

   ```mysql
   begin;
   select * from t;
   ```

   此时我们的主库修改了t的表结构，那么会因为获取不到锁而卡死。

2. 备库在执行一个超大的事务

   此时事务不结束，时间就会累积、。

但是我觉得这个是没开启并行复制的情况下，开启并行复制的情况下的主备延迟的时间我觉得是以最大的那个。