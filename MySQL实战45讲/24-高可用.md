#### 前言

高可用。

上文我们在谈主备的时候，我们知道了主库在执行一条影响数据库状态的sql后，会把这个记录的binlog传给备库，备库接受这个binlog然后转换成中转日志，接着解析落库。

这一套执行下来就算是跑通的，就是主库和备库之间能达到最终一致性。

问题就在备库什么时候能达到和主库一致的状态，不然假设此时主库断电，你的备库和主库还差了数小时，那我们不能说主备就是高可用的。



所以高可用应该包含 最终一致性，而且主备之间的延迟要低。



##### 主备延迟

![img](https://static001.geekbang.org/resource/image/89/cc/89290bbcf454ff9a3dc5de42a85a69cc.png)

高可用意味着什么，意味着我们就算主库宕机了，无论是主动的还是被动的，我们的服务依然可以对外服务，这就要求主备之间的延迟不能太长，最好不要有。

那主备延迟是由什么引起的呢？

我们在上一章讲主备的时候，我们知道，主库写完binlog的时间，我们记为T1，备库把binlog转换为relaylog的时间点我们记为T2,备库把中转日志完成入库的时间点，我们记为T3。

主备的延迟时间，就是 T3 - T1。

如果我们在备库上执行 `show slave status`命令，会看到一个参数seconds_behind_master。

这个参数是怎么算出来的呢

![img](https://static001.geekbang.org/resource/image/c3/c2/c342cf480d23b05d30a294b114cebfc2.png)

拿到我们上一讲中的binlog的内容，当时我们忽略了一个东西，就是时间。

备库在解析中转日志的时候，会提取到这个时间字段，并和自己的时间做对比，算出的差值，就是最后的结果。



1. 结果就是我们刚刚说的T3-T1;
2. 两个系统的时间不一致怎么办？这个不强求一样，只是备库在连接到主库的时候，会算出主库的时间，然后再算自己的时间，计算其中的差值，然后再计算T3-T1的时候把这个差值考虑进去，就是最后的结果。



T3 - T1 = T3 - T2 + (T2 - T1);

当网络状况良好的时候，T2-T1耗时是很短的，可以忽略不记。

即T3 - T1 = T3  - T2,这个时间段是什么，就是备库执行binlog还原数据的时间。

让我们回到mysql服务刚开始运行，这时候没有任何日志，此时主库开始产生binlog，产生完之后传给了备库，经过我们刚刚的分析，传输的耗时基本可以忽略不记，倘若如此，那么备库在主库完成binlog的一刹那就开始执行恢复任务，倘若备库执行时间也可以忽略不计，那么二者之间就是没有时间差的。此时A源源不断的产生binlog，B都消费的很快。A负责写binlog,B负责读binlog,一个生产者消费者，当有延迟的时候，就说明消费能力赶不上生产能力了。



