#### 前言

高可用。

上文我们在谈主备的时候，我们知道了主库在执行一条影响数据库状态的sql后，会把这个记录的binlog传给备库，备库接受这个binlog然后转换成中转日志，接着解析落库。

这一套执行下来就算是跑通的，就是主库和备库之间能达到最终一致性。

问题就在备库什么时候能达到和主库一致的状态，不然假设此时主库断电，你的备库和主库还差了数小时，那我们不能说主备就是高可用的。



所以高可用应该包含 最终一致性，而且主备之间的延迟要低。



##### 主备延迟

![img](https://static001.geekbang.org/resource/image/89/cc/89290bbcf454ff9a3dc5de42a85a69cc.png)

高可用意味着什么，意味着我们就算主库宕机了，无论是主动的还是被动的，我们的服务依然可以对外服务，这就要求主备之间的延迟不能太长，最好不要有。

那主备延迟是由什么引起的呢？

我们在上一章讲主备的时候，我们知道，主库写完binlog的时间，我们记为T1，备库把binlog转换为relaylog的时间点我们记为T2,备库把中转日志完成入库的时间点，我们记为T3。

主备的延迟时间，就是 T3 - T1。

如果我们在备库上执行 `show slave status`命令，会看到一个参数seconds_behind_master。

这个参数是怎么算出来的呢

![img](https://static001.geekbang.org/resource/image/c3/c2/c342cf480d23b05d30a294b114cebfc2.png)

拿到我们上一讲中的binlog的内容，当时我们忽略了一个东西，就是时间。

备库在解析中转日志的时候，会提取到这个时间字段，并和自己的时间做对比，算出的差值，就是最后的结果。



1. 结果就是我们刚刚说的T3-T1;
2. 两个系统的时间不一致怎么办？这个不强求一样，只是备库在连接到主库的时候，会算出主库的时间，然后再算自己的时间，计算其中的差值，然后再计算T3-T1的时候把这个差值考虑进去，就是最后的结果。



T3 - T1 = T3 - T2 + (T2 - T1);

当网络状况良好的时候，T2-T1耗时是很短的，可以忽略不记。

即T3 - T1 = T3  - T2,这个时间段是什么，就是备库执行binlog还原数据的时间。

让我们回到mysql服务刚开始运行，这时候没有任何日志，此时主库开始产生binlog，产生完之后传给了备库，经过我们刚刚的分析，传输的耗时基本可以忽略不记，倘若如此，那么备库在主库完成binlog的一刹那就开始执行恢复任务，倘若备库执行时间也可以忽略不计，那么二者之间就是没有时间差的。此时A源源不断的产生binlog，B都消费的很快。A负责写binlog,B负责读binlog,一个生产者消费者，当有延迟的时候，就说明消费能力赶不上生产能力了。



#### 原因探究

##### 备库性能不行

一般这种情况很少见，这种主要是搞错了备库的角色定位，以为备库只是简单的做做查询。没有意识到主备切换的意义。一般备库的机器配置与主库都相去甚远，更有甚者还会把很多个主库的备库都放到一个服务器上。

更新操作对IOPS的压力在主库和备库都是一样的。

我们在再谈可靠性一文中描述过，最好的安全性就是binlog的落盘参数和redolog的落盘参数都定为双一。这个就意味着完全放弃了缓存的优化，无论是文件系统提供的pagecache还是mysql服务本身提供的缓存，这种是最慢的，但是是最可靠的。

假设主库开启了双一，备库的性能跟不上主库的情况下，似乎备库只有使用缓存，不使用双一来赶上主库的速度。

不过目前这种情况越来越少了，基本主库和备库都是对称配置，不分彼此。

做了对称部署，主备还是会有延迟

##### 备库压力大

一般而言都是主库提供写能力，大家觉得备库的压力不大，就再备库上疯狂执行一些查询语句，造成备库的压力变大。

这种的解决方案是，既然你想跑些查询任务，如果对时间的要求不是很苛刻，可以再用几个从库出来，专门用作查询，从库和备库的区别就是，当发生主备切换时，会变成主库的那个就是备库，其他的是从库。

或者把binlog同步到hdfs上，然后再那个上面执行查询分析任务。



如果采用一主一备多从，使得备库的压力不大了，还有什么会导致主备延迟吗？

##### 大事务

###### 删除大量数据

我们知道binlog写入事务的逻辑是一次性全部写入的。如果采用的是row 格式的binlog，如果要执行删除操作，当删除的数据量比较大的时候，会导致要记录很多的数据，我们知道binlog的事务的时间是执行的时间，如果一个事务再A上执行了几分钟，那么当B拿到这个binlog的时候，主备的延迟就已经有了几分钟，如果这个时间超过了检测预警的主备延迟的时间线，那么就会产生预警信息。

###### 对大表做DDL

做ddl涉及到重建表，拷贝数据重放等一系列操作，会比较耗时。



###### 备库的并行复制能力

产生binlog和消费binlog不是一个程序，二者之间的时间并不是完全等同的，实际上我们再上一张主备的时候考虑过，最后一步解析中转日志到数据库中的时候，那一步是可以多线程并行的，这个消费速度如果跟不上生产速度也是会产生延迟的。





##### 关于高可用性和主备延迟的关系

刚刚突然想到这个话题，我们觉得高可用性达到极致，就是可以存在数台状态一致的服务，无论哪一台或者哪几台宕机了，剩下的机器都可以无损的对外提供服务，所以极致的主备延迟就是0，就意味着极致的高可用。



##### 当主备一定存在延迟的时候，我们如何进行主备切换呢？

我们的讨论先暂定在主动的主备切换，这意味着我们可以控制中断和切换的时机。

一般思考的方向就是数据的可靠性，和服务的可用性，两个方面是两个极端。我们先分别述之。



###### 可靠性优先的主备切换策略

**背景**

双M架构。主动切换

**步骤**

1. 判断备库B现在的seconds_behind_master，如果小于某个值（比如5s），如果没有继续重试
2. 把主库A改为只读状态
3. 判断B的seconds_behind_master的值，直到变成0为止
4. 把B的状态改为可读写状态
5. 把业务请求切换到B

一般这个由专门的HA（双机集群）系统来完成。

**我的问题**

1. 第一步可能永远卡死在那边，一般而言主备 对称的状态下，备机的延迟时间不会很长，而且主机也不是一直有binlog在产生，我们主备切换的时间一定是系统用的最少的时间，而这个时间，主备的延迟会随着生产者的停滞与消费者的持续消费而减少，为什么不设置成0呢？这个时间点比较难找，这个设置的时间点，就是第三步要等的时间点，其实不尽然，备库延迟了三秒，这个三秒不是说需要三秒才能入库。
2. 从第二步到第五步，服务处于暂停状态，这对业务而言是否可以接受

基于服务有不可用的问题，我们提出了可用性优先的主备切换策略。

###### 可用性优先的主备切换策略





