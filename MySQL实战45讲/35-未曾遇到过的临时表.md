#### 前言

因为在上一节的join优化章中对BNLjoin的优化，使用了临时表，作者顺理成章的就在本章开始介绍临时表。

主要是按照如下思路来行文

1. 先是介绍如何创建临时表
2. 临时表跟非临时表有哪些异同
3. 临时表的使用场景
4. 临时表在主备复制时的相关表现



通读一遍下来发现在主备表现上可能有点难度。在临时表的使用场景中作者第一次引出了**分库分表** 的概念，这个我觉得应该也是后续文章的一个引子。





#### 如何创建临时表

```mysql
create temporary table t1
```

就加了一个`temporary`关键字



#### 临时表的特征

##### 临时表和内存表的异同

这个问题也萦绕在我的脑海，临时表是否全是存储在内存中的。

**内存表**，是指建表时使用Memory引擎的表，这种表的特性是，数据存放在内存中，当系统重启时，表结构还在，但是数据全部消失。

**临时表**，可以使用多种引擎类型，当使用Memory引擎时，就是内存表，当使用Innodb引擎时，就不是内存表。

故而，临时表跟内存表是两个维度的概念。



##### 临时表的特征

![img](https://static001.geekbang.org/resource/image/3c/e3/3cbb2843ef9a84ee582330fb1bd0d6e3.png)

我们通过这个执行结果，可以得出

1. 临时表只对创建的连接可见，对其他的连接不可见
2. 在一个连接中，临时表的命名可以和普通表一致
3. 当查询的表既存在临时表又存在普通表时，会优先查询临时表（show create 和 增删改查）
4. show tables 只展示普通表



还有一些看不出的特性，就是在客户端断开连接的时候，会自动删除临时表。特别的，客户端异常断开，或者服务器异常重启，这个临时表产生的文件都会自动被删除。

临时表是如何和join产生作用的，我们需要明白join需要什么？

我们需要一个单独的表来存储满足条件的记录，这个表要么是临时表，要么是普通表，普通表的问题就在于这个名字不好起，而是出现异常的时候不好清理。



#### 分库分表的跨库查询

其实我实际开发的时候也遇到过，不过是无奈之举，在pg库中，我们的数据按照业务不同分散在了不同的数据库中。

作者叙述的这个场景我没有见过，因为我没接触过这么大数据量的场景，不过可以当作一个思路。

倘若我们有大表t，数据十亿计，我们按照自增主键的序列，把大表拆分成1024个分表，然后分不到32个数据库实例上

![img](https://static001.geekbang.org/resource/image/dd/81/ddb9c43526dfd9b9a3e6f8c153478181.jpg)

这边作者给出了一些通用的实现

- 比如都有一个proxy层，客户端直接对接proxy，不对接数据库，这个主要是减少客户端的压力，把复杂度都集中在proxy，这个实现还可以理解
- 我们说拆分的逻辑是要以以后的使用方便为大方向的，这个也可以理解，但是我却下意识的忽略了这个，我们在建一个业务表的时候，其实就已经大致的对以后这个表怎么使用有了理解，这个表结构就有待商榷
- 一般而言，系统的查询总是多于修改的
- 当我们知道了怎么查询的时候，跨库或者跨表查询消耗是比单表大的
- 基于此，我们拆分的时候要以**减少跨库和跨表查询**为方向，常见的是等值查询



为了方便定量叙述，假设我们的分库分表是使用f字段。

```mysql
select v from ht where f=N;
```

这种情况就是我们最爱的情况，比如我们是分1024个表，当我们插入一条新数据的时候，我们直接让数据的f字段%1024,判断放到哪个表里去，查询的时候也是一样。



```mysql
select v from ht where k >= M order by t_modified desc limit 100;
```

这种我们发现没有用到我们的分库分表字段，所以只能到1024个表中去查询，把所有满足条件的结果全部放到一起在进行排序分页。

如何处理这种情况，也有两种常见的思路

##### proxy做

###### 优点

- 处理速度快，拿到分表数据后，直接在内存中处理

###### 缺点

- 复杂的sql的处理难度比较大，要兼容mysql的各种各样语法
- 内存不够用，cpu不够用



##### 临时表

这个的思路就是，把满足条件的数据汇总到一个临时表中

我们以上面的sql为例

1. 先找一台机器建立临时汇总表，字段包含，v ,k t_modified
2. 在各个分库上执行那个查询语句
3. 把查询结果写到临时汇总表中，
4. 在临时汇总表中执行最终的查询语句



![img](https://static001.geekbang.org/resource/image/f5/0d/f5ebe0f5af37deeb4d0b63d6fb11fc0d.jpg)





