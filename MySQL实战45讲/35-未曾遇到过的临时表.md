#### 前言

因为在上一节的join优化章中对BNLjoin的优化，使用了临时表，作者顺理成章的就在本章开始介绍临时表。

主要是按照如下思路来行文

1. 先是介绍如何创建临时表
2. 临时表跟非临时表有哪些异同
3. 临时表的使用场景
4. 临时表在主备复制时的相关表现



通读一遍下来发现在主备表现上可能有点难度。在临时表的使用场景中作者第一次引出了**分库分表** 的概念，这个我觉得应该也是后续文章的一个引子。





#### 如何创建临时表

```mysql
create temporary table t1
```

就加了一个`temporary`关键字



#### 临时表的特征

##### 临时表和内存表的异同

这个问题也萦绕在我的脑海，临时表是否全是存储在内存中的。

**内存表**，是指建表时使用Memory引擎的表，这种表的特性是，数据存放在内存中，当系统重启时，表结构还在，但是数据全部消失。

**临时表**，可以使用多种引擎类型，当使用Memory引擎时，就是内存表，当使用Innodb引擎时，就不是内存表。

故而，临时表跟内存表是两个维度的概念。



##### 临时表的特征

![img](https://static001.geekbang.org/resource/image/3c/e3/3cbb2843ef9a84ee582330fb1bd0d6e3.png)

我们通过这个执行结果，可以得出

1. 临时表只对创建的连接可见，对其他的连接不可见
2. 在一个连接中，临时表的命名可以和普通表一致
3. 当查询的表既存在临时表又存在普通表时，会优先查询临时表（show create 和 增删改查）
4. show tables 只展示普通表



还有一些看不出的特性，就是在客户端断开连接的时候，会自动删除临时表。特别的，客户端异常断开，或者服务器异常重启，这个临时表产生的文件都会自动被删除。

临时表是如何和join产生作用的，我们需要明白join需要什么？

我们需要一个单独的表来存储满足条件的记录，这个表要么是临时表，要么是普通表，普通表的问题就在于这个名字不好起，而是出现异常的时候不好清理。



#### 分库分表的跨库查询

其实我实际开发的时候也遇到过，不过是无奈之举，在pg库中，我们的数据按照业务不同分散在了不同的数据库中。

作者叙述的这个场景我没有见过，因为我没接触过这么大数据量的场景，不过可以当作一个思路。

倘若我们有大表t，数据十亿计，我们按照自增主键的序列，把大表拆分成1024个分表，然后分不到32个数据库实例上

![img](https://static001.geekbang.org/resource/image/dd/81/ddb9c43526dfd9b9a3e6f8c153478181.jpg)

这边作者给出了一些通用的实现

- 比如都有一个proxy层，客户端直接对接proxy，不对接数据库，这个主要是减少客户端的压力，把复杂度都集中在proxy，这个实现还可以理解
- 我们说拆分的逻辑是要以以后的使用方便为大方向的，这个也可以理解，但是我却下意识的忽略了这个，我们在建一个业务表的时候，其实就已经大致的对以后这个表怎么使用有了理解，这个表结构就有待商榷
- 一般而言，系统的查询总是多于修改的
- 当我们知道了怎么查询的时候，跨库或者跨表查询消耗是比单表大的
- 基于此，我们拆分的时候要以**减少跨库和跨表查询**为方向，常见的是等值查询



为了方便定量叙述，假设我们的分库分表是使用f字段。

```mysql
select v from ht where f=N;
```

这种情况就是我们最爱的情况，比如我们是分1024个表，当我们插入一条新数据的时候，我们直接让数据的f字段%1024,判断放到哪个表里去，查询的时候也是一样。



```mysql
select v from ht where k >= M order by t_modified desc limit 100;
```

这种我们发现没有用到我们的分库分表字段，所以只能到1024个表中去查询，把所有满足条件的结果全部放到一起在进行排序分页。

如何处理这种情况，也有两种常见的思路

##### proxy做

###### 优点

- 处理速度快，拿到分表数据后，直接在内存中处理

###### 缺点

- 复杂的sql的处理难度比较大，要兼容mysql的各种各样语法
- 内存不够用，cpu不够用



##### 临时表

这个的思路就是，把满足条件的数据汇总到一个临时表中

我们以上面的sql为例

1. 先找一台机器建立临时汇总表，字段包含，v ,k t_modified
2. 在各个分库上执行那个查询语句
3. 把查询结果写到临时汇总表中，
4. 在临时汇总表中执行最终的查询语句



![img](https://static001.geekbang.org/resource/image/f5/0d/f5ebe0f5af37deeb4d0b63d6fb11fc0d.jpg)



#### 临时表的物理存储探究，及主备时的表现



```mysql
create temporary table temp_t(id int primary key)engine=innodb;
```

当我们在执行上述语句的时候，有一个**frm**文件保存表结构定义。

文件名是**"#sql{进程id}\_{线程id}_序列号"**,保存在临时文件目录下（我在win10上并没有发现）

表结构存放在临时目录下，数据文件存储做过修正

- 5.6及之前，会在临时目录下放一个相同前缀，以.ibd为后缀的文件，存放数据
- 5.7版本开始，mysql引入了一个临时表空间，专门存储临时文件的数据，无需创建idb文件了

![img](https://static001.geekbang.org/resource/image/22/1b/22078eab5c7688c9fbfd6185555bd91b.png)

进程id和线程id都是16进制表示的。

这也就是为什么有普通表了我们还可以创建同名临时表，不同的连接也可以创建同名临时表的原因。

存储位置不同，我们一起读到内存中的时候，这个存储位置就没有区分的作用了，所以在内存中，我们还需要一套唯一标识一个表的字段。

- 如果是普通表，就是库名+表名
- 如果是临时表，就是server_id+thread_id+库名+表名



对一个seesion的临时表命名的维护

我们可以看到，同一个session创建的临时表，是通过序号来维护的，但是仍然不可以重名，因为重名之后，加载到内存中无法区分。

这是一个链表来维护的，当我们心中一个临时表的时候，我们会检测已有的临时表链表中是否有重名的，如果没有就添加，否则失败。

当seesion断开的时候，我们会执行DROP TEMPORARY TABLE + 表名，清除该seesion创建的临时表。

这条DROP语句也被记录到了binlog中。



记录到binlog中，作者继而引出了主备复制，也是我一直在逃避的东西。



#### 难搞的主备复制与临时表的二三事

```mysql
create table t_normal(id int primary key, c int)engine=innodb;/*Q1*/
create temporary table temp_t like t_normal;/*Q2*/
insert into temp_t values(1,1);/*Q3*/
insert into t_normal select * from temp_t;/*Q4*/
```

临时表是否需要记录binlog呢？上面的语句给出了答案，如果不记录的话，备库在收到语句的时候，执行Q4时会直接报错。

进而我们得知，临时表也是需要记录binlog的。

但是我们也知道，如果binlog是row格式的话，记录的是实际的行数据，这也不会报错了。

确实，我们说临时表操作记录binlog，是在binlog_format=statement\mixed的时候才会。

既然会同步，那自然创建和删除都需要执行。



```mysql
DROP TABLE `t_normal` /* generated by server */
```

一般我们都知道在记录ddl语句的时候，binlog是原封不动的，但是如果是在row格式下的drop语句，server会把临时表的drop删掉，因为备库是没有临时表的。



##### 不同线程创建的同名临时表，备库如何处理

![img](https://static001.geekbang.org/resource/image/74/ba/74e789024f10bcde515f21c0368847ba.png)

这个处置方式很简单，就是在记录binlog的时候，会把M的服务id和SessionA的thread_id记录下来，这样在恢复的时候，创建的表的table_def_key就不会起冲突。这个是内存的区分方式，但是没有说磁盘上的存储方式，我猜测存储方式也是跟记录的这两个字段有关系。







