## 锁

### 出现的背景

数据库是共享的资源，会有多个线程同时对其访问。多线程并发访问的时候一定需要同步吗？是需要的，比如我在执行`select Id from T where age =14`的时候，同时`alter table T drop column age`,如果我不加同步操作，那我在查询语句执行的过程中，age字段被删除了，这个sql就会执行报错。这个问题不是无解。因为mysql默认的事务隔离级别是可重复读，在我们执行查询之前，其实已经创建了一个视图，你对表结构的改动，跟我的本次查询没啥关系。我们考虑的时候可以不考虑这个隔离级别，因为不是所有的存储引擎都支持事务。

那对我的查询语句来说，如果我先于更改表结构的语句先执行，那么我理所应当在查询结束前你才能改我的表结构。

 其实这个也是看我们对我们的数据库再使用的时候有什么期望。并没有一个明确的答案。

比如我想让我的数据库定格在某一个时间点，我要做全表备份。你需要提供一个机制。这个机制就是锁。

为啥备份一定要在一个确定的时间点呢？因为备份的表之间可能存在逻辑上的一致性，比如转账，A扣钱，B加钱，这两个虽然是一个事务，但是如果不加锁控制就会导致逻辑上的不一致性。

这是我们的一个期望。这种整个数据库都只能读的锁叫全局锁。开启的方式就是FTWRL(FLUSH TABLE WITH READ LOCK)。

当然是否让数据只能读，或者只能读的目的是为了逻辑上的一致性，有没有别的实现方式了呢？有的

一个是 改变一个全局只读标识为true。一个是使用支持事务的一致性读的隔离级别。

这两个都有自己的应用场景。前者的问题是这个参数不止会用在控制全局已读上，代价比FTWRL更大。后者有个要求就是所有的表都使用支持这种事务隔离级别的引擎。



#### 表级锁

##### 表锁

1. 开启方式

   - **lock tables ... read/write**

2. 开启之后的影响

   > **lock tables t1 read, t2 write**

   - 其他线程的写t1，读写t2的请求都会阻塞
   - 在本线程释放锁之前，只能读t1,读写t2;不允许访问其他表。

3. 如何释放

   - 执行 unlock tables
   - 客户端断开连接

##### 元数据锁（MDL）

1. 如何开启
   
   - 访问一个表的时候自动加上
2. 开启之后的影响
   - 如果是DML语句，会加读锁，如果是DDL语句，会加写锁
   - 读锁之间不互斥，读写，写锁之间互斥。
   - 综上，我在查询的时候，如果没有使用可重复读隔离级别的情况下，别的线程是可以增删改的；但是如果有线程需要改表的结构，会被阻塞。

3. 如何释放

   - 事务结束之后；
     - 这里我们发现事务好像只是保证一系列操作全部成功或者失败的手段，而不限语句是DQL,DML,DDL；
     - 如果数据库关闭了自动提交，而你在查询之后，又没有及时的提交事务，就会导致**长事务**的出现，长事务意味着这个读操作不会释放元数据锁，后面如果是其他的DML语句，那么不会出问题，因为读锁之间是不互斥的。**而一旦出现DDL，就会申请一个写锁，一旦申请写锁，这里会有一个队列，一旦有申请写锁的线程出现，那后面无论是申请读锁还是写锁，都必须等待，这就导致了后续的DML语句全部阻塞。**如果一个表的查询非常频繁，会导致服务端的连接池被全部占满，或者客户端有重试机制，也会尝试开启新的连接，而使服务端连接资源被彻底占满，导致数据库服务直接不可用；可以在MySQL中的information_schema库的innodb_trx中查看正在执行的事务，这时可以暂停这个DDL，或者kill掉长事务。
     - 如果你要在一个热点表新增一个字段会怎么做？这里跟cpu调度很类似，一个连接所发的请求一般是由一个队列来处理（其实有两个，一个普通队列，一个优先级队列，优先级的依据是是否已经开启了事务），但是如果是热点表，那会有很多个连接同时查询这个表，而导致DDL的写锁拿不到，而阻塞后面的所有的锁的获取。我们不能一个一个去kill掉长连接，因为这个热点表的请求很多，而且最关键的是他们不是在同一个任务队列中，所以不一定保证你来了就可以很快获得锁；比较合理的解决方案是当做DDL的时候，新增一个超时时间，如果没有在超时时间的限制内获取到写锁，就放弃，后面在人为重试，直到成功为止。

   > 表锁，一般是数据库引擎不支持行锁的时候才会用到。



问题：备份一般都会在备库上执行，你在用–single-transaction 方法做逻辑备份的过程中，如果主库上的一个小表做了一个 DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？

我的答案： 备库使用这个-single-transaction备份的时候，



