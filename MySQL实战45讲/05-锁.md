### 锁

- 锁包括全局锁，表锁，行锁。粒度依次降低。
- 锁的出现类比java中的锁，因为数据库是一个共享的，对于共享数据的访问，我们有时因为一些业务需要同步操作。



#### 全局锁

顾名思义，全局锁是锁住整个数据库，只能读不能写。这个粒度最大，但是代价比较高。

##### 如何开启？

执行命令：Flush tables with read lock (FTWRL)。

所有的DML和DDL语句都会被阻塞。



##### 使用场景

1. 全库备份
   - 需要再备份的时候保证不会有变化。让全库只能读。
   - 如果备份主库，将导致业务停摆，如果备份备库，会导致主库和备库的逻辑不一致。不一致的原因是什么呢，那就涉及一个问题，主从库是如何同步的？大致搜索了下[MySQL主从复制](https://blog.csdn.net/seven71111/article/details/109213684)。备库的备份工作是需要主库配合的，主库必须运行一个I/O线程，然后备份库才能运行，如果主库宕机，那么从库的备份工作也无法执行。而主库的binlog写入是支持并发的，从库的读取binlog是串行的，这就导致了两者之间的一个速度差，而如果从库没有备份完，而主库彻底宕机并再起不能，那就会导致两者的数据不一致。这种情况无论怎么加锁一定会导致数据的不一致，跟加不加锁没有关系。后来开启了半同步复制，就是一个事务在同步给从库成功之后再返回给客户端，如果从库宕机，就改为之前的异步模式。这边有两个问题，就是如果我们的从库不止一个，是发给所有的从库都成功才返回，还是有一个成功就返回。这样的话还是会有数据不一致的，我们只能找到从库中，相对最新的一条记录。**但是这个跟锁有啥关系？**，我吐了。
   - 我们需要先明确，我们不加锁，在一切正常的情况下会导致什么问题？同样的两张表，一张购买的课程表，一张账户余额表。如果我先备份的是账户余额宝，在备份之后，又来备份课程表，但是在此期间，用户已经在主库上完成了一笔交易，课程表中已经多了一门记录，如果用此时备份的数据还原会发现用户没有花钱就多了一门课程；究其原因，是因为备份的时候我们的表中的数据不应该有变化了，不然这个不是实时的，会造成数据不一致的情况。
   - 如果需要维持数据逻辑上的一致性，我们可以使用**可重复读**这个视图，这也不会阻塞主库的修改操作。但是这个隔离级别是存储引擎实现的，这就要求所有的表都是支持使用事务引擎的库。
   - 当然除此之外，还可以使用set global readonly=true但是这个方法有两个弊端，一个是这个参数不止会置为已读，还会有其他的判断会用到这个参数，修改的影响比较大；二是，如果使用FTWRL如果宕机了会自动释放，但是这个参数不会，会导致业务一直不能用。

