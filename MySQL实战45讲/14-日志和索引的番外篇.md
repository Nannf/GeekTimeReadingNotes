#### 前言

这个章节的问题很多我在阅读之前章节的时候都已经搜索出答案，这边再次记录一下。

文章主要是关于日志的，日志又仅包含redolog和binlog

![img](https://static001.geekbang.org/resource/image/ee/2a/ee9af616e05e4b853eba27048351f62a.jpg)

##### commit 状态和commit语句

> 每个commit语句最后肯定会把redolog变成commit状态



##### 不同时刻发生异常，数据库的情况

1. 如果redolog还没有处于prepare阶段就异常，那么此时的程序重启的时候，也不会去恢复这次更新，而且客户端也没有收到执行成功的显示，使用binlog还原库的时候也不会出现和主库不一致的情况
2. 如果在时刻A奔溃了，程序启动的时候，发现有出于prepare状态的redolog，它接着要去判断有没有redolog对应的记录完成的binlog，显然此时是没有的，那此时是会回滚这个redolog的，按照1的分析也没有出现状态不一致的情况
3. 如果在时刻B崩溃了，那么程序重启的时候，我们找到了处理完成的binlog，这时候会把redolog对应的数据页加载到内存中，然后应用redolog的修改，此时内存中的数据页就是脏页，然后回刷到盘中。此时如果使用binlog去还原库会得到和主库一样的数据。

##### mysql怎么知道binlog的完整性

我们在上个问题，发现了redolog对应的binlog，是否是记录完成：

1. 如果是statement格式的binlog，最后会有一个 COMMIT;
2. 如果是row格式的binlog，最后会有一个XID event;
3. 5.6.2之后的版本还有一个checksum来校验完整性。



##### redolog和binlog如何关联

当我们发现prepare状态的redolog的时候，我们会去查找有没有对应的binlog，这个关联的是两个都有一个共同的字段XID；



##### 为什么要两阶段提交，恢复的时候必须两个日志都完整才能恢复不也是可以的吗

但是redolog一旦应用成功就是不能回滚的了，因为你的回滚会导致别的事务的更新失效，基于此，如果先写redolog，然后成功了，写binlog的时候失败了，程序重启的时候，判断这两个并没有全部成功，就回滚，但是这个就与我们刚刚说的redolog一旦成功就不能回滚的相矛盾了。



##### 为什么不用binlog来恢复数据呢，它不是记录了所有的修改吗？

![img](https://static001.geekbang.org/resource/image/eb/63/eb838b87e9c20fa00aca50ef154f2a63.jpg)

这个问题的关键就在于，为了更新的速度，我们的修改是在内存中的，我们只知道最后一个失败的事务，但是之前的哪些事务进行过修改就不知道了，可能会造成之前的修改在内存中的，还没来得及刷盘。

这个我们参照上图，我们发现恢复的时候会选择去恢复哪些数据呢？那些已经修改完成的但是还没来得及提交的数据，比如binlog2，对那些已经提交完成的会去恢复吗？那些数据我们其实都默认是已经完成了，不用去恢复，但是，binlog1的完成可能只是修改了内存，还没来得及刷盘。

binlog是不记录数据页的。



##### 能不能只要redolog，不要binlog呢

redolog空间有限，起不到归档的左右，我们为了高可用会去创建从库，备份数据，使用的就是binlog。



##### redolog中到底记录的是什么

redolog其实并没有记录数据页的完整数据，它只记录了数据页的改动，单凭redolog是没办法落盘的。

1. 如果一切正常，数据页被修改之后，存储在内存中，称为脏页，落盘是把内存中的脏页刷到磁盘上，跟redolog没关系。
2. 如果是崩溃恢复，InnoDB发现redolog有可用的，会把redolog对应的数据页读到内存中，应用redolog上的更新，然后就回到了第一种情况。



##### redolog buffer是什么

事务只有commit的时候，redolog的相关语句才会写道redolog的文件中，执勤都是存放在redolog buffer中的，redologbuffer是一块内存。

