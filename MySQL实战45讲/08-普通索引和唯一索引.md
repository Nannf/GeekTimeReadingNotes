

唯一索引保证b+树上的节点的值是唯一的；

这在查询上和修改上会带来什么样的影响呢？

现在的场景是库里的这个字段由业务端保证不会重复。

首先来看看查询：

> 当我们在二叉树上找到这个值的时候，因为唯一性，我们不会接着往后找，如果是普通索引，是会接着往后找的，读取索引树上的下一条数据，判断不是之后结束查找。

这个造成的性能损失了吗？且不论其他，这个仅增加了一次寻找的过程，二者的查询效率基本忽略不计。而且这次查找我们做了哪些事情呢？我们知道B+树索引上的叶子节点维护了相邻叶子节点的指针，这个指针有啥用呢？就是定位到相邻的叶子节点的物理地址。这里有个问题，就是所有的叶子节点是使用连续内存存储的吗？

我们知道InnoDB引擎维护磁盘的基本单位是页，一般是16k，读取的时候也是把16k全部读取进内存的，

数据库中最耗时的一种操作就是从磁盘上随机读取数据。

这里有个问题，就是b+数索引的叶子节点之间是顺序存储的吗，是存放在一个数据页上的吗。

这个我们先略过不提，我们只要知道，如果业务端保证了数据唯一性的情况下，在读取数据方面，唯一索引和普通索引差别不大。

这边引申出一个问题：

Q: b+树上的叶子节点是使用连续磁盘空间存储的吗？

A: 不是，因为不好评估叶子节点区间的大小，这个连续空间没办法设置，这种插入较多的，我们使用的也是链表的方式存储；二是B+树的非叶子节点上存放的是key，并不包含值，且不同的叶子节点之间使用引用连接，这样跨叶子节点的访问无需冲根节点重新定位。我们把自己想象成MySQL的服务器，当我们要读取一个id=5的数据，我们第一步就是到索引树去找这个5的数据，我们在B+数上，找到了区间3开头的，我们逐个获取这个叶子节点上的数据，直到获取到5为止，如果是唯一索引就到此结束，如果不是，就需要接着访问下一个，如果跨页了，我们就需要在从磁盘上捞一页的数据上来，这个发生的机率不高，而且数量只有一次，时间基本可以忽略不计。



[索引相关，指出了区间搜索](https://blog.csdn.net/qq_33599978/article/details/78368660)



再来看看更新，这边要介绍到一个新的概念**change buffer**

#### changebuffer 是什么

是一个内存中的文件，当我们对数据进行改动的时候，**为了速度**，我们会把改动先记录在内存中，每次读取的时候，我们把磁盘上的记录和changebuffer中的做一次运算，就得到一个最新的结果集。**为了可用性**，我们需要把changebuffer存放在内存中，如果数据库是正常关闭的，我们会把changebuffer中的数据同步到磁盘上，如果是非正常关闭呢？这个和redolog，binlog是如何联动的呢？这个我们略过不表。

changebuffer中缓存的是热点数据页和热点索引页。



[changebuffer的介绍](https://blog.csdn.net/shenjian58/article/details/93691224)

这边引申出一个问题：

Q： changebuffer 和 redolog binlog 是如何联动的呢?

先写changebuffer 再写redolog这些，这样如果再redolog写入成功前奔溃，那数据就没有更新成功，changebuffer因为是存在内存中的，重启后丢失，两者是一致的。如果是写完之后奔溃，数据库中会从redolog中恢复。

Q : 唯一索引能使用changebuffer吗？

A: 如果要明白这个问题我们需要直到唯一索引的数据再入一条新的数据时会做什么操作，因为是唯一的，所以我们需要从索引树上查找，看能否找到索引值等于插入值的索引。而普通索引，直接写入修改的内容就返回了。所以对唯一索引我们没有必要使用changebuffer,因为这个什么用都没有，我们是需要从索引树上加载的。changebuffer不可能维护全量最新的唯一索引树，那么它维护唯一索引就显得鸡肋。**关键就在于changebuffer不会缓存索引树上的所有页**，基于此我们可以推断，每次插入唯一索引字段时，我们要去判断这个字段是否在索引树上存在，而我们不会把索引树所在的数据页都加载进内存，这意味着会存在缓存没命中的情况，一旦出现这种情况，我们需要从索引树的磁盘文件**随机i/O**读取数据页，这是最耗时的。如果此时仍然使用changebuffer的话，相当于changebuffer中维护了一部分唯一索引的数据页，bufferpool中仍然需要一部分数据来存储加载未命中的数据页。可能是唯一索引的数据页的命中率太低，导致数据库的开发人员觉得changebuffer不适合唯一索引。

​	**随机i/o也表明了我之前的推断，就是b+树上的叶子节点的存储不是连续的磁盘空间，而是类似链表的存储。在磁盘上是随机的，。**



Q: 如果我们要插入一条数据时InnoDB做了哪些操作？

A:  如果插入的数据页再内存中，如果是唯一索引，我们先在索引树。



Q: 是先更新索引树还是先插入数据？

A: 不知道是不是我的搜索不对，网上搜到的答案都是不知所云。这边写给出我的猜测，我们知道，更新的时候一般是写redolog和binlog就结束了，我猜测是针对这个最新的数据进行的一个索引更新，但是这几个操作应该是一个事务才对，不然redolog和binlog写成功了，但是在更新索引的时候失败了，那会导致索引和实际数据的不一致，我如果是数据库的开发人员，应该尽量避免这种情况的产生。 难道redolog中记录了索引文件的改动？这个我们暂时按下不提。

**这里我们发现，其实对数据库内容的修改，只涉及redolog和binlog的改动，程序再更新的时候是不会去加载磁盘上实际存储的数据的，这也就意味着，本文中所有的加载数据页的操作指的都是索引文件的数据页。**



当我们插入一条数据到有唯一索引的表和没有唯一索引的表会发生什么呢？

当要更新的索引数据页在内存中，比如我要插入4，3和5所在的叶子节点在内存中。

此时对唯一索引的表而言，它要做的，就是判断下有没有违反唯一索引的冲突，检测之后发现没有违反，然后插入数据到内存页中。

此时的普通索引，找到这个数据页然后插入。

相较而言，仅仅是少了一次检测，影响不大。



当不在内存页中，会发生什么事情呢？

我们需要把索引树找到要插入的数据应当在的数据页（即3和5所在的数据页）这是随机i/o，加载进内存后，然后判断，如果不冲突，写入数据。

如果是普通索引，我们直接写入changebuffer。然后直接返回，这一步的提升非常迅速。



通过之前的分析我们知道，更新只是暂时的被写入到了changebuffer中，如果要查询的话，是需要读取数据和changebuffer中的数据进行运算得到结果。如果你写了之后立马就要读，那么不仅没有减少数据库i/o还多了一步合并的计算操作。

**changebuffer适用写多读少的普通索引**。

说了半天发现唯一索引好像一无是处。但是我们上面的讨论都是基于业务端保证了数据的唯一性。但是实际情况的时候我们业务端并不能保证，经常会出现如果数据库中某个唯一索引存在就更新或者什么都不做，如果不存在才插入这样的操作。

### changebuffer和redolog

这两个都优化了mysql的性能，现在我们要具体分析下二者是如何优化的。我们以下面这个sql语句为例来进行说明

```mysql
mysql> insert into t(id,k) values(id1,k1),(id2,k2);
```

当我们插入两条数据到表t中的时候，changebuffer和redolog分别在什么时候起作用的呢？

其中id是主键，k是索引。

![img](https://static001.geekbang.org/resource/image/98/a3/980a2b786f0ea7adabef2e64fb4c4ca3.png)

我们以专栏的图片为例，当我们开启了changebuffer之后，一条插入语句涉及到图示的四个部分，内存、redolog，系统表空间、数据表空间。

我们先要计算要插入的两条数据的磁盘上的数据页在不在内存中。这边又有了新的问题，就是主键索引上有表中所有的记录，这个数据页指的是什么？主键索引的文件吗，还是实际的行文件。

通过百度我们直到了ibd是innodb存储引擎的一个文件，它存储的内容是表的数据文件和索引文件。因为文中表述的意思是当我们插入的时候，我们需要计算出插入的位置，比如id1插入到Page1中，id2插入到page2中，一般我们在插入索引文件的时候会进行计算，因为它要进行排序。所以我们在这里大胆的假设，文中说的page指的都是索引，而且还是主键索引。

如图所示，id1的page1在内存中，id2的不在，当我们在更新的时候 。经历了四步。

1. 发现page1在内存中，直接更新page1，插入id1
2. 发现id2的page2不在内存中，在内存中找到changebuffer所在的地址空间，然后插入记录。
3. 把1，2两个改动同步到redolog中，本次事务结束。

我们发现本次更新，有两次内存的写入，以及两次磁盘的顺序写入。非常快 。

那我们如果这时候执行`select * from t where k in (k1, k2)`

![img](https://static001.geekbang.org/resource/image/6d/8e/6dc743577af1dbcbb8550bddbfc5f98e.png)

假设这次查询的时候，在插入操作之后，这些内存还没有被更新过，因为page1在内存中，所以就直接返回的，k2不在内存中，会从磁盘上加载到内存中，然后changebuffer的进行合并，然后返回正确的结果集。

我们先以一个更新操作为例，数据库要做哪些事情：

1. 找到要更新的数据在磁盘的哪个地方存储，
2. 把它读取到内存中，并进行相关修改
3. 把修改之后的新数据写入到磁盘中。

第2步涉及到随机读，第3步涉及到随机写，这都是比较耗时的操作。

InnoDb存储引擎对这两个地方都做了优化，在第二步的时候，把修改的情况先记录下来，并不实际修改，留待后面不忙的时候再修改，这样就不用从磁盘上随机读了。

第三步的随机写也被变成了顺序写redolog。

所以changebuffer省去了随机读，redolog用顺序写优化了随机写。



问题：

通过图 2 你可以看到，change buffer 一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致 change buffer 丢失呢？change buffer 丢失可不是小事儿，再从磁盘读入数据可就没有了 merge 过程，就等于是数据丢失了。会不会出现这种情况呢？

答： 假设写redolog之前丢失了，事务没有完成，本来恢复的时候就无需恢复。如果是写redolog之后丢失了，那么可以通过redolog来恢复，实际并没有丢失。