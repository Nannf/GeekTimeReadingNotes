

唯一索引保证b+树上的节点的值是唯一的；

这在查询上和修改上会带来什么样的影响呢？

现在的场景是库里的这个字段由业务端保证不会重复。

首先来看看查询：

> 当我们在二叉树上找到这个值的时候，因为唯一性，我们不会接着往后找，如果是普通索引，是会接着往后找的，读取索引树上的下一条数据，判断不是之后结束查找。

这个造成的性能损失了吗？且不论其他，这个仅增加了一次寻找的过程，二者的查询效率基本忽略不计。而且这次查找我们做了哪些事情呢？我们知道B+树索引上的叶子节点维护了相邻叶子节点的指针，这个指针有啥用呢？就是定位到相邻的叶子节点的物理地址。这里有个问题，就是所有的叶子节点是使用连续内存存储的吗？

我们知道InnoDB引擎维护磁盘的基本单位是页，一般是16k，读取的时候也是把16k全部读取进内存的，

数据库中最耗时的一种操作就是从磁盘上随机读取数据。

这里有个问题，就是b+数索引的叶子节点之间是顺序存储的吗，是存放在一个数据页上的吗。

这个我们先略过不提，我们只要知道，如果业务端保证了数据唯一性的情况下，在读取数据方面，唯一索引和普通索引差别不大。

这边引申出一个问题：

Q: b+树上的叶子节点是使用连续磁盘空间存储的吗？

A: 不是，因为不好评估叶子节点区间的大小，这个连续空间没办法设置，这种插入较多的，我们使用的也是链表的方式存储；二是B+树的非叶子节点上存放的是key，并不包含值，且不同的叶子节点之间使用引用连接，这样跨叶子节点的访问无需冲根节点重新定位。我们把自己想象成MySQL的服务器，当我们要读取一个id=5的数据，我们第一步就是到索引树去找这个5的数据，我们在B+数上，找到了区间3开头的，我们逐个获取这个叶子节点上的数据，直到获取到5为止，如果是唯一索引就到此结束，如果不是，就需要接着访问下一个，如果跨页了，我们就需要在从磁盘上捞一页的数据上来，这个发生的机率不高，而且数量只有一次，时间基本可以忽略不计。



[索引相关，指出了区间搜索](https://blog.csdn.net/qq_33599978/article/details/78368660)



再来看看更新，这边要介绍到一个新的概念**change buffer**

#### changebuffer 是什么

是一个内存中的文件，当我们对数据进行改动的时候，**为了速度**，我们会把改动先记录在内存中，每次读取的时候，我们把磁盘上的记录和changebuffer中的做一次运算，就得到一个最新的结果集。**为了可用性**，我们需要把changebuffer存放在内存中，如果数据库是正常关闭的，我们会把changebuffer中的数据同步到磁盘上，如果是非正常关闭呢？这个和redolog，binlog是如何联动的呢？这个我们略过不表。

changebuffer中缓存的是热点数据页和热点索引页。



[changebuffer的介绍](https://blog.csdn.net/shenjian58/article/details/93691224)

这边引申出一个问题：

Q： changebuffer 和 redolog binlog 是如何联动的呢?

先写changebuffer 再写redolog这些，这样如果再redolog写入成功前奔溃，那数据就没有更新成功，changebuffer因为是存在内存中的，重启后丢失，两者是一致的。如果是写完之后奔溃，数据库中会从redolog中恢复。

Q : 唯一索引能使用changebuffer吗？

A: 如果要明白这个问题我们需要直到唯一索引的数据再入一条新的数据时会做什么操作，因为是唯一的，所以我们需要从索引树上查找，看能否找到索引值等于插入值的索引。而普通索引，直接写入修改的内容就返回了。所以对唯一索引我们没有必要使用changebuffer,因为这个什么用都没有，我们是需要从索引树上加载的。changebuffer不可能维护全量最新的唯一索引树，那么它维护唯一索引就显得鸡肋。**关键就在于changebuffer不会缓存索引树上的所有页**，基于此我们可以推断，每次插入唯一索引字段时，我们要去判断这个字段是否在索引树上存在，而我们不会把索引树所在的数据页都加载进内存，这意味着会存在缓存没命中的情况，一旦出现这种情况，我们需要从索引树的磁盘文件**随机i/O**读取数据页，这是最耗时的。如果此时仍然使用changebuffer的话，相当于changebuffer中维护了一部分唯一索引的数据页，bufferpool中仍然需要一部分数据来存储加载未命中的数据页。可能是唯一索引的数据页的命中率太低，导致数据库的开发人员觉得changebuffer不适合唯一索引。

​	**随机i/o也表明了我之前的推断，就是b+树上的叶子节点的存储不是连续的磁盘空间，而是类似链表的存储。在磁盘上是随机的，。**



Q: 如果我们要插入一条数据时InnoDB做了哪些操作？

A:  如果插入的数据页再内存中，如果是唯一索引，我们先在索引树。



Q: 是先更新索引树还是先插入数据？

A: 不知道是不是我的搜索不对，网上搜到的答案都是不知所云。这边写给出我的猜测，我们知道，更新的时候一般是写redolog和binlog就结束了，我猜测是针对这个最新的数据进行的一个索引更新，但是这几个操作应该是一个事务才对，不然redolog和binlog写成功了，但是在更新索引的时候失败了，那会导致索引和实际数据的不一致，我如果是数据库的开发人员，应该尽量避免这种情况的产生。 难道redolog中记录了索引文件的改动？这个我们暂时按下不提。

**这里我们发现，其实对数据库内容的修改，只涉及redolog和binlog的改动，程序再更新的时候是不会去加载磁盘上实际存储的数据的，这也就意味着，本文中所有的加载数据页的操作指的都是索引文件的数据页。**



当我们插入一条数据到有唯一索引的表和没有唯一索引的表会发生什么呢？

当要更新的索引数据页在内存中，比如我要插入4，3和5所在的叶子节点在内存中。

此时对唯一索引的表而言，它要做的，就是判断下有没有违反唯一索引的冲突，检测之后发现没有违反，然后插入数据到内存页中。

此时的普通索引，找到这个数据页然后插入。

相较而言，仅仅是少了一次检测，影响不大。



当不在内存页中，会发生什么事情呢？

我们需要把索引树找到要插入的数据应当在的数据页（即3和5所在的数据页）这是随机i/o，加载进内存后，然后判断，如果不冲突，写入数据。

如果是普通索引，我们直接写入changebuffer。然后直接返回，这一步的提升非常迅速。



通过之前的分析我们知道，更新只是暂时的被写入到了changebuffer中，如果要查询的话，是需要读取数据和changebuffer中的数据进行运算得到结果。如果你写了之后立马就要读，那么不仅没有减少数据库i/o还多了一步合并的计算操作。

**changebuffer适用写多读少的普通索引**。

说了半天发现唯一索引好像一无是处。但是我们上面的讨论都是基于业务端保证了数据的唯一性。但是实际情况的时候我们业务端并不能保证，经常会出现如果数据库中某个唯一索引存在就更新或者什么都不做，如果不存在才插入这样的操作。

### changebuffer和redolog

