#### 概览

前几章，我们讨论了主备的相关知识，讨论的内容有如下特点：

1. 是基于一主一备讨论的
2. 主备的数据同步，以及主备延迟的产生与我们如何可以降低主备延迟

本章我们的重点将放在一主一备多从的情况下主备如何切换的场景下的讨论。

这就自然引出一个问题，一主一备有问题吗？

这有个前提假设，

1. 就是我们的业务都是读多写少的；
2. 读也是消耗资源的；
3. 一台服务器的资源是有限的；
4. 一台服务器的性能是有上线的

所以从库出现的背景就是解决因为读压力大而产生的一个解决方案。



从库的引入，让我们会思考如下几个问题：

1. 从库和备库的区别是什么
   - 当我们发生主动或者被动的切换主机的时候，会成为新的主机的机器，我们叫备库，其他的叫从库。
2. 从库和备库的机器性能的要求是一样的吗？
   - 我猜是大差不差的，因为备库也好，从库也罢，都是要从主库同步数据的，同时还要承受着查询的压力，如果性能太差的话，不是多此一举吗



好了，我们开始本次的主从问题。



##### 基础架构图

![img](https://static001.geekbang.org/resource/image/aa/79/aadb3b956d1ffc13ac46515a7d619e79.png)

如图所示，A和A' 互为主备，从图中我们看出，从库和备库的另一个区别：

**二者都是只读，但是从库会对外提供查询服务，而备库只复制同步A的数据，这因为备库和主库的延迟要很低，有提供查询的资源，不如多开几个线程来负责同步数据，我想也是基于此，才出现了从库。**



##### 主库异常情况下的主备切换图例

![img](https://static001.geekbang.org/resource/image/00/53/0014f97423bd75235a9187f492fb2453.png)

这里我们有一些假设，

1. A和A‘之间是不存在备份差异的，就是两者的状态是完全一致的。
2. B，C，D和A之间是存在差异的

当两者的库表数据没有差异的情况下，我们主备切换的问题就回到了一个新的问题，从库怎么更新自己的数据。

我们知道，从库从主库同步信息使用的是binlog，binlog是有多个文件追加写的，我们在回到主备一开始的时候，分析的binlog的内容

![img](https://static001.geekbang.org/resource/image/c3/c2/c342cf480d23b05d30a294b114cebfc2.png)

我们找到了end_log_pos 9092 这样的，这个其实就指出了一个位置信息。

我们可以在从库上记录下我们从主库同步到哪个文件，的哪个位置，下次可以从下个位置开始同步。



这样我们就找到了第一个恢复的方法：

##### 基于位点的主备切换

假如备库和主库一模一样，那么主备切换讲不存在任何问题，因为从库可以读取之前在主库上的binlog的文件和位置索引直接从备库开始备份，这样就不存在啥问题了。

但是问题就出现在了，备库只保证和主库最终数据的一致性，但是不保证binlog文件的一致性，因为我们最后在解析入库的那一步，是并行的，不会相互影响的事务之间的顺序并不保证和主库一致。

但是我猜测备库的文件名和主库是一致的，只是里面的内容不一致。

所以，这个备库的位点就不好找。

我们可以先描述最极端的情况：

1.  从头复制，把备库清空

   - 耗时大，主备延迟高
   - 主备的数据不会有差异

2. 从最新的开始复制
   - 会有数据丢失



我们把目光集中到主库A发生事故的那一刹那，记为时刻T，此时A上的数据已经发送给备库A'了，但是BCD还没有收到A上的修改，那BCD上的内容其实差的就是T时刻前后的一些记录。



当我想冷静的分析一波在A宕机的那一刹那发生了什么的时候，我的思路就乱了。



当A在T时刻断了，在断之前的一刹那把一条插入记录同时发给了A’和B； C和D没有收到这条插入信息。

BCD在切换主库的时候，需要指定我们要从新的主库A‘的哪个文件的哪个位置开始备份。

我们只知道A是在T时刻断的，A和A'是一样的，所以我们从A’的T时刻对应的位置开始备份。

这个位置是会让从库多备份数据还是少备份数据呢？

我们知道假设T时刻仅有一条语句被执行，那么这条语句在A‘上这条语句的时间一定大于A上的这条语句的记录时间。倘若BCD只有T时刻的没有备份，那么它们按照T时刻来读取数据，他们会多读一部分数据出来。

倘若有多条语句在执行，但是最晚的是在T时刻执行结束的，那么倘若从库没有更新这些语句，而这些语句在备库上的分布可能散布在T的前后，从库可能会有遗漏。

所以这并不是一个好的选择。



   

#####    GTID

正如我们介绍的那样，通过位点来更新，因为备库需要并行操作binlog的原因，使得主备库的binlog的文件名称和位置都不大一致，而且并没有任何规律而言，不是一个好选择。

基于此背景，GTID应运而生。

**Global Transcation Identifier**

即全局事务id，是一个事务在**提交**的时候生成的。是这个事务的唯一标识。

GTID=server_uuid:gno







   

   

   





