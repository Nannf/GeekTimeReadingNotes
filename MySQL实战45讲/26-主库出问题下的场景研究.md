#### 概览

前几章，我们讨论了主备的相关知识，讨论的内容有如下特点：

1. 是基于一主一备讨论的
2. 主备的数据同步，以及主备延迟的产生与我们如何可以降低主备延迟

本章我们的重点将放在一主一备多从的情况下主备如何切换的场景下的讨论。

这就自然引出一个问题，一主一备有问题吗？

这有个前提假设，

1. 就是我们的业务都是读多写少的；
2. 读也是消耗资源的；
3. 一台服务器的资源是有限的；
4. 一台服务器的性能是有上线的

所以从库出现的背景就是解决因为读压力大而产生的一个解决方案。



从库的引入，让我们会思考如下几个问题：

1. 从库和备库的区别是什么
   - 当我们发生主动或者被动的切换主机的时候，会成为新的主机的机器，我们叫备库，其他的叫从库。
2. 从库和备库的机器性能的要求是一样的吗？
   - 我猜是大差不差的，因为备库也好，从库也罢，都是要从主库同步数据的，同时还要承受着查询的压力，如果性能太差的话，不是多此一举吗



好了，我们开始本次的主从问题。



##### 基础架构图

![img](https://static001.geekbang.org/resource/image/aa/79/aadb3b956d1ffc13ac46515a7d619e79.png)

如图所示，A和A' 互为主备，从图中我们看出，从库和备库的另一个区别：

**二者都是只读，但是从库会对外提供查询服务，而备库只复制同步A的数据，这因为备库和主库的延迟要很低，有提供查询的资源，不如多开几个线程来负责同步数据，我想也是基于此，才出现了从库。**



##### 主库异常情况下的主备切换图例

![img](https://static001.geekbang.org/resource/image/00/53/0014f97423bd75235a9187f492fb2453.png)

这里我们有一些假设，

1. A和A‘之间是不存在备份差异的，就是两者的状态是完全一致的。
2. B，C，D和A之间是存在差异的

当两者的库表数据没有差异的情况下，我们主备切换的问题就回到了一个新的问题，从库怎么更新自己的数据。

我们知道，从库从主库同步信息使用的是binlog，binlog是有多个文件追加写的，我们在回到主备一开始的时候，分析的binlog的内容

![img](https://static001.geekbang.org/resource/image/c3/c2/c342cf480d23b05d30a294b114cebfc2.png)

我们找到了end_log_pos 9092 这样的，这个其实就指出了一个位置信息。

我们可以在从库上记录下我们从主库同步到哪个文件，的哪个位置，下次可以从下个位置开始同步。



这样我们就找到了第一个恢复的方法：

##### 基于位点的主备切换

假如备库和主库一模一样，那么主备切换讲不存在任何问题，因为从库可以读取之前在主库上的binlog的文件和位置索引直接从备库开始备份，这样就不存在啥问题了。

但是问题就出现在了，备库只保证和主库最终数据的一致性，但是不保证binlog文件的一致性，因为我们最后在解析入库的那一步，是并行的，不会相互影响的事务之间的顺序并不保证和主库一致。

但是我猜测备库的文件名和主库是一致的，只是里面的内容不一致。

所以，这个备库的位点就不好找。

我们可以先描述最极端的情况：

1.  从头复制，把备库清空

   - 耗时大，主备延迟高
   - 主备的数据不会有差异

2. 从最新的开始复制
   - 会有数据丢失



我们把目光集中到主库A发生事故的那一刹那，记为时刻T，此时A上的数据已经发送给备库A'了，但是BCD还没有收到A上的修改，那BCD上的内容其实差的就是T时刻前后的一些记录。



当我想冷静的分析一波在A宕机的那一刹那发生了什么的时候，我的思路就乱了。



当A在T时刻断了，在断之前的一刹那把一条插入记录同时发给了A’和B； C和D没有收到这条插入信息。

BCD在切换主库的时候，需要指定我们要从新的主库A‘的哪个文件的哪个位置开始备份。

我们只知道A是在T时刻断的，A和A'是一样的，所以我们从A’的T时刻对应的位置开始备份。

这个位置是会让从库多备份数据还是少备份数据呢？

我们知道假设T时刻仅有一条语句被执行，那么这条语句在A‘上这条语句的时间一定大于A上的这条语句的记录时间。倘若BCD只有T时刻的没有备份，那么它们按照T时刻来读取数据，他们会多读一部分数据出来。

倘若有多条语句在执行，但是最晚的是在T时刻执行结束的，那么倘若从库没有更新这些语句，而这些语句在备库上的分布可能散布在T的前后，从库可能会有遗漏。

所以这并不是一个好的选择。



   

#####    GTID

正如我们介绍的那样，通过位点来更新，因为备库需要并行操作binlog的原因，使得主备库的binlog的文件名称和位置都不大一致，而且并没有任何规律而言，不是一个好选择。

基于此背景，GTID应运而生。

**Global Transcation Identifier**

即全局事务id，是一个事务在**提交**的时候生成的。是这个事务的唯一标识。

GTID=server_uuid:gno

server_uuid 是一个实例在第一次启动的时候创建的，是一个全局唯一的值。

实例指的是mysql服务，每个不同的mysql服务器都是一个不同的实例。

关于gno，官网给出的GTID的解释是：
GTID=source_id:transaction_id

source_id 就是server_id

但是transaction_id有别于我们平时说的事务id，我们平时说的事务id，是在事务执行的过程中分配的，并不是提交的时候分配的，如果事务出错回滚了，那么这个id是不会再分配给别的事务的，而gno是再提交的时候分配的，这个是严格顺序递增的。



##### GTID如何开启

启动一个mysql示例的时候，gtid_mode=on enforce_gtid_consistency=on



##### GTID的值如何生成

取决于session中的Gtid_next，因为这个gtid是全局唯一的，这个session我们推测也是全局共享的。

###### gtid_next = automatic

这个是mysql默认的方式；这个时候mysql做了几件事情：

1. 在写binlog的时候 SET @@SESSION.GTID_NEXT=‘server_uuid:gno’;
2. 把这个gtid加入到这个示例的gtid组中

这有几个问题，binlog写入失败了怎么办，我们看下上图截取的binlog的内容，我们可以发现，这个set操作时在binlogcommit成功之后写的，如果在写这个之前数据库服务宕机了，那么这个值还没有生成，gno也不会被分配。



###### set gtid_next='current_gtid’

这种不会使用mysql分配的默认值，而是会使用我们给他赋予的值。

如果这个值在gtidset中已经存在，那么这个事务会直接被系统忽略

如果不存在，那么接下来的事务会使用这个id，然后gno并不加一。

假如我的gno现在时2，我给它分配个3，然后下一个事务加的时候发现3已经存在，那会发生什么事情呢？按照之前的逻辑，我猜测接下来的事务会被忽略。

但是这种情况发生的概率不大，这种方式使用的目的不是让人为的来生成gtid，而是我们已经知道了一个gtid，需要让一个实例跳过这个，不然会出错，但是因为这个实例中不包含这个gtid，所以我们可以设置一个空的事务，gtid赋予这个值。



##### gtid相关使用概况

我们在实例X上建表如下：

```mysql

CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

insert into t values(1,1);
```

![img](https://static001.geekbang.org/resource/image/28/c2/28a5cab0079fb12fd5abecd92b3324c2.png)



  一张图彻底把我的三观击碎了，这个gtid的值是在事务执行的一开始就创建了，如果是这样的话，如果我binlog写一般宕机了，咋整

我们来分析下这种情况，如果写一半宕机了，那么这个事务就是执行失败了，那gno会加一吗？不会，因为写完binlog后会把这个值加到集合中，加到之后，这个值才加一。

那还有个问题，如果此时有并发的多个线程同时在写，那这个是如何分配的呢？这个我们先略过不表。

如果X有个从库，那么那个从库在执行这个binlog的事务的时候会先执行这两个SET命令。倘若执行完成之后失败了呢？

我感觉我有点钻牛角尖了，我假设程序在任何一个时间点都会出异常，还要出异常之后程序可以恢复到完好无损的状态。

下面作者给出了gtid的第二种使用方法的举例，即我们主动设置的情况。

作者给出的场景的是，我X是另一个Y的从库，然后X是Y从库的基础上，X还进行插入操作。

这是最骚的，X不应该是readonly吗？

其实我感觉作者这里想要论述的就是我们这个设置不是盲目的设置，而是为了跳过某些不应该执行的事务而特意设置的。



##### 基于GTID的主备切换

我们之前说了基于位点的主备切换，是不好控制的。

那我们来看下基于GTID的主备切换要如何做：

即此时从库B要设置新主库到A‘。

我们要把B的主库配置连接到A'.

此时B中有基于A的GTID列表，A’中也有一份A的GTIDset。

B在请求的时候会把自己维护的GTID列表发给A‘，A'会把B中没有的发给它。

此时如果B请求的GTID不在A’中，会直接报错，说明A‘数据不完整，此时我们应该人工排查问题。

切换之后，如果A’有新的事务，那么会生成server_id_A':1

此时B和A'维护的GTID集合就是server_uuid_of_A:1-N, server_uuid_of_A’:1-M



作者描述了，比如B有G1，A'有G2，我们在G2中找到第一条不在G1中存在的数据，然后往后顺序读取就可以了。

这个我有个疑问，binlog写入不是并行写的吗？并行写的，难道它的GTID是写成功之后去申请的吗？如果是这样，那就解释的通了。这样维护了binlog中的GTID完全有序。

如果我们要这样的话，不难想象如果我写成功了，但是我申请失败了，那这个算是成功还是失败。

我们来分析一下时刻：
如果binlog写数据成功，但是GTID申请的时候失败，那此时恢复的时候，这个事务算是失败的事务，不会被执行。

如果binlog写数据成功，GTID申请的时候也成功，但是写到GTID集合的时候宕机，这个事务就是成功的事务，这个GTID集合每次重启的时候会去检测加上那些这种情况导致的问题。



##### GTID和在线DDL

###### 背景

1. 示例X和示例Y互为主备
2. 发现查询压力大是因为有个索引没加，我们需要在不暂停服务的情况下加索引，但是我们知道加索引的过程需要全表扫描构建B+树，这个是很耗性能的。当然我们可以在一个机器上先执行这个加索引的操作，另一个对外提供服务。
3. 在互为主备的情况下，一个机器做的操作是会记录binlog并发给另一台机器执行的，所以我们必须把加索引的这台机器的binlog给关了。
4. 如果我们不记录binlog了，那么我们使用binlog来备份数据的时候不会导致数据的不一致吗。



###### 具体方案

X和Y虽互为主备，为了区分，我们把X称为主机，Y为备机

1. 在X上执行 stop slave，停止 向Y传输binlog

2. 在Y上执行DDL

3. 执行完成之后查询这个DDL的语句对应的GTID

4. 到示例X上执行

   ```mysql
   
   set GTID_NEXT="server_uuid_of_Y:gno";
   begin;
   commit;
   set gtid_next=automatic;
   start slave;
   ```

   这样X在执行的时候就跳过了这个事务，为了弥补这个事务，我们在已经加好了索引的Y，设置为主表，执行stop slave语句，然后复刻即可。

   

   这有几个问题：

   1. X上执行stop slave之后，X和Y还有数据往来吗？
      - 我猜测是没有了，这时候两个都可以响应读写需求，但是都是各自的
      - 之所以这样猜测是因为倘若Y可以像X发binlog，那这个就等于没用，我们手动执行之前，X就已经收到执行了
      - 如果X会向Y发送数据，我们知道在DDL的时候，获取了Y上的一个快照，在此基础上建立了索引，然后把这个期间的更新操作插入到索引中。
      - 所以X和Y发不发都不影响Y的执行。

   
   
   ##### 思考题
   
   你在 GTID 模式下设置主从关系的时候，从库执行 start slave 命令后，主库发现需要的 binlog 已经被删除掉了，导致主备创建不成功。这种情况下，你觉得可以怎么处理呢？
   
   
   
   解： 到从库查看这个被删除的binlog是啥，然后在主库重放一下。
   
   
   
   





   

   





