

#### 前言

*Q: 为什么表中数据删除了一半，但是表大小没有变呢？*

如果要回答这个问题，我们需要知道，表文件大小是如何定义的，我们是怎么查询到这个参数的，查询的过程中是精确查询还是近似算的，带着这些问题，我们开启今天的学习。



#### 表大小的组成

1. 表结构的元数据文件
   - 大小基本可以忽略不计
2. 表中存储的数据文件
   - 是本文讨论的对象



#### 表文件的存储

有个参数的控制，innodb_file_per_table，参数值是ON/OFF

这个参数的值是ON的时候，表示一个表使用一个单独的文件来存。

默认值是ON。

默认值设置为ON的理由是好管理，无论是写还是删除都比多张表写在一个文件中好管理。

这边有个问题，有没有拆分文件的机制，就是一个表的数据量很大很大。

我们来分析一下，很大，但是磁盘存的下，就是数据页有点多，我们有索引来定位不同的数据页，其实底层的存储都是数据页，都是已经拆分之后的，所以我觉得没必要拆分了。

但是是谁把大文件转换成数据页的呢？然后给数据页编号，这个就是存储引擎做的事情了，我们从逐渐发展的角度来看这个问题，一开始表的大小都是很小的，innodb引擎在启动的时候，应该有个设置，表示他能访问多大的磁盘空间，然后把这些磁盘空间划分数据页来管理，当我们写入数据的时候，虽然给我们看到的是一个文件，但是在最底层，英是一个一个的数据页。



#### 删除操作的影响

1. 如果是drop table 命令
   - 这种是直接会把表对应的文件全部删除，这种情况下，空间是直接释放了。
2. 如果是删表中的某些行的数据
   - 这种情况下，表文件大小是不会删除的，这个类似于jvm的垃圾回收算法的标记删除算法，当我们删除一个行的时候，只是把这个记录所在的位置标记为删除，但是不实际的删除数据



#### 数据删除的流程

##### 记录复用和数据页复用

![img](https://static001.geekbang.org/resource/image/f0/c8/f0b1e4ac610bcb5c5922d0b18563f3c8.png)

我们以此图为例，当我们删除R4这条记录时，InnoDB引擎就不会删除500这条数据，而是标记为已删除，后面如果来了一个id=400的可以直接复用这个位置，如果来了一个id=800的就不能复用这个位置。

这就是记录复用，复用的必须在一定范围内的数据，因为一个数据页的数据拿本例来说都有一个范围，如果在这个范围内，而这个范围内恰好有个已删除的位置，那么就可以直接复用；

这种删除基本不会对表文件大小有影响。

当然如果我们把R3和R5也给删除了，那么这种整个数据页上的记录全部标记为已删除的，此时整个数据页就可以被复用，那么此时该数据页可以存放任意一条数据，不受范围的限制，但是一旦他第一条数据确定之后，他后面的数据也是有范围的。

> 这边说句题外话，如果两个相邻的数据页的的利用率很低，那么他们会进行合并，然后空出来的数据页可以被复用。
>
> 一样的问题，相邻如何定义？相邻要么是逻辑相邻，要么是物理相邻，因为索引文件的存储是随机的，物理相邻的两个数据页存储的内容可能都不相同，就不存在合并一说，这边的合并应该是针对存储相同的数据页，那么就是逻辑相邻，因为B+树的叶子节点之间存储了相邻的数据页的存储地址，类似链表，我们可以知道下一个数据页的地址，然后访问到地址之后，如果达到了我们合并的阈值，就会进行移动合并标记等操作。



###### delete操作

用delete删除表之后，我们只是把这个表对应的所有数据页进行标记为已删除，可复用，但是实际上并没有删除数据，表文件大小并不会变化。



如果我们把这种占用空间，却不实际存储数据的现象叫空洞的话，那么除了上述的删除，插入更新会造成吗？会的，下面我们逐个来分析一下



###### insert操作

所有情况下的插入都会导致空洞情况的出现吗？

不会，如果我们插入的索引是严格递增的，那么单从插入而言，索引文件是紧凑的，是不会有空洞现象的产生的。

这是不是就是用自增主键的另一个理由呢？在这里我回顾了索引一节，发现作者在文末确实提出了，使用自增主键防止页分裂的场景，当时我不理解的，现在突然想明白了。

但是我们经常会不使用自增主键，而是使用uuid，或者一个业务相关的字段作为主键，这种主键都导致了一个问题，就是没办法保证严格递增，一旦没办法保证严格递增，一个问题就会出现在我们面前：页分裂。

![img](https://static001.geekbang.org/resource/image/80/ea/8083f05a4a4c0372833a6e01d5a8e6ea.png)

假设pageA已满，当我们插入550的时候，没有空间，此时就会触发页分裂，还会更新索引树，页分裂会从pageA上把比插入的值大的全部转到pageb上*这个纯属我个人瞎猜，看图说话。*总而言之，这个会导致pageA上出现了空洞，实际上我们只是在新申请的页上把600给拷贝了过去，pageA上原本存储600的记录没有被删除，而仅仅是标注为已删除，可复用。

[innodb的存储](https://www.cnblogs.com/163yun/p/8892324.html)，今天在做count(*)的时候发现了这个文章，文章中记录了，如果插入数据时，要拆入的页已满，会把页的数据分成两个页，左边的页存储的是比当前插入的值小的，右边的值是比当前值大的。

如果更新的话，为了保证索引的有序性，也是在一个合适的位置上插入更新的新值，然后把原来的值的位置标记为已删除。



这些插入删除和更新都是很正常且频繁的操作，通过我们上面的分析会导致很多空洞，简单的说就是浪费了磁盘空间，那有没有方法解决这种问题呢？重建表应运而生。

#### 重建表

##### 目的

- 收缩表空间
  - 其实就相当于一次垃圾的收集操作
  - 收缩表空间就相当于把一些分布在多个数据页上的可被复用的记录整合到一起，变成数据页复用
  - 收缩表空间是要重建索引的，一旦从建索引，那些标记为删除的位置就没有存在的必要了，所以可以被删除

##### 方法

- 逐行拷贝

  - 这个方案的逻辑是，我们虽然不按递增主键的顺序插入数据，但是在我们现在已有数据的情况下，由于主键的唯一性，所以这些记录之间可以按照主键进行严格排序
  - 当我们按照主键严格递增的顺序插入数据到另一张表中的时候，就可以保证数据的紧凑性，不会出现数据空洞的情形出现。
  - 我们描述的数据空洞一般都是基于主键索引树而描述的
  - 在5.5版本之前，mysql就是这样实现的
    - mysql服务器完成了建临时表、转存数据、交换表名、删除旧表的操作，这边的删除就是直接把表文件给删了，就可以释放空间了
    - 我们回顾整个过程最耗时的是转存数据这一步的操作
    - **而且这种方式，表A是不能有更新的，不然会造成数据丢失**，这种就意味着整个过程必须在服务离线的情况下执行，即**Offline**

  ![img](https://static001.geekbang.org/resource/image/02/cd/02e083adaec6e1191f54992f7bc13dcd.png)



##### Online 重建表

> 背景就是改善之前的只能Offline重建的状态，让我们在数据变化的时候，也可以执行上述的重建操作

###### 操作流程

1. 我猜测，在运行的一开始，先开启了一致性视图，获取了我们重建表那一时刻，关于表A的一致性快照
2. 基于此快照得到所有的数据页，并写到一个临时的数据文件中
3. 我们还使用一个文件（row_log）来记录从我们重建表的那一时刻开始，所有的在表A上应用的变化
4. 当我们使用一致性视图重建表A结束之后，在使用row_log把这段时间关于表A的更改全部应用到新的b+树上
   - 这边仍然是要求不能对表A有任何更新操作，但是最耗时的不是这一步，而是获取临时文件并重建索引树的那一步，一般而言这个速度是比较快的，而且这段时间对表A的改动也不会很大，不然我们也不会选择在这个时间来重建表



在之前的跟锁有关的文章中，曾有疑问，DDL 之前是要拿 MDL 写锁的，这样还能叫 Online DDL 吗？

当我看到这段话的时候，都已经遗忘了，重建表的命令其实是`alter table A engine=InnoDB`,这是一条DDL指令

我们发现当我们在执行DDL语句的时候是要拿MDL（元数据锁）写锁的，MDL是分读锁和写锁的，读锁的时候，别的线程是可以进行增删改查的，但是写锁的时候，所有的操作都会被暂停。而且只有有读锁，我们是没办法获取写锁的。

通过我们上面分析的操作流程，只有第四部的时候，才需要升级为写锁，在启动的时候，我们会申请写锁，表示我们可以做这个操作，但是申请到之后，在做数据拷贝的时候，这一步是最耗时的，降级为读锁，知道最后一步合并这段时间内对表A的操作的时候，才重新升级为写锁，之所以是降级而不释放，是因为不想让别的DDL语句运行。

而且从作者对评论的回复而言，这个升级为写锁的操作不一定成功，如果我们设置了超时时间，这个ddl事务会回滚。



![img](https://static001.geekbang.org/resource/image/2d/f0/2d1cfbbeb013b851a56390d38b5321f0.png)





#### Online 和 inplace

这两个都是DDL语句相关的概念，我们知道了Online的含义，但是并不知道inplace的含义，以及两者的区别。

inplace是跟Online相关的一个概念，因为在没有Online DDL 之前，我们发现，数据是先转到tmp_table中的，一个临时表，这个临时表示在server层创建的，而Online之后，我们发现数据是转到tmp_file一个临时文件中的，这个是在innodb层做的，对server层而言，没有消耗server层的空间，属于原地操作，即inplace名字的来源。

这里我们发现，拷贝数据的时候，现在的Online和Offline拷贝的位置是不一样的，一个是拷贝到了server层的临时表中，一个是拷贝到了InnoDB引擎的临时文件中。

Q: 如果你有一个 1TB 的表，现在磁盘间是 1.2TB，能不能做一个 inplace 的 DDL 呢？

A: 虽然是名字是原地，但是不意外拷贝就不需要额外的空间了，这个原地不需要额外的空间是相对于server层来说的。但是我猜测这边是不是描述的不太严谨，因为1TB的表，可能其中的很多数据页全是数据空洞，实际的数据可能仅用不到1g，这样我的tmp_file的大小就控制在了1g一下，这样两个加起来仍然是没有超过磁盘的容量的。这边作者的本意是告诉大家不要被原地这个词给骗了，以为不需要申请额外的空间，所以我就不用在这斤斤计较了。

[mysql online ddl](https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-space-requirements.html)一文中指出，当我们在生成临时文件的时候，我们并不知道原来的表中有多少数据，所以我们会尝试申请跟元表大小一模一样的空间大小，如果申请不到应该就会报错。





我在之前的理解inplace是跟Online同时出现的一个概念，但是作者紧接着就给出了一个加全文索引的示例，告诉我这两个没啥关系，像是两个形容词，在重建表的时候都能用来修饰发生了什么。

`alter table t add FULLTEXT(field_name);`

当我们在执行这个语句的是时候，是会阻塞增删改操作的，但是是原地操作。



- DDL如果是Online的，一定是inplace的
- DDL是inplace，不一定是Online的（mysql8.0 的时候添加全文索引和空间索引就是这种情况）

#### optimize table、analyze table 和 alter table的区别

-  alter table 从5.6开始就是我们叙述的Online了（recreate）
- analyze table 不是重建表语句，只是对索引数据进行重新计算，加了MDL读锁
- optimize table = recreate+analyze
- truncate = drop + create



#### 问答时间

假设现在有人碰到了一个“想要收缩表空间，结果适得其反”的情况，看上去是这样的：一个表 t 文件大小为 1TB；对这个表执行 alter table t engine=InnoDB；发现执行完成后，空间不仅没变小，还稍微大了一点儿，比如变成了 1.01TB。你觉得可能是什么原因呢 ？

答：这个其实我在阅读文章有疑惑的时候去翻评论的时候看到了答案，下面说说我在答案影响之后的思路把，如果变大了，说明在整理之前表可能就没有空洞，或者极少，而在整理的过程中，一个数据页也不是完全插满的，这一导致了整理之后的密度还不如整理前，导致了这种现象。

还有一个是我在分析的时候发现但是一直没想起来，就是我们在重建表的时候不会中断DML的，在合并的时候，也会导致数据空洞的产生。



