

#### 前言

*Q: 为什么表中数据删除了一半，但是表大小没有变呢？*

如果要回答这个问题，我们需要知道，表文件大小是如何定义的，我们是怎么查询到这个参数的，查询的过程中是精确查询还是近似算的，带着这些问题，我们开启今天的学习。



#### 表大小的组成

1. 表结构的元数据文件
   - 大小基本可以忽略不计
2. 表中存储的数据文件
   - 是本文讨论的对象



#### 表文件的存储

有个参数的控制，innodb_file_per_table，参数值是ON/OFF

这个参数的值是ON的时候，表示一个表使用一个单独的文件来存。

默认值是ON。

默认值设置为ON的理由是好管理，无论是写还是删除都比多张表写在一个文件中好管理。

这边有个问题，有没有拆分文件的机制，就是一个表的数据量很大很大。

我们来分析一下，很大，但是磁盘存的下，就是数据页有点多，我们有索引来定位不同的数据页，其实底层的存储都是数据页，都是已经拆分之后的，所以我觉得没必要拆分了。

但是是谁把大文件转换成数据页的呢？然后给数据页编号，这个就是存储引擎做的事情了，我们从逐渐发展的角度来看这个问题，一开始表的大小都是很小的，innodb引擎在启动的时候，应该有个设置，表示他能访问多大的磁盘空间，然后把这些磁盘空间划分数据页来管理，当我们写入数据的时候，虽然给我们看到的是一个文件，但是在最底层，英是一个一个的数据页。



#### 删除操作的影响

1. 如果是drop table 命令
   - 这种是直接会把表对应的文件全部删除，这种情况下，空间是直接释放了。
2. 如果是删表中的某些行的数据
   - 这种情况下，表文件大小是不会删除的，这个类似于jvm的垃圾回收算法的标记删除算法，当我们删除一个行的时候，只是把这个记录所在的位置标记为删除，但是不实际的删除数据



#### 数据删除的流程

##### 记录复用和数据页复用

![img](https://static001.geekbang.org/resource/image/f0/c8/f0b1e4ac610bcb5c5922d0b18563f3c8.png)

我们以此图为例，当我们删除R4这条记录时，InnoDB引擎就不会删除500这条数据，而是标记为已删除，后面如果来了一个id=400的可以直接复用这个位置，如果来了一个id=800的就不能复用这个位置。

这就是记录复用，复用的必须在一定范围内的数据，因为一个数据页的数据拿本例来说都有一个范围，如果在这个范围内，而这个范围内恰好有个已删除的位置，那么就可以直接复用；

这种删除基本不会对表文件大小有影响。

当然如果我们把R3和R5也给删除了，那么这种整个数据页上的记录全部标记为已删除的，此时整个数据页就可以被复用，那么此时该数据页可以存放任意一条数据，不受范围的限制，但是一旦他第一条数据确定之后，他后面的数据也是有范围的。

> 这边说句题外话，如果两个相邻的数据页的的利用率很低，那么他们会进行合并，然后空出来的数据页可以被复用。
>
> 一样的问题，相邻如何定义？相邻要么是逻辑相邻，要么是物理相邻，因为索引文件的存储是随机的，物理相邻的两个数据页存储的内容可能都不相同，就不存在合并一说，这边的合并应该是针对存储相同的数据页，那么就是逻辑相邻，因为B+树的叶子节点之间存储了相邻的数据页的存储地址，类似链表，我们可以知道下一个数据页的地址，然后访问到地址之后，如果达到了我们合并的阈值，就会进行移动合并标记等操作。



###### delete操作

用delete删除表之后，我们只是把这个表对应的所有数据页进行标记为已删除，可复用，但是实际上并没有删除数据，表文件大小并不会变化。



如果我们把这种占用空间，却不实际存储数据的现象叫空洞的话，那么除了上述的删除，插入更新会造成吗？会的，下面我们逐个来分析一下



###### insert操作

所有情况下的插入都会导致空洞情况的出现吗？

不会，如果我们插入的索引是严格递增的，那么单从插入而言，索引文件是紧凑的，是不会有空洞现象的产生的。

这是不是就是用自增主键的另一个理由呢？在这里我回顾了索引一节，发现作者在文末确实提出了，使用自增主键防止页分裂的场景，当时我不理解的，现在突然想明白了。

但是我们经常会不使用自增主键，而是使用uuid，或者一个业务相关的字段作为主键，这种主键都导致了一个问题，就是没办法保证严格递增，一旦没办法保证严格递增，一个问题就会出现在我们面前：页分裂。

![img](https://static001.geekbang.org/resource/image/80/ea/8083f05a4a4c0372833a6e01d5a8e6ea.png)

假设pageA已满，当我们插入550的时候，没有空间，此时就会触发页分裂，还会更新索引树，页分裂会从pageA上把比插入的值大的全部转到pageb上*这个纯属我个人瞎猜，看图说话。*总而言之，这个会导致pageA上出现了空洞，实际上我们只是在新申请的页上把600给拷贝了过去，pageA上原本存储600的记录没有被删除，而仅仅是标注为已删除，可复用。

如果更新的话，为了保证索引的有序性，也是在一个合适的位置上插入更新的新值，然后把原来的值的位置标记为已删除。



这些插入删除和更新都是很正常且频繁的操作，通过我们上面的分析会导致很多空洞，简单的说就是浪费了磁盘空间，那有没有方法解决这种问题呢？重建表应运而生。

#### 重建表





