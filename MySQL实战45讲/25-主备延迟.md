#### 前言

我们在上一章高可用中知道，高可用=主备延迟低，延迟越低，就越可用。同时也知道了经常造成主备延迟的一些原因，本文对这些原因进行细化。

通读本文后，知道了本文其实就是在解决我在高可用一文中提出的生产者消费者问题，因为这二者的操作内容是不一致的，时间并不可以完全等价，实际上消费可能更快一些。本文的知识点非常多，今天对一些背景和之前的疑惑进行梳理。



#### 疑问的梳理

##### 主备延迟的根本原因

![img](https://static001.geekbang.org/resource/image/1a/ef/1a85a3bac30a32438bfd8862e5a34eef.png)

我们在主备一章中描述了这样一副图，图中的两个黑色箭头表示并发度。

正如图中描述的那样，其实主库写盘的并发度是远远高于备库消费的能力的。

如果主库的压力不大，因为备库一直在消费，所以这主备延迟还有缩小的可能，但是如果主库的压力一直很大，那么备库的延迟就会一直增加。



影响主库写日志的就是各种锁，但是除了那种热点数据会造成锁而阻塞并发度以外，大部分的锁基本不影响并发度。



5.6之前备库的复制是单线程的，当主库压力变大的情况下，主备的延迟会持续升高。



##### 备库的多线程复制

类似于线程池，每个需要执行的binlog语句都是一个一个任务，线程池中有个工作线程队列，这个工作线程的数目是由参数指定的。

但是和传统的多线程不同的是，这个取任务是有限制的。

![img](https://static001.geekbang.org/resource/image/bc/45/bcf75aa3b0f496699fd7885426bc6245.png)

其中 coordinator就是原来的sql_thread,不过目前它并不负责解析入库数据了，它仅仅负责把binlog分发给后面的worker线程。真正负责入库的是work线程。

我们知道如果两个事务都需要修改一张表的一行，那么他们在备库上的执行顺序应该是一致的，这就要求我们在分发的时候需要把这种类型的事务分发给一个worker线程去执行，然后执行顺序要保证和主库的顺序一致。

还有一个情况，就是一个事务中的多个更新语句可以交给不同的worker线程来处理吗？也不大行，虽然最终的结果是一致的，但是给不同的线程更新，就会有一个短暂的不一致的时间段出现，如果我们恰好在此时间段进行查询，那么就会出错。



以上就是我们并行执行入库的时候两条准则

1. 事务的更新不能覆盖，其实两个事务修改同一行，肯定有一个要覆盖另一个，唯一的区别就是谁覆盖谁，这个的标准是后执行的覆盖先执行的，先后相对于其在主库上的执行时间。
2. 同一个事务不能放到多个worker去执行，**这边有个东西我感觉到了，但是我现在还说不明白，等我以后来灵感了再说。**



##### 并行的两种思路

###### 按表分发

这个的逻辑很简单，就是我两个事务修改的是两张表，那这两个事务必不可能互相影响，所以执行的先后顺序不影响，可以分给不同的worker执行。

每个worker有个hash表，表的key是库名+表名。

1. 这就意味着两件事情，一是不同的库表可能hash值一样，会分到一个worker下计算
2. 这个类似java的HashMap,相同的库表会加到同一个worker，排在队列中，并且有个计数器标注了引用次数。



有几个情况需要说明：

1. 如果事务A它修改了库A下的表t，它通过hash计算，发现它应该分给worker6，然后会加到worker6的队列中，等待被调度
2. 如果事务A修改了库A下的表t1 和 t2,而这两张表分别由worker1和worker2分配，那么其会阻塞，直到其需要等待的worker变成1个或者以下，两个表自然会计算出两个hash值，而且就之前的情况，这两个hash值不一样，至于分配给哪个，那就要看冲突的worker哪个先执行完，选择分配给先执行完的。



按表分配的worker冲突情况

1. 与任何worker都不冲突，分配给最闲的那个；
2. 和一个worker冲突，分配给冲突的那个
3. 和两个及以上的worker冲突，阻塞，直到冲突的worker数量变成一个及以下。



按表分配的局限性

1. 当遇到热点表时，会退化成单线程更新。

为了解决热点表的问题，我们又找到了按行分发的策略。



###### 按行分发

把锁的粒度从表缩小到表中的行。为了解决热点表而诞生的一个并行执行的策略。

核心就是如果两个事务不改同一行数据，那么我们就可以默认这两个事务是可以并行的。

按照这个思路，我们有几个问题：

1. binlog必须是row，因为只有row格式的binlog我们才能知道是改了哪几行。
2. 



