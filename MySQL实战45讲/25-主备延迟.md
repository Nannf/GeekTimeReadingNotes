#### 前言

我们在上一章高可用中知道，高可用=主备延迟低，延迟越低，就越可用。同时也知道了经常造成主备延迟的一些原因，本文对这些原因进行细化。

通读本文后，知道了本文其实就是在解决我在高可用一文中提出的生产者消费者问题，因为这二者的操作内容是不一致的，时间并不可以完全等价，实际上消费可能更快一些。本文的知识点非常多，今天对一些背景和之前的疑惑进行梳理。



#### 疑问的梳理

##### 主备延迟的根本原因

![img](https://static001.geekbang.org/resource/image/1a/ef/1a85a3bac30a32438bfd8862e5a34eef.png)

我们在主备一章中描述了这样一副图，图中的两个黑色箭头表示并发度。

正如图中描述的那样，其实主库写盘的并发度是远远高于备库消费的能力的。

如果主库的压力不大，因为备库一直在消费，所以这主备延迟还有缩小的可能，但是如果主库的压力一直很大，那么备库的延迟就会一直增加。



影响主库写日志的就是各种锁，但是除了那种热点数据会造成锁而阻塞并发度以外，大部分的锁基本不影响并发度。



5.6之前备库的复制是单线程的，当主库压力变大的情况下，主备的延迟会持续升高。



##### 备库的多线程复制

类似于线程池，每个需要执行的binlog语句都是一个一个任务，线程池中有个工作线程队列，这个工作线程的数目是由参数指定的。

但是和传统的多线程不同的是，这个取任务是有限制的。

![img](https://static001.geekbang.org/resource/image/bc/45/bcf75aa3b0f496699fd7885426bc6245.png)

其中 coordinator就是原来的sql_thread,不过目前它并不负责解析入库数据了，它仅仅负责把binlog分发给后面的worker线程。真正负责入库的是work线程。

我们知道如果两个事务都需要修改一张表的一行，那么他们在备库上的执行顺序应该是一致的，这就要求我们在分发的时候需要把这种类型的事务分发给一个worker线程去执行，然后执行顺序要保证和主库的顺序一致。

还有一个情况，就是一个事务中的多个更新语句可以交给不同的worker线程来处理吗？也不大行，虽然最终的结果是一致的，但是给不同的线程更新，就会有一个短暂的不一致的时间段出现，如果我们恰好在此时间段进行查询，那么就会出错。



以上就是我们并行执行入库的时候两条准则

1. 事务的更新不能覆盖，其实两个事务修改同一行，肯定有一个要覆盖另一个，唯一的区别就是谁覆盖谁，这个的标准是后执行的覆盖先执行的，先后相对于其在主库上的执行时间。
2. 同一个事务不能放到多个worker去执行，**这边有个东西我感觉到了，但是我现在还说不明白，等我以后来灵感了再说。**

