#### 前言

我们在上一章高可用中知道，高可用=主备延迟低，延迟越低，就越可用。同时也知道了经常造成主备延迟的一些原因，本文对这些原因进行细化。

通读本文后，知道了本文其实就是在解决我在高可用一文中提出的生产者消费者问题，因为这二者的操作内容是不一致的，时间并不可以完全等价，实际上消费可能更快一些。本文的知识点非常多，今天对一些背景和之前的疑惑进行梳理。



#### 疑问的梳理

##### 主备延迟的根本原因

![img](https://static001.geekbang.org/resource/image/1a/ef/1a85a3bac30a32438bfd8862e5a34eef.png)

我们在主备一章中描述了这样一副图，图中的两个黑色箭头表示并发度。

正如图中描述的那样，其实主库写盘的并发度是远远高于备库消费的能力的。

如果主库的压力不大，因为备库一直在消费，所以这主备延迟还有缩小的可能，但是如果主库的压力一直很大，那么备库的延迟就会一直增加。



影响主库写日志的就是各种锁，但是除了那种热点数据会造成锁而阻塞并发度以外，大部分的锁基本不影响并发度。



5.6之前备库的复制是单线程的，当主库压力变大的情况下，主备的延迟会持续升高。



##### 备库的多线程复制

类似于线程池，每个需要执行的binlog语句都是一个一个任务，线程池中有个工作线程队列，这个工作线程的数目是由参数指定的。

但是和传统的多线程不同的是，这个取任务是有限制的。

![img](https://static001.geekbang.org/resource/image/bc/45/bcf75aa3b0f496699fd7885426bc6245.png)

其中 coordinator就是原来的sql_thread,不过目前它并不负责解析入库数据了，它仅仅负责把binlog分发给后面的worker线程。真正负责入库的是work线程。

我们知道如果两个事务都需要修改一张表的一行，那么他们在备库上的执行顺序应该是一致的，这就要求我们在分发的时候需要把这种类型的事务分发给一个worker线程去执行，然后执行顺序要保证和主库的顺序一致。

还有一个情况，就是一个事务中的多个更新语句可以交给不同的worker线程来处理吗？也不大行，虽然最终的结果是一致的，但是给不同的线程更新，就会有一个短暂的不一致的时间段出现，如果我们恰好在此时间段进行查询，那么就会出错。



以上就是我们并行执行入库的时候两条准则

1. 事务的更新不能覆盖，其实两个事务修改同一行，肯定有一个要覆盖另一个，唯一的区别就是谁覆盖谁，这个的标准是后执行的覆盖先执行的，先后相对于其在主库上的执行时间。
2. 同一个事务不能放到多个worker去执行，**这边有个东西我感觉到了，但是我现在还说不明白，等我以后来灵感了再说。**



##### 并行的两种思路

###### 按表分发

这个的逻辑很简单，就是我两个事务修改的是两张表，那这两个事务必不可能互相影响，所以执行的先后顺序不影响，可以分给不同的worker执行。

每个worker有个hash表，表的key是库名+表名。

1. 这就意味着两件事情，一是不同的库表可能hash值一样，会分到一个worker下计算
2. 这个类似java的HashMap,相同的库表会加到同一个worker，排在队列中，并且有个计数器标注了引用次数。



有几个情况需要说明：

1. 如果事务A它修改了库A下的表t，它通过hash计算，发现它应该分给worker6，然后会加到worker6的队列中，等待被调度
2. 如果事务A修改了库A下的表t1 和 t2,而这两张表分别由worker1和worker2分配，那么其会阻塞，直到其需要等待的worker变成1个或者以下，两个表自然会计算出两个hash值，而且就之前的情况，这两个hash值不一样，至于分配给哪个，那就要看冲突的worker哪个先执行完，选择分配给先执行完的。



按表分配的worker冲突情况

1. 与任何worker都不冲突，分配给最闲的那个；
2. 和一个worker冲突，分配给冲突的那个
3. 和两个及以上的worker冲突，阻塞，直到冲突的worker数量变成一个及以下。



按表分配的局限性

1. 当遇到热点表时，会退化成单线程更新。

为了解决热点表的问题，我们又找到了按行分发的策略。



###### 按行分发

把锁的粒度从表缩小到表中的行。为了解决热点表而诞生的一个并行执行的策略。

核心就是如果两个事务不改同一行数据，那么我们就可以默认这两个事务是可以并行的。

按照这个思路，我们有几个问题：

1. binlog必须是row，因为只有row格式的binlog我们才能知道是改了哪几行。
2. 不改同一行，两个事务就不会起冲突了吗？如果有唯一键的约束该怎么办？

```mysql

CREATE TABLE `t1` (
  `id` int(11) NOT NULL,
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `a` (`a`)
) ENGINE=InnoDB;

insert into t1 values(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);
```

建表和初始化语句如下，

倘若我们先执行

```mysql
update t1 set a = 6 where id = 1;
update t1 set a = 1 where id = 2;
```

第一条语句是比第二条语句先执行的。

如果我们仅仅按照修改的行不一样就判定两个可以并行，那么如果第二个语句先执行，我们就会收到一个唯一键冲突的异常。



###### 按行分发的约束

1. binlog格式必须是row
2. 唯一标记一个行需要 库名+表名 + 唯一键的key 和唯一键的值

唯一键必定包含主键，可能包含其他定义的唯一键。

倘若我们解析第二条语句的binlog，我们能知道啥呢？

1. 我会影响库A的t1表的id=2 的这行
2. 我会影响库A的t1表的a=2的这行
3. 我会影响库A的t1表的a=1的这行

同样的，我们第一条语句就是

1. t1 id = 1
2. t1 a =1
3. t1 a = 6

所以当我们判断的时候发现这两个是有冲突的，是不能并发执行的。



###### 按行分发的缺点

1. 需要大量的计算：要获取库名，表名 主键的值 唯一索引的列 唯一索引的值
2. 表必须有主键（没有也有rowid吧）
3. 表不能有外键，级联更新不会记录再binlog中，这样会导致冲突判断不准确。

如果是大事务的话，比如修改100w行记录，那么我们就要再内存中算100w次，然后再保存起来，这个对cpu和内存的占用都是极大的。

按行分发的并行度比按表的高很多，但是对大事务而言，因为会引入过多的计算，而导致可能把计算资源消耗殆尽。这个消耗殆尽并不是说不行，而是把本来用来入库的资源，用来计算各种数据上，有点得不偿失。

所以对小事务可以通过这个提高并行度，如果是大事务，我们就让他单线程运行吧。

简单的实现就是

1. 设置阈值，binlog修改的行数超过这个值后就算大事务
2. 再执行这个大事务的时候，先等待现有的worker全部执行完成
3. 完成后单线程运行大事务
4. 恢复多线程。



以上的按表并行和按行并行的策略都是作者在mysql还没有支持并行化的时候，自己改的一个方案，基本指出了并行的思路，下面我们来具体看下mysql官方的并行处理方案。



##### 官方的并行方案

###### 按库分发

锁的粒度上升到整个库。

优点是计算量少，同样库的事务放到一个worker去执行。



缺点是：

并发度不高，实践中常见的库就是了了几个，这种方案基本达不到优化的效果。



###### 由redolog组提交而产生的并行策略

1. 什么是组提交

   redolog prepare  binlog  redolog commit;

   当我们在prepare的时候，是先写到redologbuffer中，如果配置的是1，那么会直接写到磁盘上，在这个过程中，redologbuffer上可能还有了其他事务的redolog的prepare，那此时他们会一起被刷盘，这就是组提交。

2. 组提交为什么可以产生并行策略

   我们从刚刚组提交的定义可以看出，组提交是一组并行的事务，事务一旦可以并行，那么他们一定不会有冲突，所有我们可以把一组提交的事务加上一个标识：commit_id.这样我们在备库的时候，可以按照组提交的id来分发给不同的worker。



我们在备库执行的时候，为了检测两个事务不冲突，粒度可以定为 库 表 行，这种组提交就模拟了主库在执行sql语句天然的冲突判断，更方便，方案堪称惊艳。

组提交的并行是每次取一组的事务，然后把这一组的事务分发给不同的worker执行，当执行完成之后，再去取第二组的事务。

这里我们就发现了一个问题，就是在主库当一组事务commit的时候，此时后面的事务已经在执行了，但是，此时我们的备库在执行的时候，是一组一组取的，此时二者之间会有一个微妙的时间差。

这种并行受大事务影响比较严重，比如一组有一个大事务，那么整组甚至整个的执行时间都会超长。





##### 5.7的并行策略

###### DATABASE

即前文描述的库并行



###### LOGICAL_CLOCK

和之前的redolog的组提交类似。二者的区别是前者的判断逻辑是一组同时处于commit的事务，他们是可以并行的。但是我们知道当一组事务处于prepare的时候，就说明他们通过了锁检测。

由此我们可以得出，如果两个事务同时处于prepare状态，那么它们是可以并行的。

什么叫同时呢？怎么判断是否是同时呢？

事务在prepare状态的时候是可以落盘的，但是我们知道主备使用的是binlog，binlog又没有prepare状态，那它要怎么复制呢？这个地方有点问题。





##### 一些问题

1. 主库和备库的交互方式是binlog
2. binlog是主库主动发送给备库，之所以这样是因为如果备库请求的话会有一个时间差，我们不能一直请求。
3. binlog什么时候会把binlog发送给备库呢？
   1. 当它落盘的时候，因为当binlog落盘的时候，我们就已经可以认为这个事务已经处于完成状态，就算此时数据库服务崩了，我们可以通过binlog并利用XID找到磁盘上的prepare状态的redolog完成恢复。由此我们推断，当binlog落盘之后，就是传送的时候。
   2. 这里我有个疑问，就是主备如何检测差异，比如我备库备份一半的时候挂了，那么我重启备库的时候，如果断点续背？这个问题我们以后再来回答。
4. 后提交的事务的binlog，会不会比先提交事务的binlog先写
   1. binlog是什么时候会去写，不同的事务的binlog都是先写到自己的binlog cache中然后再追加写到一个binlog file中，我们知道一旦多个事务之间可以并行执行，那么他们的binlog之间的执行顺序不会引起语义的不一致，所有我们可以不用考虑两者的先后顺序。
5. 处在commit状态的事务，会释放锁吗
   1. 我们知道锁是再需要的时候获取，并在commit之后释放，commit的一个步骤就包括把redolog置为commit状态，也是commit的最后一步，所以我们这里可以认为当处于commit状态的事务是不在持有任何锁的。
6. 处于prepare状态的事务和出于commit状态的时候可以并行吗
   1. 我们再第五条分析了，commit状态的事务不在持有锁，那处在prepare阶段的事务可能会持有commit事务相同的锁，二者按理来说不是不可以并行的吗。





引用作者关于prepare并行的解释

> “处于prepare状态的事务，可以并行” 在实现上是，主库在写binlog的时候会给这些binlog里面记commit_id和sequence_no，来说明事务之间在主库上并行prepare的状态；
>
> 备库是通过解析binlog拿到 commit_id 和 sequence_no，来决定要怎么并发的。









