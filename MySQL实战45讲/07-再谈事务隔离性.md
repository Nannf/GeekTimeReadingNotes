### 背景

我们引入了行锁，当事务A开启可重复读事务的时候，获取到了一个全局的快照，当它执行到某一行的时候，发现事务B在更新这一行，那事务A就会被锁住，等事务B更新结束的时候，事务A接着操作，问题是此时事务A看到的这行记录是什么？



要解决这个问题，我们需要先明白，全局的快照到底是什么？

比如数据库的数据有100g，难道全局快照是拷贝一个100g的副本出来吗？想想不太可能，因为当事务并发一上来，没有任何机器能顶的住。而且磁盘拷贝100g的速度慢的令人发指。

基于此，数据库保存每行的时候，都有一个版本的概念，其实数据库对一行数据保存了多个版本，每个版本对应一个修改其数据的事务id，数据库的事务id是严格递增的。

> 但是申请的早，不代表我修改的早。比如一个事务我启动的贼早，假设事务id是1，但是我啥都不做，就在那挂着，后面的事务id到100了，而且已经对这个数据修改了，如果此时这个1才修改这行数据，那这行数据对应的事务id是啥呢？是1
>
> 但是这会影响可重复读吗？



如果我申请的早，但是我迟迟不操作，那么在每个事务开启的时候，都会去获取所有正在运行，且尚未提交的事务id，组成一个事务数组，我们记做 T[], 如果你在我查询的时候，1这个事务改了，虽然你的事务id比我小，但是你是在这个事务数组中，意味着我在开启事务的时候，你还没提交，你这次提交是在我开启之后才提交的，所以这个版本的数据，我们不要。



数据库在进行多版本控制的时候，其实只会保留最新版本的文件，然后每次修改都会有undolog，通过undolog去回滚得到之前的版本。

当可重复读事务启动的时候，会去获取整个数据库引擎中，所有正在运行的事务，正在运行意味着，事务已经开启，尚未提交。

如果我在读一行数据的时候，发现它对应的事务id，比我当前事务的大，我就不读，通过undolog，回滚到上个版本接着判断，直到找到我可见的版本。

如果发现事务id比我的小，我会判断这个事务id，是否在启动时检测的事务数组中，数组中的事务，对当前事务而言也是不可见的。

如果不在数组中，表示是可见的。我们取可见的最小的一条，作为读取的结果。

1. 如果事务未提交，那么只可能是我当前事务启动之后才开启的，或者是我启动的时候它已经再启动了，这时候对我而言是不可见的。
2. 如果事务已提交，但是提交的事务在我启动时创建的事务数组里，这对我也是不可见的，因为我启动的时候，你没有完成。
3. 如果事务已提交，但是不在我的启动事务数组里，需要判断当前的事务id跟我的关系，如果比我的大，说明了什么，如果比我的小又说明了什么？什么情况下一个比我大的事务会比我先提交，就是我中间有三十个事务都卡在那，然后后面的事务执行完了，这三十事务 还在卡着，那有个问题，我这三十个事务在启动的时候事务数组里有没有这个事务，都没有，但是它后来执行的，显然我不应该看到，只要你比我事务数组中的最大事务id还大，我一定看不到。如果你事务id比我小，而且你不在我的启动事务数组中，我能看到吗，一定能，因为比我小的要么是跟我一样一直在挂着的，要么是已经执行完了，如果一直是挂着的，那么在我的启动数组中应该有它的身影，但是没有，说明它早执行完了，说明对我是可见的。



