### 背景

我们引入了行锁，当事务A开启可重复读事务的时候，获取到了一个全局的快照，当它执行到某一行的时候，发现事务B在更新这一行，那事务A就会被锁住，等事务B更新结束的时候，事务A接着操作，问题是此时事务A看到的这行记录是什么？



要解决这个问题，我们需要先明白，全局的快照到底是什么？

比如数据库的数据有100g，难道全局快照是拷贝一个100g的副本出来吗？想想不太可能，因为当事务并发一上来，没有任何机器能顶的住。而且磁盘拷贝100g的速度慢的令人发指。

基于此，数据库保存每行的时候，都有一个版本的概念，其实数据库对一行数据保存了多个版本，每个版本对应一个修改其数据的事务id，数据库的事务id是严格递增的。

> 但是申请的早，不代表我修改的早。比如一个事务我启动的贼早，假设事务id是1，但是我啥都不做，就在那挂着，后面的事务id到100了，而且已经对这个数据修改了，如果此时这个1才修改这行数据，那这行数据对应的事务id是啥呢？是1
>
> 但是这会影响可重复读吗？



如果我申请的早，但是我迟迟不操作，那么在每个事务开启的时候，都会去获取所有正在运行，且尚未提交的事务id，组成一个事务数组，我们记做 T[], 如果你在我查询的时候，1这个事务改了，虽然你的事务id比我小，但是你是在这个事务数组中，意味着我在开启事务的时候，你还没提交，你这次提交是在我开启之后才提交的，所以这个版本的数据，我们不要。



数据库在进行多版本控制的时候，其实只会保留最新版本的文件，然后每次修改都会有undolog，通过undolog去回滚得到之前的版本。

当可重复读事务启动的时候，会去获取整个数据库引擎中，所有正在运行的事务，正在运行意味着，事务已经开启，尚未提交。

如果我在读一行数据的时候，发现它对应的事务id，比我当前事务的大，我就不读，通过undolog，回滚到上个版本接着判断，直到找到我可见的版本。

如果发现事务id比我的小，我会判断这个事务id，是否在启动时检测的事务数组中，数组中的事务，对当前事务而言也是不可见的。

如果不在数组中，表示是可见的。我们取可见的最小的一条，作为读取的结果。

1. 如果事务未提交，那么只可能是我当前事务启动之后才开启的，或者是我启动的时候它已经再启动了，这时候对我而言是不可见的。
2. 如果事务已提交，但是提交的事务在我启动时创建的事务数组里，这对我也是不可见的，因为我启动的时候，你没有完成。
3. 如果事务已提交，但是不在我的启动事务数组里，需要判断当前的事务id跟我的关系，如果比我的大，说明了什么，如果比我的小又说明了什么？什么情况下一个比我大的事务会比我先提交，就是我中间有三十个事务都卡在那，然后后面的事务执行完了，这三十事务 还在卡着，那有个问题，我这三十个事务在启动的时候事务数组里有没有这个事务，都没有，但是它后来执行的，显然我不应该看到，只要你比我事务数组中的最大事务id还大，我一定看不到。如果你事务id比我小，而且你不在我的启动事务数组中，我能看到吗，一定能，因为比我小的要么是跟我一样一直在挂着的，要么是已经执行完了，如果一直是挂着的，那么在我的启动数组中应该有它的身影，但是没有，说明它早执行完了，说明对我是可见的。

![img](https://static001.geekbang.org/resource/image/82/d6/823acf76e53c0bdba7beab45e72e90d6.png)

图中事务b执行查询的时候，k=3；但是按照我们之前的分析，因为事务B启动比事务C早，事务C的事务id应该是大于事务B的，那么事务C的修改按道理事务B是不应该看见的，但是实际情况下，事务B再执行的时候确实是看到了事务C的更新。

我们之前的解释出了什么问题呢？

我们发现之前的描述都只涉及读，而且我们遗漏一个点就是一个事务除了能看见在它启动之前就已经提交完成的事务造成的修改之外，还应该能看见自己造成的修改。这是理所当然的。

但是我们没有说，当更新的时候我们读的是啥。实际上如果你在事务B的update语句之前，执行select语句，它看到的k还是1。

执行update的时候，我们使用的就不是一致性视图中的值，而是最新的提交值，即**当前读**。

当事务B在update的时候，事务C已经更新完毕，此时最新的数据是事务C修改的。此时k=2。

B在更新的时候，读取的就是开k=2,然后最新的值是自己这个事务修改的，所以下面的select看到的是3.

我们再看事务A，因为它没有更新操作，所以它读取的值一直是创建时的一致性视图中带的值，后面的事务B和事务C的修改它都看不见。

所以A执行查询语句的时候，看到的k=1；



![img](https://static001.geekbang.org/resource/image/cd/6e/cda2a0d7decb61e59dddc83ac51efb6e.png)

如果是这种情况，B执行查询的时候，K的值是多少呢？

我们在上一节知道了，事务加锁是两段的，事务C对id=1这一行加了行锁，虽然语句已经执行完了，但是事务没有提交，此时还持有id=1的行锁。此时事务B来更新的时候，~~因为是DML语句，需要获取读锁~~，获取不到，会进入到阻塞状态。等事务C提交之后，它才被唤醒，来更新，此时B看到的就是3.

> **这边我搞混了，DML是读锁，是表级别的锁，不是行锁，行锁是更新的时候，这一行就被锁了，不存在说我们都是DML语句可以同时改**

对事务A而言，这个人还在闷头装死，看到的还是一。

读提交的事务隔离级别下，每个视图是在执行的时候创建的。

![img](https://static001.geekbang.org/resource/image/82/d6/823acf76e53c0bdba7beab45e72e90d6.png)

以这个为例，因为是读提交隔离级别，这个start transaction with consistent snapshot 就没用了，等价于 start transaction.

对事务A而言，在执行的时候，会用最新的数据创建视图，所以读到的是事务C提交的2.

事务B而言，更新使用的一直是最新的数据，所以B读到的还是3。



#### 思考题

。我用下面的表结构和初始化语句作为试验环境，事务隔离级别是可重复读。现在，我要把所有“字段 c 和 id 值相等的行”的 c 值清零，但是却发现了一个“诡异”的、改不掉的情况。请你构造出这种情况，并说明其原理。

```mysql

mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, c) values(1,1),(2,2),(3,3),(4,4);
```

![img](https://static001.geekbang.org/resource/image/9b/0b/9b8fe7cf88c9ba40dc12e93e36c3060b.png)

复现出来以后，请你再思考一下，在实际的业务开发中有没有可能碰到这种情况？你的应用代码会不会掉进这个“坑”里，你又是怎么解决的呢？

这个题目首先我们要能构造出这种场景。

我们来分析下，当我们更新的时候，发现0条数据匹配，但是我们读的时候发现数据还是匹配的，说明两者之间的数据版本不同，而更新是当前读，读取是事务启动的时候创建的一个一致性视图，所以我们推测在事务启动的时候，当前表的数据还没有修改，但是我们启动过之后，在update之前已经有事务修改，且提交。我们在update的时候，基于的是最新的记录，所以发现没有行匹配的，但是我们读的时候还是事务启动时的视图，因为修改的事务提交的时候是在我们这个事务启动之后，所以这个对我们而言是不可见的。