### 背景

我们引入了行锁，当事务A开启可重复读事务的时候，获取到了一个全局的快照，当它执行到某一行的时候，发现事务B在更新这一行，那事务A就会被锁住，等事务B更新结束的时候，事务A接着操作，问题是此时事务A看到的这行记录是什么？



要解决这个问题，我们需要先明白，全局的快照到底是什么？

比如数据库的数据有100g，难道全局快照是拷贝一个100g的副本出来吗？想想不太可能，因为当事务并发一上来，没有任何机器能顶的住。而且磁盘拷贝100g的速度慢的令人发指。

基于此，数据库保存每行的时候，都有一个版本的概念，其实数据库对一行数据保存了多个版本，每个版本对应一个修改其数据的事务id，数据库的事务id是严格递增的。

> 但是申请的早，不代表我修改的早。比如一个事务我启动的贼早，假设事务id是1，但是我啥都不做，就在那挂着，后面的事务id到100了，而且已经对这个数据修改了，如果此时这个1才修改这行数据，那这行数据对应的事务id是啥呢？是1
>
> 但是这会影响可重复读吗？



如果我申请的早，但是我迟迟不操作，那么在每个事务开启的时候，都会去获取所有正在运行，且尚未提交的事务id，组成一个事务数组，我们记做 T[], 如果你在我查询的时候，1这个事务改了，虽然你的事务id比我小，但是你是在这个事务数组中，意味着我在开启事务的时候，你还没提交，你这次提交是在我开启之后才提交的，所以这个版本的数据，我们不要。



数据库在进行多版本控制的时候，其实只会保留最新版本的文件，然后每次修改都会有undolog，通过undolog去回滚得到之前的版本。

当可重复读事务启动的时候，会去获取整个数据库引擎中，所有正在运行的事务，正在运行意味着，事务已经开启，尚未提交。

如果我在读一行数据的时候，发现它对应的事务id，比我当前事务的大，我就不读，通过undolog，回滚到上个版本接着判断，直到找到我可见的版本。

如果发现事务id比我的小，我会判断这个事务id，是否在启动时检测的事务数组中，数组中的事务，对当前事务而言也是不可见的。

如果不在数组中，表示是可见的。我们取可见的最小的一条，作为读取的结果。

1. 如果事务未提交，

