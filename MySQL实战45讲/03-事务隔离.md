### 什么是事务

通常都会拿转账举例，事务就可以理解为一个原子操作，要么都成功要么都失败；

关键点：

	1. 包含多个操作，这多个操作之间具有逻辑上的一致性；

### 事务由什么保证

我们知道mysql包括服务端和数据引擎，事务是在数据引擎层面保证的。



### 几个概念

1. 脏读

   > 这里和线程很像，前提是数据库中是可以运行多个事务的，就跟可以运行多个线程一样；
   >
   > 假设有两个事务分别是A和B，他们共享了数据表T里面的一个字段X；
   >
   > A在某一个时刻读取了X的值，恰好B在A读取成功的前一刻修改了字段X的值，这时候A读取的就是B修改之后的值；
   >
   > 然后因为一些原因导致B的这次关于X的修改失败了，事务回滚，那A的这次读取就被称为**脏读**
   >
   > 我们用一句话概括就是**一个事务读取到另一个事务修改失败的数据**
   >
   > 脏读会导致什么问题呢？就假如事务A要根据X的值来判断走什么逻辑，一旦出现脏读，就会导致错误的处理逻辑。

2. 不可重复读

   > 这个跟脏读很类似，出现的场景就是，当事务A读取X的值，然后再读取成功之后，事务B修改了X的值，而且修改成功了，然后A再来读取X的值发现跟刚刚读取的不一致了，这就是**不可重复读**。
   >
   > 一句话概括：一个事务再读取一个数据之后，被另一个事务给修改了。
   >
   > 不可重复读会导致什么问题呢？这个其实只有在特定的场景下才是问题，就是我希望在我事务执行的期间，我读到的值不会发生变化，具体什么样的场景我没有接触过，但是一旦有这个场景，而数据库是不支持的，这就是数据库的问题，这种问题可以通过数据库设置来实现吗？我们接着往下看。

3. 幻读

   > 这个和不可重复读很类似，出现的场景是：当事务A按照某一个条件搜索表T时，得到N条数据，再事务A第二次按照同样的条件来搜索表T之前，事务B往表里插入了M条符合事务A搜索条件的数据，这样当A再次读取的时候，发现就得到了N+M条数据。
   >
   > 幻读和不可重复读的区别是，幻读强调的是insert操作，不可重复读强调的是update操作。
   >
   > 一句话概括就是，一个事务，两次，同样的条件，结果集不一致。**而且是特指后面的查询看到了前面的查询没有看到的数据**。
   >
   > 幻读其实会导致问题的，但是我现在理解不了，也不是我们关注的重点，一个就是会导致行锁的语义失效，二是会导致数据一致性问题。这个我们在后面再来关注吧。
   
4. 第一类丢失更新
   
   > 事务A和事务B同时对表T修改，事务A改成功了，但是事务B改失败了，然后把数据回滚到最开始的状态，导致第一次的更新丢失。
   >
   > 这个目前已经不会发生了，我们暂时不考虑。
   
5. 第二类丢失更新
   
   > 事务A和事务B同时对表修改，事务A先改成功了，事务B后改成功了，事务B的修改会把事务A的修改覆盖掉，这是第二类数据丢失。
   >
   > 这个问题就是我们向一个账户转账，A转了1000，B也转了1000，但是因为这个问题，导致了最后账户的值只增加了1000.
   
   ##### 这几种真的有问题吗？
   
   其实这几类问题都可以类比两个线程对一个共享数据进行操作，而事务的隔离级别，就是锁的粒度。
   
      

