### 什么是事务

通常都会拿转账举例，事务就可以理解为一个原子操作，要么都成功要么都失败；

关键点：

	1. 包含多个操作，这多个操作之间具有逻辑上的一致性；

### 事务由什么保证

我们知道mysql包括服务端和数据引擎，事务是在数据引擎层面保证的。



### 几个概念

1. 脏读

   > 这里和线程很像，前提是数据库中是可以运行多个事务的，就跟可以运行多个线程一样；
   >
   > 假设有两个事务分别是A和B，他们共享了数据表T里面的一个字段X；
   >
   > A在某一个时刻读取了X的值，恰好B在A读取成功的前一刻修改了字段X的值，这时候A读取的就是B修改之后的值；
   >
   > 然后因为一些原因导致B的这次关于X的修改失败了，事务回滚，那A的这次读取就被称为**脏读**
   >
   > 我们用一句话概括就是**一个事务读取到另一个事务修改失败的数据**
   >
   > 脏读会导致什么问题呢？就假如事务A要根据X的值来判断走什么逻辑，一旦出现脏读，就会导致错误的处理逻辑。

2. 不可重复读

   > 这个跟脏读很类似，出现的场景就是，当事务A读取X的值，然后再读取成功之后，事务B修改了X的值，而且修改成功了，然后A再来读取X的值发现跟刚刚读取的不一致了，这就是**不可重复读**。
   >
   > 一句话概括：一个事务再读取一个数据之后，被另一个事务给修改了。
   >
   > 不可重复读会导致什么问题呢？这个其实只有在特定的场景下才是问题，就是我希望在我事务执行的期间，我读到的值不会发生变化，具体什么样的场景我没有接触过，但是一旦有这个场景，而数据库是不支持的，这就是数据库的问题，这种问题可以通过数据库设置来实现吗？我们接着往下看。

3. 幻读

   > 这个和不可重复读很类似，出现的场景是：当事务A按照某一个条件搜索表T时，得到N条数据，再事务A第二次按照同样的条件来搜索表T之前，事务B往表里插入了M条符合事务A搜索条件的数据，这样当A再次读取的时候，发现就得到了N+M条数据。
   >
   > 幻读和不可重复读的区别是，幻读强调的是insert操作，不可重复读强调的是update操作。
   >
   > 一句话概括就是，一个事务，两次，同样的条件，结果集不一致。**而且是特指后面的查询看到了前面的查询没有看到的数据**。
   >
   > 幻读其实会导致问题的，但是我现在理解不了，也不是我们关注的重点，一个就是会导致行锁的语义失效，二是会导致数据一致性问题。这个我们在后面再来关注吧。
   
4. 第一类丢失更新
   
   > 事务A和事务B同时对表T修改，事务A改成功了，但是事务B改失败了，然后把数据回滚到最开始的状态，导致第一次的更新丢失。
   >
   > 这个目前已经不会发生了，我们暂时不考虑。
   
5. 第二类丢失更新

   > 事务A和事务B同时对表修改，事务A先改成功了，事务B后改成功了，事务B的修改会把事务A的修改覆盖掉，这是第二类数据丢失。
   >
   > 这个问题就是我们向一个账户转账，A转了1000，B也转了1000，但是因为这个问题，导致了最后账户的值只增加了1000.

   ##### 这几种真的有问题吗？

   其实这几类问题都可以类比两个线程对一个共享数据进行操作，而事务的隔离级别，就是锁的粒度。隔离级别的出现就是为了解决这几个问题的。

   

   我在搜索事务相关文章的时候，DML，这些一直映入眼帘，我还不清楚这些是啥意思，看的我火大，现在就重新认识下这些词汇。

   

   #### SQL语言的分类

   1. **DQL**：Data Query Language
      - 数据库查询语言
      - 就是select
      - 常见的格式就是  select * from T where
   2. **DML**: Data Manipulation  Language
      - 数据库操作语言
      - **Insert**
      - **Update**
      - **Delete**
      - 这边有个疑问就是DML包不包括查询
   3. **DDL**: Data Define Language
      - 数据库定义语言
      - **CREATE TABLE/VIEW/INDEX/SYN/CLUSTER**
      - **不能回滚**
   4. **DCL**: Data Control Language
      - 数据库控制语言
      - **GRANT**:授权
      - **ROLLBACK**:回滚数据库状态到上次最后提交的状态
      - **COMMIT**：提交
        - 说起提交，就是跟事务挂钩的
        - 只有事务提交了，才算是真的修改了
        - 那到底什么是事务呢？

   ##### 再谈事务

   Q: 查询算不算事务？

   A:  不算，事务只和DML，就是增删改有关

   

   Q: 事务开启标志

   A：当增删改语句执行的时候

   

   Q: 事务结束标志

   A: 结束分为两种，成功和失败，成功就是提交(commit)；失败就是回滚(rollback)

   

   Q: 事务一定是多个语句组成的吗

   A:  事务是一个最小的不可分割的单元。一条修改语句就是一个最小的不可分割的单元，所以事务可以由一条或多条dml语句组成。

   

   Q: 事务是如何控制的？

   A: InnoDB数据引擎是用的redolog

   

   Q: DDL能回滚吗

   A: SQLServer是可以回滚的，Oracle是不可以的，看具体的数据库实现；DDL其实是对数据库表结构的一次DML，这个参照博客[DDL能回滚吗](https://blog.csdn.net/change2970955076/article/details/78084866),一文，这里不再赘述，一句话概括，DDL可以设计成回滚，但是要以降低并发性为代价。

   

   Q： DML语句一定可以自动回滚吗？

   A： 前提是DML语句中间不能参杂DDL语句，因为DDL语句再运行前和运行后都会commit。

   

   

   ##### 隔离级别

   1. 读未提交
      - 事务A可以读取事务B修改的但是还未提交的数据。
      - 这种级别什么都解决不了。
   2. 读提交
      - 事务A只能读取到

      

