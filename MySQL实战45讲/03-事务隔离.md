### 什么是事务

通常都会拿转账举例，事务就可以理解为一个原子操作，要么都成功要么都失败；

关键点：

	1. 包含多个操作，这多个操作之间具有逻辑上的一致性；

### 事务由什么保证

我们知道mysql包括服务端和数据引擎，事务是在数据引擎层面保证的。



### 几个概念

1. 脏读

   > 这里和线程很像，前提是数据库中是可以运行多个事务的，就跟可以运行多个线程一样；
   >
   > 假设有两个事务分别是A和B，他们共享了数据表T里面的一个字段X；
   >
   > A在某一个时刻读取了X的值，恰好B在A读取成功的前一刻修改了字段X的值，这时候A读取的就是B修改之后的值；
   >
   > 然后因为一些原因导致B的这次关于X的修改失败了，事务回滚，那A的这次读取就被称为**脏读**
   >
   > 我们用一句话概括就是**一个事务读取到另一个事务修改失败的数据**
   >
   > 脏读会导致什么问题呢？就假如事务A要根据X的值来判断走什么逻辑，一旦出现脏读，就会导致错误的处理逻辑。

2. 不可重复读

   > 这个跟脏读很类似，出现的场景就是，当事务A读取X的值，然后再读取成功之后，事务B修改了X的值，而且修改成功了，然后A再来读取X的值发现跟刚刚读取的不一致了，这就是**不可重复读**。
   >
   > 一句话概括：一个事务再读取一个数据之后，被另一个事务给修改了。
   >
   > 不可重复读会导致什么问题呢？这个其实只有在特定的场景下才是问题，就是我希望在我事务执行的期间，我读到的值不会发生变化，具体什么样的场景我没有接触过，但是一旦有这个场景，而数据库是不支持的，这就是数据库的问题，这种问题可以通过数据库设置来实现吗？我们接着往下看。

3. 幻读

   > 这个和不可重复读很类似，出现的场景是：当事务A按照某一个条件搜索表T时，得到N条数据，再事务A第二次按照同样的条件来搜索表T之前，事务B往表里插入了M条符合事务A搜索条件的数据，这样当A再次读取的时候，发现就得到了N+M条数据。
   >
   > 幻读和不可重复读的区别是，幻读强调的是insert操作，不可重复读强调的是update操作。
   >
   > 一句话概括就是，一个事务，两次，同样的条件，结果集不一致。**而且是特指后面的查询看到了前面的查询没有看到的数据**。
   >
   > 幻读其实会导致问题的，但是我现在理解不了，也不是我们关注的重点，一个就是会导致行锁的语义失效，二是会导致数据一致性问题。这个我们在后面再来关注吧。
   
4. 第一类丢失更新
   
   > 事务A和事务B同时对表T修改，事务A改成功了，但是事务B改失败了，然后把数据回滚到最开始的状态，导致第一次的更新丢失。
   >
   > 这个目前已经不会发生了，我们暂时不考虑。
   
5. 第二类丢失更新

   > 事务A和事务B同时对表修改，事务A先改成功了，事务B后改成功了，事务B的修改会把事务A的修改覆盖掉，这是第二类数据丢失。
   >
   > 这个问题就是我们向一个账户转账，A转了1000，B也转了1000，但是因为这个问题，导致了最后账户的值只增加了1000.

   ##### 这几种真的有问题吗？

   其实这几类问题都可以类比两个线程对一个共享数据进行操作，而事务的隔离级别，就是锁的粒度。隔离级别的出现就是为了解决这几个问题的。

   

   我在搜索事务相关文章的时候，DML，这些一直映入眼帘，我还不清楚这些是啥意思，看的我火大，现在就重新认识下这些词汇。

   

   #### SQL语言的分类

   1. **DQL**：Data Query Language
      - 数据库查询语言
      - 就是select
      - 常见的格式就是  select * from T where
   2. **DML**: Data Manipulation  Language
      - 数据库操作语言
      - **Insert**
      - **Update**
      - **Delete**
      - 这边有个疑问就是DML包不包括查询
   3. **DDL**: Data Define Language
      - 数据库定义语言
      - **CREATE TABLE/VIEW/INDEX/SYN/CLUSTER**
      - **不能回滚**
   4. **DCL**: Data Control Language
      - 数据库控制语言
      - **GRANT**:授权
      - **ROLLBACK**:回滚数据库状态到上次最后提交的状态
      - **COMMIT**：提交
        - 说起提交，就是跟事务挂钩的
        - 只有事务提交了，才算是真的修改了
        - 那到底什么是事务呢？

   ##### 再谈事务

   Q: 查询算不算事务？

   A:  不算，事务只和DML，就是增删改有关

   

   Q: 事务开启标志

   A：当增删改语句执行的时候

   

   Q: 事务结束标志

   A: 结束分为两种，成功和失败，成功就是提交(commit)；失败就是回滚(rollback)

   

   Q: 事务一定是多个语句组成的吗

   A:  事务是一个最小的不可分割的单元。一条修改语句就是一个最小的不可分割的单元，所以事务可以由一条或多条dml语句组成。

   

   Q: 事务是如何控制的？

   A: InnoDB数据引擎是用的redolog

   

   Q: DDL能回滚吗

   A: SQLServer是可以回滚的，Oracle是不可以的，看具体的数据库实现；DDL其实是对数据库表结构的一次DML，这个参照博客[DDL能回滚吗](https://blog.csdn.net/change2970955076/article/details/78084866),一文，这里不再赘述，一句话概括，DDL可以设计成回滚，但是要以降低并发性为代价。

   

   Q： DML语句一定可以自动回滚吗？

   A： 前提是DML语句中间不能参杂DDL语句，因为DDL语句再运行前和运行后都会commit。

   

   #### 事务和线程

   线程是操作系统调度的最小单位；

   事务时数据库服务器调度的最小单位；

   二者都涉及对共享数据的访问。

   事务可以理解为一个线程。

   

   ##### 隔离级别

   1. 读未提交
      - 事务A关于共享数据的修改，虽然没有提交成功，但是别的事务也可以看到。
      - 这种级别什么都解决不了。
      
   2. 读提交
      - 事务A关于共享数据的修改，只有提交成功之后，别的事务才能看到。

   3. 可重复读
      - 事务A在事务运行期间，关于某个共享数据的值，是一直不变的。
   4. 串行化
      - 事务A在执行事务期间，别的事务只能等待。
      - **这边其实有个疑问，因为作者给出的解释中，说关于一行数据的处理，读会加读锁，写会加写锁，当我们试图对一行数据加锁时，要先判断有没有锁，没有的话才能加成功。**
        - 这其实有个问题，就是读也算是事务吗？
        - 这个锁的粒度到底是什么级别的？按照作者的描述，事务的锁的级别似乎是行锁。这个我们后面看能否得到解答。
        - 我理解的锁又是库锁，就是整个库都被锁住，这个显然是不合理的，因为我只要锁住我操作的数据就行了，那些我不操作的数据，说白了跟我就不是共享的，我不用管，所以这个锁可能是表锁。

   =
#### 接着补充概念

Q: 数据库在启动的时候只能有一种隔离级别吗？

A: 反证，如果不是这样的，我查询的时候可以指定隔离级别，但是因为隔离级别都是和别人进行交互的，你指定了级别有啥用啊，你说你指定了我这次查询的隔离级别时串行化，好问题来了，你跟谁两串行化呢？由此可证，事务的隔离级别在一个确定的时刻，只可能存在一种，是一个全局变量。

Q: 我们为什么要有数据库隔离级别，为什么还要分等级

A: 有共享数据，多共享 数据的操作，我们要加锁，隔离级别就是锁的粒度。我们回顾一下java中同步相关的知识，当多线程对一个共享变量操作的时候，我们为什么要加锁，因为如果不加锁，我对共享数据的修改别人不能看到，每个线程关于共享数据其实都是持有一个自己的副本，事务呢？不同的事务由一个自己的副本吗？



Q: 我们来想这样一个场景，事务A就是当表T的ID字段为1的时候，我们把ID加1，同时把S字段的值赋予9527；事务B是当表T的ID字段为1的时候，我们把ID加1，同时把S的值变成2403；假设事务A先执行，但是事务A没执行结束，事务B开始执行，这个时候我们要首先由一个期望，就是我们希望数据库的最终结果是什么样子的？假如我们接受的结果是，ID=2,S=9527/2403,那么此时我们的隔离级别就是读未提交。这个时候我又考虑到，当事务A再改的时候，如果没有加锁，事务B也是可以改的。那此时这个读提交和读未提交又什么区别吗？读未提交是，我事务B再执行的时候，我就已经发现这个ID=1的改成2了，我就不会改这个了，但是读提交，是我看不到，我们各改各的，我不知道数据库底层这个修改是不是原子操作，如果不是的话那它两改的话，也是看cpu调度的，那它两谁会覆盖谁这个是未知的。这个我突然就不明白了，除非你是加锁的，否则当多个事务在执行的时候，你的执行结果是未知的。这个真的不会有问题吗？



我们再看事务的四个特性**ACID**

### 事务的四大特性

#### A:原子性

> 事务的操作，要么都成功，要么都失败。

#### C:一致性

> 我都原子了，能不一致吗？这个不是业务要求的吗，和我数据库有啥关系。

#### I: 隔离性

> 说是不同事务之间应该是感知不到别的事务的存在的，那我的读未提交，不是还是感知到了别的事务的修改了吗，网上给的全是拷贝的语句，我感觉这边的值得商榷。

#### D:持久性

> 这个我也想吐槽，改了就是改了，但是可以被别的事务覆盖，最后会落盘，这个是啥意思....

我感觉四大特性就原子性还有点意思，其他的都有点扯



#####       隔离级别的实现

###### 补充概念

1. 视图

   > mysql中视图的意思可以简单的理解为一张虚拟表，它由真是的表查询而来，那些真实的表我们又叫做基表，基表的改动会影响视图的数据。



读未提交需要用视图吗？它每次查询都是基于最新的数据，这个查询查询的应该是内存，而事务未提交时，其实再内存中已经写了。所以读未提交无需视图。

读提交需要视图吗？作者给出的解释时每个SQL语句开始执行的时候创建的；



这个原理我们缺失太多的知识，作者只是给出了结论，这块我们先略过。



