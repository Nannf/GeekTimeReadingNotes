#### 前言

到我最喜欢的主备一致了。



问：为什么需要多台机器？

答：

- 为了高性能，我们可以把一部分查询的操作放到备库去做
- 为了备份，高可靠（其实为了达到可靠的目的是冗余，而多台机器恰好是冗余的），我们为了高性能使用了多台机器，而多台机器的天然数据冗余又让数据变得更可靠。



问：查询放到备库，不会有时差吗？主库入成功了，但是备库还没有入成功

答：看实际业务是不是有这种场景，这算是分布式系统的强一致性问题，这边我说不清楚。



问： 备库需要设置成readonly吗？

答： 最好设置，一是我们会把一些运维的查询语句放到备库去查询，如果设置成readonly，可以减少错误操作的机会。二是可以通过是否是readonly来判断主备机的角色。



问： 如果备库是readonly那怎么执行主机的数据同步呢？

答：readonly对超级管理员权限无效，执行主备同步的线程是有超级管理员权限的。



问： 主备之间的数据同步时怎么做的？

答： 

![img](https://static001.geekbang.org/resource/image/a6/a3/a66c154c1bc51e071dd2cc8c1d6ca6a3.png)



1. 备份的主体是binlog
2. 主服务器有个专门的线程负责处理备份的信息，即本文中的dump_thread
3. 在B服务器上执行 change master 指令，设置主机A的ip,port用户名，密码，以及要从哪个位置（binlog的文件名和偏移量）请求binlog
4. 在B服务器上执行start slave指令，于是B上便执行两个后台线程，io_thread sql_thread, io_thread 负责和主库连接
5. io_thread 启动之后开始尝试和A进行握手连接，A收到B的连接请求后，判断用户名和密码的正确性，通过之后，便把B请求的binlog发送给B
6. io_thread 接受到数据之后写到本地变成中转文件（relay log 中转日志）
7. sql_thread 读取并解析relay log.







