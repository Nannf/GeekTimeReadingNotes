#### 前言

本文尝试梳理加锁的类型和时机。



为了能更好的阅读本文，我通读了mysql官方文档中关于锁的叙述部分，详见番外篇2-文档中的锁。

通读完成之后，再来看这篇文章，发现知识的密度仍然非常的大，阅读起来比较吃力，日拱一卒，功不唐捐，我一天看不完，我就用一个星期，一个月，我一定可以把这篇文章看透。让我们开始吧。



本文想描述的就是mysql的加锁规则，更准确的说是mysql在执行语句的时候的加锁规则。

因为锁的种类跟事务的隔离级别有关，事务又跟存储引擎有关。我们的讨论是基于InnoDB存储引擎的RR隔离级别讨论。

考虑到后面数据库版本的升级，有些原则可能有所改变，为了严谨性5.x 系列的版本 <=5.7.24; 8.0系列的版本<=8.0.13





#### 加锁的规则

作者先给出了加锁的规则，然后使用不同情况下的语句执行，来阐述这些规则，准确的说是根据一些现象和源码总结出了这些规则，这是作者的学习之路，现在我们仅需记忆和会分析即可。

- 原则一： 加锁的基本单位是next-key lock
- 原则二： 查找过程中访问到的对象才会加锁
- 优化一： 索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化成行锁
- 优化二： 索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁
- 一个bug： 唯一索引上的范围查询会访问到不满足条件的第一个值位置。



建表如下:

```mysql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
-- 数据库版本 5.7.18-log
```



#### 案例一：等值查询间隙锁

![img](https://static001.geekbang.org/resource/image/58/6c/585dfa8d0dd71171a6fa16bed4ba816c.png)