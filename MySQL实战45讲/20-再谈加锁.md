#### 前言

本文尝试梳理加锁的类型和时机。



为了能更好的阅读本文，我通读了mysql官方文档中关于锁的叙述部分，详见番外篇2-文档中的锁。

通读完成之后，再来看这篇文章，发现知识的密度仍然非常的大，阅读起来比较吃力，日拱一卒，功不唐捐，我一天看不完，我就用一个星期，一个月，我一定可以把这篇文章看透。让我们开始吧。



本文想描述的就是mysql的加锁规则，更准确的说是mysql在执行语句的时候的加锁规则。

因为锁的种类跟事务的隔离级别有关，事务又跟存储引擎有关。我们的讨论是基于InnoDB存储引擎的RR隔离级别讨论。

考虑到后面数据库版本的升级，有些原则可能有所改变，为了严谨性5.x 系列的版本 <=5.7.24; 8.0系列的版本<=8.0.13





#### 加锁的规则

作者先给出了加锁的规则，然后使用不同情况下的语句执行，来阐述这些规则，准确的说是根据一些现象和源码总结出了这些规则，这是作者的学习之路，现在我们仅需记忆和会分析即可。

- 原则一： 加锁的基本单位是next-key lock（前开后闭）
- 原则二： 查找过程中访问到的对象才会加锁
- 优化一： 索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化成行锁
- 优化二： 索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁
- 一个bug： 唯一索引上的范围查询会访问到不满足条件的第一个值位置。



建表如下:

```mysql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
-- 数据库版本 5.7.18-log
```



#### 案例一：等值查询间隙锁

![img](https://static001.geekbang.org/resource/image/58/6c/585dfa8d0dd71171a6fa16bed4ba816c.png)

###### 我的分析

可复现。

结合优化一，索引上的等值查询给唯一索引加锁的时候会退化成行锁，但是没有id=7 的这一行。优化一失效。

优化二，索引上的等值查询，像右遍历到最后一个值不满足条件的时候，next-key lock 退化成间隙锁，就本例而言，间隙锁（5,10）

这两个就解释了图中出现的现象。

###### 实际的结论

先是根据原则一，加了next-key lock，锁住了（5,10]

再根据优化二，最后一个不满足条件的退化成间隙锁，最终的加锁范围是(5,10)

这边其实是有问题的，这个访问到的是如何理解呢？

其实因为我们定为索引的时候，不知道哪些索引会在一个数据页上，也不知道b+树上的非叶子节点的值是如何分布的，如果是这样的话，一般情况下，我们在叶子节点的上一层，定位到了查询条件所在的数据页在某一个叶子节点上，但是这个叶子节点并不一定以它作为开始，就拿本例而言，查询7的时候，这里因为7前面只有一个5，我不知道如果有比5小的是不是也会被锁住，我来试试。

我有插入了（1,1,1）（4,4,4）然后插入了（3,3,3），发现是可以插入的，这个不会被锁住，说明它其实只锁了这个间隙锁在的两边的位置，而且我们是主键索引，它其实是锁住了(5,5,5)->(10,10,10)之间的位置，这个我们是不是就可以得出结论，间隙锁不考虑实际b+树上的索引定位，而只锁了这个间隙的最近的两个索引记录。



#### 案例二：非唯一索引等值锁

![img](https://static001.geekbang.org/resource/image/46/65/465990fe8f6b418ca3f9992bd1bb5465.png)

###### 我的分析

可复现

先根据原则一，加锁的是next-key lock，会在c这个索引树上，锁住c=5这一行，和这个记录的上一条记录之间的间隙(0,5].因为c不是唯一索引，所以索引树还会往后接着查看，会扫描到十，按道理会加(5,10]这个next-key的锁，此时根据优化二，会退化成间隙锁，（5,10）.

所以C的插入被锁定是应该的，但是B为什么可以更新呢？因为我们刚刚遍历的是c索引树，我们的锁是加在c这个索引树上的，而B是使用的主键索引，这个上面是没有锁的，所以可以成功更新。

###### 实际情况

a只访问了索引C是因为**覆盖索引**的存在，这个分析的时候我遗漏了。

还有如果改成for update 系统会认为你接下来要更新数据，会给主键上加上索引。

如果你想使用 lock in share mode 防止数据被更新的话，最好避开覆盖索引。比如查询一个索引中没有的字段 如`select d from t where c = 5 lock in share mode`；实测之后，确实session B被锁住了。



#### 案例三：主键索引范围锁

这是关于范围查询的，先思考如下的问题，关于表t，如下的两种sql锁的范围相同吗

```mysql
mysql> select * from t where id=10 for update;
mysql> select * from t where id>=10 and id<11 for update;
```

###### 我的分析

1. 第一条sql语句
   - 原则一，锁住了(5,10]
   - 优化一退化成行锁，只锁住10这一行。
2. 第二条语句
   - 原则一锁住了(5,10] 和（10,15]
   - 因为不是等值查询，所有的优化没办法使用，实际锁了（5,10)的间隙 加上10 这一行，以及(10,15的间隙)，和（15）这一行。

我们来验证一下

对第一条语句而言，我们修改id=5的然后插入数据到5和10之间应该是可以成功的，但是修改10这一行，会失败。实际确实如此。

对第二条而言，我可以改id=5的记录，但是没办法插入5-10之间的数据，也没办法修改10 这一行，且没办法插入数据到10-15之间，而且没办法改15这一行。

实际是在（5-10）没有间隙锁，可以插入数据，其他的和我的预期都一致。

###### 实际结果

我的分析哪地方错了呢？错在了>=这个=号上，它首次查找的时候，使用的是等值匹配，且是主键索引上的主键匹配，这边的next-key 锁，退化成行锁。后面的就是范围锁，和我分析的就一致了。



#### 案例四：非唯一索引范围锁

范围查询加锁的问题

![img](https://static001.geekbang.org/resource/image/73/7a/7381475e9e951628c9fc907f5a57697a.png)







