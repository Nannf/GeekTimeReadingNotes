#### 前言

本文尝试梳理加锁的类型和时机。



为了能更好的阅读本文，我通读了mysql官方文档中关于锁的叙述部分，详见番外篇2-文档中的锁。

通读完成之后，再来看这篇文章，发现知识的密度仍然非常的大，阅读起来比较吃力，日拱一卒，功不唐捐，我一天看不完，我就用一个星期，一个月，我一定可以把这篇文章看透。让我们开始吧。



本文想描述的就是mysql的加锁规则，更准确的说是mysql在执行语句的时候的加锁规则。

因为锁的种类跟事务的隔离级别有关，事务又跟存储引擎有关。我们的讨论是基于InnoDB存储引擎的RR隔离级别讨论。

考虑到后面数据库版本的升级，有些原则可能有所改变，为了严谨性5.x 系列的版本 <=5.7.24; 8.0系列的版本<=8.0.13





#### 加锁的规则

作者先给出了加锁的规则，然后使用不同情况下的语句执行，来阐述这些规则，准确的说是根据一些现象和源码总结出了这些规则，这是作者的学习之路，现在我们仅需记忆和会分析即可。

- 原则一： 加锁的基本单位是next-key lock（前开后闭）
- 原则二： 查找过程中访问到的对象才会加锁
- 优化一： 索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化成行锁
- 优化二： 索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁
- 一个bug： 唯一索引上的范围查询会访问到不满足条件的第一个值位置。



建表如下:

```mysql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
-- 数据库版本 5.7.18-log
```



#### 案例一：等值查询间隙锁

![img](https://static001.geekbang.org/resource/image/58/6c/585dfa8d0dd71171a6fa16bed4ba816c.png)

###### 我的分析

可复现。

结合优化一，索引上的等值查询给唯一索引加锁的时候会退化成行锁，但是没有id=7 的这一行。优化一失效。

优化二，索引上的等值查询，像右遍历到最后一个值不满足条件的时候，next-key lock 退化成间隙锁，就本例而言，间隙锁（5,10）

这两个就解释了图中出现的现象。

###### 实际的结论

先是根据原则一，加了next-key lock，锁住了（5,10]

再根据优化二，最后一个不满足条件的退化成间隙锁，最终的加锁范围是(5,10)

这边其实是有问题的，这个访问到的是如何理解呢？

其实因为我们定为索引的时候，不知道哪些索引会在一个数据页上，也不知道b+树上的非叶子节点的值是如何分布的，如果是这样的话，一般情况下，我们在叶子节点的上一层，定位到了查询条件所在的数据页在某一个叶子节点上，但是这个叶子节点并不一定以它作为开始，就拿本例而言，查询7的时候，这里因为7前面只有一个5，我不知道如果有比5小的是不是也会被锁住，我来试试。

我有插入了（1,1,1）（4,4,4）然后插入了（3,3,3），发现是可以插入的，这个不会被锁住，说明它其实只锁了这个间隙锁在的两边的位置，而且我们是主键索引，它其实是锁住了(5,5,5)->(10,10,10)之间的位置，这个我们是不是就可以得出结论，间隙锁不考虑实际b+树上的索引定位，而只锁了这个间隙的最近的两个索引记录。



#### 案例二：非唯一索引等值锁

![img](https://static001.geekbang.org/resource/image/46/65/465990fe8f6b418ca3f9992bd1bb5465.png)

###### 我的分析

可复现

先根据原则一，加锁的是next-key lock，会在c这个索引树上，锁住c=5这一行，和这个记录的上一条记录之间的间隙(0,5].因为c不是唯一索引，所以索引树还会往后接着查看，会扫描到十，按道理会加(5,10]这个next-key的锁，此时根据优化二，会退化成间隙锁，（5,10）.

所以C的插入被锁定是应该的，但是B为什么可以更新呢？因为我们刚刚遍历的是c索引树，我们的锁是加在c这个索引树上的，而B是使用的主键索引，这个上面是没有锁的，所以可以成功更新。

###### 实际情况

a只访问了索引C是因为**覆盖索引**的存在，这个分析的时候我遗漏了。

还有如果改成for update 系统会认为你接下来要更新数据，会给主键上加上索引。

如果你想使用 lock in share mode 防止数据被更新的话，最好避开覆盖索引。比如查询一个索引中没有的字段 如`select d from t where c = 5 lock in share mode`；实测之后，确实session B被锁住了。



#### 案例三：主键索引范围锁

这是关于范围查询的，先思考如下的问题，关于表t，如下的两种sql锁的范围相同吗

```mysql
mysql> select * from t where id=10 for update;
mysql> select * from t where id>=10 and id<11 for update;
```

###### 我的分析

1. 第一条sql语句
   - 原则一，锁住了(5,10]
   - 优化一退化成行锁，只锁住10这一行。
2. 第二条语句
   - 原则一锁住了(5,10] 和（10,15]
   - 因为不是等值查询，所有的优化没办法使用，实际锁了（5,10)的间隙 加上10 这一行，以及(10,15的间隙)，和（15）这一行。

我们来验证一下

对第一条语句而言，我们修改id=5的然后插入数据到5和10之间应该是可以成功的，但是修改10这一行，会失败。实际确实如此。

对第二条而言，我可以改id=5的记录，但是没办法插入5-10之间的数据，也没办法修改10 这一行，且没办法插入数据到10-15之间，而且没办法改15这一行。

实际是在（5-10）没有间隙锁，可以插入数据，其他的和我的预期都一致。

###### 实际结果

我的分析哪地方错了呢？错在了>=这个=号上，它首次查找的时候，使用的是等值匹配，且是主键索引上的主键匹配，这边的next-key 锁，退化成行锁。后面的就是范围锁，和我分析的就一致了。



#### 案例四：非唯一索引范围锁

范围查询加锁的问题

![img](https://static001.geekbang.org/resource/image/73/7a/7381475e9e951628c9fc907f5a57697a.png)

###### 我的分析

能复现。

原则一加锁的单位是next-key lock,一开始先做等值匹配，加间隙锁(5,10）,以及行锁10，然后范围查询向右遍历，到15，加间隙锁(10,15)，和行锁15，因为这个不是等值查询也不是唯一索引，所以优化一和优化二都无法使用。

所以加锁加的是（5,15]，如果我分析的没错，那么我修改5的可以修改成功。验证之后确实可以。

但是好奇怪的是 当我执行`update t2 set d = d+1 where id  =15`按道理这行被锁了，但是我实际执行的时候是可以执行成功的，但是当执行`update t2 set d = d+1 where c  =15`是会被锁住了。发生这种情况一般常见于我们的锁是加在了c上了但是session A使用的是for update,这个会锁住主键的，而且是select * 根本不存在覆盖索引。

###### 实际情况

我后来想了一下，扫描使用的是c索引树，当我们扫描到15这一个记录的时候，我们发现不满足情况，此时只在c索引的索引树上加了行锁，和（10,15）的间隙锁，索引此时我们根据id来操作的话是可以操作的。



#### 案例五：唯一索引范围锁 bug

![img](https://static001.geekbang.org/resource/image/b1/6d/b105f8c4633e8d3a84e6422b1b1a316d.png)

###### 我的分析

原则一，加锁是next-key锁，首先访问到15，发现是符合条件的，加(10,15],然后继续访问，到了20，不满足条件，但是是范围查询，没办法优化，所以会加（15,20]next-key 锁、



###### 实际情况

这个小于等于是个啥情况呢？我们再分析时，可以把等号去掉，先分析`where id > 10 and id < 15`,

这个中间没值，没有加锁的对象，所以没有加next-key锁，但是会加间隙锁（10,15）。然后再分析

`where id = 15`这个有这个值，本来是next-key锁退化成行锁，按道理到这应该所有的加锁全部结束了。

但是InnoDB会往前扫描到第一个不满足条件的行，然后因为是范围查询，所以在20上加了一个(15,20]的next-key锁，作者认为这是个bug。



#### 案例六：非唯一索引上存在"等值"的例子

先给表t插入新数据

```mysql
mysql> insert into t values(30,10,30);
```

![img](https://static001.geekbang.org/resource/image/c1/59/c1fda36c1502606eb5be3908011ba159.png)

(10,10)和(10,30)之间也是有间隙的。

![img](https://static001.geekbang.org/resource/image/b5/78/b55fb0a1cac3500b60e1cf9779d2da78.png)

###### 我的分析

可复现。

delect的加锁方式和之前的两个原则，两个优化，一个bug是一样的。

加锁的基本单位是next-key lock，会扫描c索引，找到了c=10的两条记录，分别是(10,10),(30,30),这期间在c和主键索引上都加了(5,10],(（10,10),(30,10)],((30,10),(15,15)],根据优化二，等值查询，最后会退化成间隙锁，所以（15,15）没有被锁住。

###### 实际情况

其实没有(10,10) (30,10)这一步，因为程序会一直扫描到（15,15）所以锁是((10,10),(15,15)]这个next-key锁。

![img](https://static001.geekbang.org/resource/image/bb/24/bb0ad92483d71f0dcaeeef278f89cb24.png)



#### 案例七：limit 语句加锁

这个可以和案例六作为参照

![img](https://static001.geekbang.org/resource/image/af/2e/afc3a08ae7a254b3251e41b2a6dae02e.png)

###### 我的分析

分析的方法和之前一样，但是这个limit2不知道是啥情况。



###### 实际情况

我们来分析下如果我是服务器我会怎么做。

1. 我先扫描索引树，找到了(10,10)这条记录满足条件，加上next-key锁，(5,5)->(10,10)]，此时库里已经有一条记录
2. 因为不满足limit 2 的数量，我们接着向后扫描，发现了(30,10)这条记录，上面的锁的范围到了(5,5)->(30,10),此时返回的数据已经满足条件，服务器终止扫描，直接返回。

第二个步骤加的那个limit 的判断可以让服务器提前终止，这样加锁范围就变成了

![img](https://static001.geekbang.org/resource/image/e5/d5/e5408ed94b3d44985073255db63bd0d5.png)

**所以删除数据的时候，如果我们可知要删除的数据数量，就加上limit**，这样更安全，也能缩小加锁范围。



#### 案例八：一个死锁的例子

![img](https://static001.geekbang.org/resource/image/7b/06/7b911a4c995706e8aa2dd96ff0f36506.png)

###### 我的分析

没复现。我的报1205 Lock wait timeout exceeded;

我来强行分析一波。

session A，因为是覆盖索引，没有访问主键，所以只锁了c索引上的节点，加锁的单位是next-key 锁

此时锁住了（5,10],然后接着访问，到15，发现不符合条件，但是满足优化二，锁住了索引C树上的(5,15)这个区域。

sessionB执行的时候会被锁住。会请求C索引树上的(5,15)的锁，然后还有主键上的锁(5,15)的锁，这个加锁过程是分步走的吗。

此时A接着执行插入，插入是会申请主键上的锁的，但是主键上的锁按照执行结果看没有获取成功，sessionA此时又申请到了(5,10)这个间隙锁。

好像解释不了这个现象，我应该有东西分析错了。



###### 实际结论

我忽略了间隙锁是可以被多个事务持有的，但是插入的时候会导致死锁。

session A 先获取了next-key lock （5,10]和间隙锁（10,15）。其实（5,10]是（5,10）间隙锁+（10）行锁。

sessionB获取(5,10)间隙锁，这一步是成功的，但是在获取10这一个行锁的时候进入锁等待。

sessionA插入（8,8,8）的时候，被sessionB的间隙锁锁住，由此发生了死锁。



#### 思考题

还是表t，表中6条记录，sessionB为什么会被锁住呢

![img](https://static001.geekbang.org/resource/image/3a/1e/3a7578e104612a188a2d574eaa3bd81e.png)

答：我知道问题出在order by 但是并不清楚为什么是它导致的。

