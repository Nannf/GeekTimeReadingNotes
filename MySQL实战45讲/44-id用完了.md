#### 最后一篇

端午石家庄出差，在现场等待搭建环境的时候完成本节。



本文作者描述了mysql中几种常见的自增主键的类型，以及达到自增主键上限的时候每种不同类型的自增主键的处置方式，下面我们逐一来看。



#### 表定义自增值id

```mysql
create table t(id int unsigned auto_increment primary key) auto_increment=4294967295;
insert into t values(null);
//成功插入一行 4294967295
show create table t;
/* CREATE TABLE `t` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4294967295;
*/

insert into t values(null);
//Duplicate entry '4294967295' for key 'PRIMARY'
```

这个就是我们常说的自增主键。

值的范围是由申明的类型决定，在本例中，值的取值范围就是[0,2^32-1]。即4294967295。

当超过这个范围时，再申请会得到最大值。

这个从主键冲突可以得到证明。



#### InnoDB 系统自增的row_id

我们之前知道，如果不给表申明主键，那么innodb会生成一个默认的主键row_id;

- 长度是6字节，即48位，范围是[0,2^48-1]；

- 是全局变量，不是每个表一个，由全局变量dict_sys.row_id控制。

- 每次插入一条新数据的时候，获取当前的dict_sys.row_id当作主键，然后把dict_sys.row_id值加一。

- 当超过最大值时，会变成0，重新开始循环

- 当一个mysql实例运行的时间足够久，插入的数据足够多，那么会出现在一张表中row_id相同的情况的，当这种情况发生时，会覆盖之前存在的row_id的数据

  

我们由此得出结论为什么建议显示的创建主键。

因为覆盖数据造成的时可靠性的问题，主键重复造成的时可用性的问题，一般而言。可靠性的优先级高于可用性。

