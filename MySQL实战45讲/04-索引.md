### 索引

到了我最喜欢的索引环节了，无奖竞猜我在这一节会卡几天，我猜这周末我能读完。





### 索引出现的目的

提升查询效率



### 索引的实现组件

由存储引擎实现



### 索引的存储位置

内存和磁盘



### 索引的实现原理

其实就是一个查找算法。如果我不用索引，最坏的时间复杂度是全表遍历O(n)；

#### 哈希表

如果我用哈希表存，如果hash算法实现的比较好，而且当发生哈希冲突的时候，我们采取的方式是链表法，时间复杂度就会变成O(1)+遍历哈希冲突链表的时间；

优点：

​	时间复杂度在数据量不大的时候趋近于O(1),数据量大的时候，后面的链表也可以优化成红黑树，这个和java的hashmap实现比较类似,最好的时间复杂度是O(1),最差的时间复杂度是O(logN);

缺点：

​	设计一个较好的散列函数比较困难。而且散列表没有区间概念，只能用于等值比较，如果是区间查询，用不了hash表。

适用场景：

等值比较；



#### 有序数组

我按照升序排列成数组。

优点：

时间复杂度即是二分查找的时间复杂度(logN),而且支持区间查询，比如查询区间[x,y],我们找到第一个不小于x的值，和最后一个不大于y的值即可。

缺点：

新增和删除操作较多时，会涉及到数组的频繁移动，这个是数组的通用缺点了。

适用场景：

等值或者区间查询，而且数据变化不大。



#### 二叉搜索树

左子树都比根节点下，右子树都比根节点大。

二叉搜索树其实需要是平衡的，不然极端情况下会退化成链表，搜索的复杂度会退化成O(N)

所以这个二叉搜索树不太妥，应该是平衡二叉搜索树。

这个的搜索类似于二分查找，时间复杂度是O(logN),一般而言我们使用的是一种非严格平衡二叉搜索树，即红黑树，这个玩意除了复杂之外好像没啥缺点。

看起来红黑树是个贼好的选择，但是数据库的索引并没有使用，说是红黑树是二叉树的一种，存储数据量大的话，层数会非常多，会导致很多次的磁盘i/o,至于为什么是这样，网上的解释多是在解释磁盘i/o多了会有什么影响，或者说二叉树的每一层都在一个单独的数据块上，但是没给原因，我觉得这边需要理一下。

我们要解答的问题是**为什么mysql索引不使用红黑树**，最终选择的是B+树，这个还真不是我两个总得选一个，然后实现者喜欢B+树，所以最后是B+树，而是红黑树确实有不好的地方，让开发者不得不放弃了这个选择。



问题就变成了为什么红黑树不好，红黑树的查询，插入，删除，修改的性能表现都很稳定，业界也有比较成熟的实现方案；除了这些理论上的性能以外，索引是必须落盘的，红黑树每个节点最多只会有两子节点，如果数据量比较多的情况下，层数会比较多，层数多就一定会导致磁盘i/o增加吗？



接下来的问题就变成了要论证，层数多确实会导致磁盘i/o变多，如果要论证这个问题，首先要先了解红黑树在磁盘上是怎么存储的。

[Mysql为什么使用B+树](https://www.cnblogs.com/wangflower/p/12237762.html)一文中作者给出解释，因为cpu读取磁盘数据的时候是按照页来读的，二叉树的每个节点，都仅仅存储了当前节点的关键词信息，和自己两个子节点的信息，如果和自己的不匹配，那么cpu大概率会根据两个子节点的信息去接着寻址比较，如果是这样的话，那么二叉树有几层就需要几次磁盘i/o.

机械硬盘时代，从磁盘读一个数据块需要10ms左右的寻址时间，如果有100w条数据，可能需要log100w ~= 20次寻址，也就是20*10ms ~=0.2s 基本无法接受。

然后就是B树，也是2-3树，然后就是B+树，我看不懂，先不研究这个算法，等以后用到再说。



> 索引由存储引擎层实现，没有统一的索引标准。我们以最常用的InonoDB存储模型为例来看

### InnoDB的索引模型

*InnoDB的索引模型是B+树，每个索引都对应一颗B+树*

#### 索引种类

> 分类依据是按照叶子节点存放的内容可分为主键索引和非主键索引；
>
> 主键索引的叶子节点存放的是行内容，非主键索引存放的是主键索引的ID

![img](https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png)

图中所示，B+树的实现有点类似跳表，具体的实现我们不了解B+树这边不太好说，这边先按照我从图中看到的部分来说，B+树的叶子节点是有序的，类似于有序数组，在磁盘上的存储位置是连续的，当然空间大小也有限制，就是一个磁盘页的大小，这个应该可以设置，比如上面的300-700之间的数据非常多，多到一个数据页存不下的时候，就会发生页分裂操作，其实页分裂就是有序数组的扩容，假如我们先分裂，后来又删除了，导致多个页上的利用率不高，就会发生页合并。这两个都比较耗时。而且为了保证数组的有序，当我们不是顺序插入数据的时候，为了维护数组的有序性，我们会涉及到数组内容的移动。

页分裂和页合并我们先了解到这个程度吧，还有很多未解的地方，我们先往下看，如果确实需要了解我们再回来看。

[InnoDB引擎中的数据页](https://www.cnblogs.com/ZhuChangwu/p/14041410.html)

1. 主键索引（聚簇索引）

   Q: 表没有主键怎么办?

   A: InnoDB会给创建一个rowid当做主键索引使用

   

2. 非主键索引（二级索引）

   Q: 查询非主键索引的步骤

   A: 先通过非主键索引找到主键索引的值，再通过这个值去主键索引中查找实际的数据，这叫做**回表**；这也就意味着我们用主键作为查询条件最好，避免了一次回表操作。

![img](https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png)

下面我们来谈谈这个回表的问题，假设表T的索引结构树是上图所示：

我们执行`select * from T where k between 3 and 5`需要执行几步呢？

1. 我们会使用k这个索引树，找到3所在的记录，定位到ID=300的记录；
2. 到主键索引上根据ID=300，进行第一次回表；
3. 然后查询下一条记录，发现k=5，满足条件，然后得到了500；
4. 到主键索引中根据ID=500,进行第二次回表；
5. 接着到k索引树下，取下一条记录，发现k=6，不满足条件，查询结束。

我们一个查询了五次，回表了两次。

我们一定要回表吗？

如果我们查询的字段只有主键索引上有（主键索引上有完整的行记录），那么没办法只能回表。

如果我们查询`select ID from T where k between 3 and 5`，因为k索引树上已经有了ID信息，此时的查询就无需回表了。这种就叫做**覆盖索引**。也引出了下一个概念：**联合索引**。联合索引出现的目的就是因为我除了主键外，还有其他的经常要查询的字段，比如根据身份证号查询姓名，我们这里假设身份证号只是一个二级索引，如果我执行如下查询`select name from T where id_no='3...'`,如果不是联合索引的话，我每次都会回表。如果这种情况很普遍，那么在数据库层面我们可以建立（id_no,name）的联合索引（其他的可以引入redis这样的索引，这个我们略过不提）。这个name就是为了防止回表而新增的，这是一种“空间换时间的做法”。

> 覆盖索引是针对某个特定select查询的联合索引。

我们得出了第一个结论，为了防止多次回表，我们引入了联合索引；我们还发现，作为联合索引的第一个索引才是有用的，所以合理安排联合索引的字段顺序。

假设我建立了联合索引(b,c,d)，相当于建了 (b),(b,c)(b,c,d)三个索引。当查询的时候，查询语句必须包含b才能走联合索引，这就是**最左前缀原则**。至于为什么是这样，我们需要了解联合索引在B+树上的存储情况。我查找资料的过程中，发现了如下两篇博文：

[联合索引在b+树上的存储情况](https://blog.csdn.net/feichitianxia/article/details/107997795)

[数据库索引相关](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

下面我就用自己的理解简要的复述一下：

1. B+树虽然不是二叉查找树，但是是多叉查找树，其减少匹配的规则跟二叉查找树类似(左右只走一边，这样时间复杂度就从O(n)，变成了二叉查找树的高度)；
2. 选择走哪个子节点是通过联合索引的第一个字段判断的，因为除了第一个字段保证有序外，其他的索引都不保证有序；如果不保证有序，我就没办法判断走哪颗子树了，只能走全表扫描。



结合上面的分析，我们有个思考题，就是如果我们有索引如下 (b,c,d),但是我的where条件只有 b 和 d，那么会走索引吗？会走哪个索引？

答： 因为有b，所以会走索引，但是走到索引之后，还能根据d的值走bcd索引吗，是不行的，因为当b的值一定的时候，d的值未必有序，我们并不知道要走哪颗子树，要跳过哪些，只能把所有的b全比较一遍。











