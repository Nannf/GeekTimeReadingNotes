### 索引

到了我最喜欢的索引环节了，无奖竞猜我在这一节会卡几天，我猜这周末我能读完。





### 索引出现的目的

提升查询效率



### 索引的实现组件

由存储引擎实现



### 索引的存储位置

内存和磁盘



### 索引的实现原理

其实就是一个查找算法。如果我不用索引，最坏的时间复杂度是全表遍历O(n)；

#### 哈希表

如果我用哈希表存，如果hash算法实现的比较好，而且当发生哈希冲突的时候，我们采取的方式是链表法，时间复杂度就会变成O(1)+遍历哈希冲突链表的时间；

优点：

​	时间复杂度在数据量不大的时候趋近于O(1),数据量大的时候，后面的链表也可以优化成红黑树，这个和java的hashmap实现比较类似,最好的时间复杂度是O(1),最差的时间复杂度是O(logN);

缺点：

​	设计一个较好的散列函数比较困难。而且散列表没有区间概念，只能用于等值比较，如果是区间查询，用不了hash表。

适用场景：

等值比较；



#### 有序数组

我按照升序排列成数组。

优点：

时间复杂度即是二分查找的时间复杂度(logN),而且支持区间查询，比如查询区间[x,y],我们找到第一个不小于x的值，和最后一个不大于y的值即可。

缺点：

新增和删除操作较多时，会涉及到数组的频繁移动，这个是数组的通用缺点了。

适用场景：

等值或者区间查询，而且数据变化不大。



#### 二叉搜索树

左子树都比根节点下，右子树都比根节点大。

二叉搜索树其实需要是平衡的，不然极端情况下会退化成链表，搜索的复杂度会退化成O(N)

所以这个二叉搜索树不太妥，应该是平衡二叉搜索树。

这个的搜索类似于二分查找，时间复杂度是O(logN),一般而言我们使用的是一种非严格平衡二叉搜索树，即红黑树，这个玩意除了复杂之外好像没啥缺点。

看起来红黑树是个贼好的选择，但是数据库的索引并没有使用，说是红黑树是二叉树的一种，存储数据量大的话，层数会非常多，会导致很多次的磁盘i/o,至于为什么是这样，网上的解释多是在解释磁盘i/o多了会有什么影响，或者说二叉树的每一层都在一个单独的数据块上，但是没给原因，我觉得这边需要理一下。

我们要解答的问题是**为什么mysql索引不使用红黑树**，最终选择的是B+树，这个还真不是我两个总得选一个，然后实现者喜欢B+树，所以最后是B+树，而是红黑树确实有不好的地方，让开发者不得不放弃了这个选择。



问题就变成了为什么红黑树不好，红黑树的查询，插入，删除，修改的性能表现都很稳定，业界也有比较成熟的实现方案；除了这些理论上的性能以外，索引是必须落盘的，红黑树每个节点最多只会有两子节点，如果数据量比较多的情况下，层数会比较多，层数多就一定会导致磁盘i/o增加吗？



接下来的问题就变成了要论证，层数多确实会导致磁盘i/o变多，如果要论证这个问题，首先要先了解红黑树在磁盘上是怎么存储的。

[Mysql为什么使用B+树](https://www.cnblogs.com/wangflower/p/12237762.html)一文中作者给出解释，因为cpu读取磁盘数据的时候是按照页来读的，二叉树的每个节点，都仅仅存储了当前节点的关键词信息，和自己两个子节点的信息，如果和自己的不匹配，那么cpu大概率会根据两个子节点的信息去接着寻址比较，如果是这样的话，那么二叉树有几层就需要几次磁盘i/o.

机械硬盘时代，从磁盘读一个数据块需要10ms左右的寻址时间，如果有100w条数据，可能需要log100w ~= 20次寻址，也就是20*10ms ~=0.2s 基本无法接受。

然后就是B树，也是2-3树，然后就是B+树，我看不懂，先不研究这个算法，等以后用到再说。



> 索引由存储引擎层实现，没有统一的索引标准。我们以最常用的InonoDB存储模型为例来看

### InnoDB的索引模型

*InnoDB的索引模型是B+树，每个索引都对应一颗B+树*

#### 索引种类

> 分类依据是按照叶子节点存放的内容可分为主键索引和非主键索引；
>
> 主键索引的叶子节点存放的是行内容，非主键索引存放的是主键索引的ID

![img](https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png)

图中所示，B+树的实现有点类似跳表，具体的实现我们不了解B+树这边不太好说，这边先按照我从图中看到的部分来说，B+树的叶子节点是有序的，类似于有序数组，在磁盘上的存储位置是连续的，当然空间大小也有限制，就是一个磁盘页的大小，这个应该可以设置，比如上面的300-700之间的数据非常多，多到一个数据页存不下的时候，就会发生页分裂操作，其实页分裂就是有序数组的扩容，假如我们先分裂，后来又删除了，导致多个页上的利用率不高，就会发生页合并。这两个都比较耗时。而且为了保证数组的有序，当我们不是顺序插入数据的时候，为了维护数组的有序性，我们会涉及到数组内容的移动。

页分裂和页合并我们先了解到这个程度吧，还有很多未解的地方，我们先往下看，如果确实需要了解我们再回来看。

[InnoDB引擎中的数据页](https://www.cnblogs.com/ZhuChangwu/p/14041410.html)

1. 主键索引（聚簇索引）

   Q: 表没有主键怎么办?

   A: InnoDB会给创建一个rowid当做主键索引使用。主键索引不一定需要主键，而是根据叶子节点存放的是行记录还是其他来进行判断。

   

2. 非主键索引（二级索引）

   Q: 查询非主键索引的步骤

   A: 先通过非主键索引找到主键索引的值，再通过这个值去主键索引中查找实际的数据，这叫做**回表**；这也就意味着我们用主键作为查询条件最好，避免了一次回表操作。

![img](https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png)

下面我们来谈谈这个回表的问题，假设表T的索引结构树是上图所示：

我们执行`select * from T where k between 3 and 5`需要执行几步呢？

1. 我们会使用k这个索引树，找到3所在的记录，定位到ID=300的记录；
2. 到主键索引上根据ID=300，进行第一次回表；
3. 然后查询下一条记录，发现k=5，满足条件，然后得到了500；
4. 到主键索引中根据ID=500,进行第二次回表；
5. 接着到k索引树下，取下一条记录，发现k=6，不满足条件，查询结束。

我们一个查询了五次，回表了两次。

我们一定要回表吗？

如果我们查询的字段只有主键索引上有（主键索引上有完整的行记录），那么没办法只能回表。

如果我们查询`select ID from T where k between 3 and 5`，因为k索引树上已经有了ID信息，此时的查询就无需回表了。这种就叫做**覆盖索引**。也引出了下一个概念：**联合索引**。联合索引出现的目的就是因为我除了主键外，还有其他的经常要查询的字段，比如根据身份证号查询姓名，我们这里假设身份证号只是一个二级索引，如果我执行如下查询`select name from T where id_no='3...'`,如果不是联合索引的话，我每次都会回表。如果这种情况很普遍，那么在数据库层面我们可以建立（id_no,name）的联合索引（其他的可以引入redis这样的索引，这个我们略过不提）。这个name就是为了防止回表而新增的，这是一种“空间换时间的做法”。

> 覆盖索引是针对某个特定select查询的联合索引。如果查询的时候使用了某个联合索引，使用之后查询返回无需回表操作，那这个索引，针对这次查询就叫做覆盖索引。覆盖索引不只是select后面的字段要全部包含，还需包含where之后的条件。

我们得出了第一个结论，为了防止多次回表，我们引入了联合索引；我们还发现，作为联合索引的第一个索引才是有用的，所以合理安排联合索引的字段顺序。

假设我建立了联合索引(b,c,d)，相当于建了 (b),(b,c)(b,c,d)三个索引。当查询的时候，查询语句必须包含b才能走联合索引，这就是**最左前缀原则**。至于为什么是这样，我们需要了解联合索引在B+树上的存储情况。我查找资料的过程中，发现了如下两篇博文：

[联合索引在b+树上的存储情况](https://blog.csdn.net/feichitianxia/article/details/107997795)

[数据库索引相关](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXNoZW42L0ltZ0hvc3RpbmcvTXVaaUxlaV9ibG9nX2ltZy8yMDIwMDgxMzIwMjQ0Mi5qcGc?x-oss-process=image/format,png)

下面我就用自己的理解简要的复述一下：

1. B+树虽然不是二叉查找树，但是是多叉查找树，其减少匹配的规则跟二叉查找树类似(左右只走一边，这样时间复杂度就从O(n)，变成了二叉查找树的高度)；
2. 联合索引在B+树上的存储是每个节点都存储了索引字段的内容，并保持索引创建的字段顺序，当我们在查询和插入新的时候，是先比较第一个索引字段，然后再比较第二个，接着比较第三个依次类推。索引存在的目的是能减少遍历记录的次数，只要查询条件包含第一个字段，那就可以走这个联合索引，当然假设联合索引是(b,c,d),我们的条件是where  b =  2 and c = 3 and d = 4,这样我们就能根据这个过滤掉非常多的记录，如果where b = 2 and c = 3会如何呢，我们会根据这两个字段找到对应的树下面，然后依次遍历所有的记录，如果是 where c = 2 and d = 3 会如何，这个索引会失效，因为我们根据c和d没办法知道走哪个分叉；如果是 b 和 d 会如何，此时还是只有b的索引会生效，因为根据d，我们并不能知道选择走哪个节点，因为b确定，d的顺序是乱序的。



我们再来看看索引下推

假设我们在表tuser上建立索引 (name,age)

`mysql> select * from tuser where name like '张%' and age=10 and ismale=1;`

当name是like查询时，组合索引还会生效吗?

**组合索引有没有生效，就在于我们在索引树上进行判断的时候，通过哪些字段减少了我们最终的结果集**，在本次查询中，因为name字段是不确定的，我们根本就没办法根据age的值进行过滤，所以虽然建立了联合索引，但是只有b这一个索引生效了，后面的都需要遍历所有的张姓人员。

在MySQL5.6之前，age字段是不会使用的，但是在之后，会有一个索引下推，就是如果后面的查询条件包含的字段**在索引中**，我们会根据这个字段先做一次过滤，然后在进行回表查询，这种看起来，就跟age也生效了一样，实际上是索引下推的优化结果。



### 思考题

```mysql

CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
```

公司的同事告诉他说，由于历史原因，这个表需要 a、b 做联合主键，这个小吕理解了。

但是，学过本章内容的小吕又纳闷了，既然主键包含了 a、b 这两个字段，那意味着单独在字段 c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？同事告诉他，是因为他们的业务里面有这样的两种语句：

```mysql

select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;
```

我给你的问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？

ca索引可删，因为c这个索引会自动带主键信息，而这个主键是排好序的，跟ca的效果是一致的，至于为什么是排好序的，是InnoDB存储引擎的实现。暂时可以这样记录。





