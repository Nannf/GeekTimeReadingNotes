### 索引

到了我最喜欢的索引环节了，无奖竞猜我在这一节会卡几天，我猜这周末我能读完。





### 索引出现的目的

提升查询效率



### 索引的实现组件

由存储引擎实现



### 索引的存储位置

内存和磁盘



### 索引的实现原理

其实就是一个查找算法。如果我不用索引，最坏的时间复杂度是全表遍历O(n)；

#### 哈希表

如果我用哈希表存，如果hash算法实现的比较好，而且当发生哈希冲突的时候，我们采取的方式是链表法，时间复杂度就会变成O(1)+遍历哈希冲突链表的时间；

优点：

​	时间复杂度在数据量不大的时候趋近于O(1),数据量大的时候，后面的链表也可以优化成红黑树，这个和java的hashmap实现比较类似,最好的时间复杂度是O(1),最差的时间复杂度是O(logN);

缺点：

​	设计一个较好的散列函数比较困难。而且散列表没有区间概念，只能用于等值比较，如果是区间查询，用不了hash表。

适用场景：

等值比较；



#### 有序数组

我按照升序排列成数组。

优点：

时间复杂度即是二分查找的时间复杂度(logN),而且支持区间查询，比如查询区间[x,y],我们找到第一个不小于x的值，和最后一个不大于y的值即可。

缺点：

新增和删除操作较多时，会涉及到数组的频繁移动，这个是数组的通用缺点了。

适用场景：

等值或者区间查询，而且数据变化不大。



#### 二叉搜索树

左子树都比根节点下，右子树都比根节点大。

二叉搜索树其实需要是平衡的，不然极端情况下会退化成链表，搜索的复杂度会退化成O(N)

所以这个二叉搜索树不太妥，应该是平衡二叉搜索树。

这个的搜索类似于二分查找，时间复杂度是O(logN),一般而言我们使用的是一种非严格平衡二叉搜索树，即红黑树，这个玩意除了复杂之外好像没啥缺点。

看起来红黑树是个贼好的选择，但是数据库的索引并没有使用，说是红黑树是二叉树的一种，存储数据量大的话，层数会非常多，会导致很多次的磁盘i/o,至于为什么是这样，网上的解释多是在解释磁盘i/o多了会有什么影响，或者说二叉树的每一层都在一个单独的数据块上，但是没给原因，我觉得这边需要理一下。

我们要解答的问题是**为什么mysql索引不使用红黑树**，最终选择的是B+树，这个还真不是我两个总得选一个，然后实现者喜欢B+树，所以最后是B+树，而是红黑树确实有不好的地方，让开发者不得不放弃了这个选择。



问题就变成了为什么红黑树不好，红黑树的查询，插入，删除，修改的性能表现都很稳定，业界也有比较成熟的实现方案；除了这些理论上的性能以外，索引是必须落盘的，红黑树每个节点最多只会有两子节点，如果数据量比较多的情况下，层数会比较多，层数多就一定会导致磁盘i/o增加吗？



接下来的问题就变成了要论证，层数多确实会导致磁盘i/o变多，如果要论证这个问题，首先要先了解红黑树在磁盘上是怎么存储的。

[Mysql为什么使用B+树](https://www.cnblogs.com/wangflower/p/12237762.html)一文中作者给出解释，因为cpu读取磁盘数据的时候是按照页来读的，二叉树的每个节点，都仅仅存储了当前节点的关键词信息，和自己两个子节点的信息，如果和自己的不匹配，那么cpu大概率会根据两个子节点的信息去接着寻址比较，如果是这样的话，那么二叉树有几层就需要几次磁盘i/o.

机械硬盘时代，从磁盘读一个数据块需要10ms左右的寻址时间，如果有100w条数据，可能需要log100w ~= 20次寻址，也就是20*10ms ~=0.2s 基本无法接受。

然后就是B树，也是2-3树，然后就是B+树，我看不懂，先不研究这个算法，等以后用到再说。



> 索引由存储引擎层实现，没有统一的索引标准。我们以最常用的InonoDB存储模型为例来看

### InnoDB的索引模型









