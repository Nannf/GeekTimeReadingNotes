#### 前言

1. 讨论是基于InnoDb引擎，RR事务隔离级别



原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。

原则 2：查找过程中访问到的对象才会加锁。

优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。

优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。

一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。



我们建表如下：

```mysql

CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

```mysql
begin;
select * from t where id>9 and id<12 order by id desc for update;
```

分析上面语句的加锁

会在10 上面加next-key锁，然后接着遍历，

（5.10],

(10,15].

哦吼，全部错了；

我们这个分析是不带order by 的分析，order by的时候，是会扫描到(5)这条记录的，所以给5也加上了next_key锁

(0,5],(5,10],(10,15].

这个next_key 锁啊，是以当前的索引记录为点，往前找比他小的第一个记录，并使用前开后闭区间。

但是我们实际操作的时候发现15这条记录没有加锁，

这个我猜测没有15的原因是因为加了order by.之所以这样说，是因为它要找到第一个大于等于12的行，这个>=就触发了等值查询，满足了优化2。



```mysql
begin;
select id from t where c in(5,20,10) lock in share mode;
```

in是等值查询的话，会锁住 5,10,20三行的行锁吗，这里我们注意，锁是加在c索引上的，还是共享锁。

我像个nt，这个c又不是唯一索引，为啥我就直接给退化了，弱智都不敢像我这样退化。

加锁的单位是n锁，先是5锁住了(0,5],然后是10（5，10],但是满足优化二，退化成间隙锁(5,10)/

然后是10，一样的(5,10],(10,15).然后是20，(15,20](20,25)



```mysql

select id from t where c in(5,20,10) order by c desc for update;
```

这个等值＋orderJ就离谱，我要怎么分析。



