#### 前言

1. 讨论是基于InnoDb引擎，RR事务隔离级别



原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。

原则 2：查找过程中访问到的对象才会加锁。

优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。

优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。

一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。



我们建表如下：

```mysql

CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

```mysql
begin;
select * from t where id>9 and id<12 order by id desc for update;
```

分析上面语句的加锁

会在10 上面加next-key锁，然后接着遍历，

（5.10],

(10,15].

哦吼，全部错了；

我们这个分析是不带order by 的分析，order by的时候，是会扫描到(5)这条记录的，所以给5也加上了next_key锁

(0,5],(5,10],(10,15].

这个next_key 锁啊，是以当前的索引记录为点，往前找比他小的第一个记录，并使用前开后闭区间。

但是我们实际操作的时候发现15这条记录没有加锁，

这个我猜测没有15的原因是因为加了order by.之所以这样说，是因为它要找到第一个大于等于12的行，这个>=就触发了等值查询，满足了优化2。



```mysql
begin;
select id from t where c in(5,20,10) lock in share mode;
```

in是等值查询的话，会锁住 5,10,20三行的行锁吗，这里我们注意，锁是加在c索引上的，还是共享锁。

我像个nt，这个c又不是唯一索引，为啥我就直接给退化了，弱智都不敢像我这样退化。

加锁的单位是n锁，先是5锁住了(0,5],然后是10（5，10],但是满足优化二，退化成间隙锁(5,10)/

然后是10，一样的(5,10],(10,15).然后是20，(15,20](20,25)



```mysql

select id from t where c in(5,20,10) order by c desc for update;
```

这个等值＋order就离谱，我要怎么分析。

order by 带来的影响是什么我要找到满足条件的那个记录，或者不满足条件的第一条记录。

这个先使用什么呢？

我想优化器会分辨出，5，10，20，这三个值中20 是最大的，所以，会先查找c=20的记录，找到了，加n锁（15，20]，然后遍历下一条，发现是25不满足，退化成间隙锁(20,25);

然后往左遍历，发现15不满足，但是仍然加了锁(10,15],然后10是满足的(5,10],然后(0,5],最后发现0不满足（-无穷,0].

(-无穷，25)，全部有锁。

事实证明不是负无穷。这个0没有锁，(0,5] 我插入（4，4，4）的时候锁住了，但是更新0的时候是成功的，插入(-1,-1,-1)也是成功的。



但是作者的意思是如果有两个连接同时执行这个语句有可能造成死锁。

因为我们知道间隙锁是可以共享的，但是行锁不可以。

数据库加锁的顺序 c in (5,20,10)和 order by c 是不相同的

一个是 5,10,20的加，一个是 20 10 5的加，而这两个是谁先执行呢？这个是随机的吗，如果不是随机的会怎么样

假设是where语句的先加，那么我先加完了5，然后另一个也开始加，这时候是不会死锁的，会进入锁等待，那只有两个加锁的顺序是随机的才会有死锁的情况发生。





