#### 前言

本文主要探究的问题是，在一主一备多从的场景下的读写分离带来的问题。

问题的原因主要是过期读，即读到的数据不是最新的。

发生的场景是因为只有主库才有写的权限，但是读不一定是从主库读，主库和从库之间的数据同步是有时差的，我们如果在这个时间差中读取了从库的数据，那么就会产生过期读。



#### 基础架构

##### 客户端做请求转发的架构

![img](https://static001.geekbang.org/resource/image/13/aa/1334b9c08b8fd837832fdb2d82e6b0aa.png)

- 客户端的连接信息维护在客户端
- 架构简单，出问题好排查
- 需要了解数据库的连接信息，如果数据库发生主备切换，客户端需要及时的感知，并调整相关的连接信息
- 这并不意味着业务代码需要感知这些，会单独分离一层出来管理连接信息，如ZooKeeper

##### 由专门的代理层来进行转发的架构

![img](https://static001.geekbang.org/resource/image/1b/45/1b1ea74a48e1a16409e9b4d02172b945.jpg)

- 我觉得这边的client客户端是真正意义上的业务代码，上一个的客户端相当于客户端+proxy
- 架构复杂
- proxy需要做高可用
- 是现在的发展趋势，但是还要量力而行



#### 解决过期读的几个方案

##### 强制走主库

过期读的问题就是读到了在主库上修改了，但是还没有同步给从库的这段时间而产生的问题。如果我们把一些时效性要求比较高的查询全部强制走主库查询，而别的请求可以放到从库去查询。

问题：金融类的服务，所有的查询都不能是过期读，强制走主库等于放弃了扩展性。



##### sleep方案

这个的思路是，我们查询之前，先执行一条sleep命令，比如 select sleep(1)这样的。这个的想法时，既然你从库同步主库有延迟，那么我就多给你一秒钟去完成这个过程，这你还同步不完成说不过去了把

充满了浪漫主义。

两个问题：

1. 如果从库仅用了0.1s，那么我们也会等待1s
2. 如果从库需要2s，我们还是会过期读。



##### 判断主备无延迟方案

既然问题出在主备延迟，那么我等主备无延迟之后在查询，岂不美哉。

这里的判断使用的时 `show slave status` 中的 seconds_behind_master参数。这个参数是s，精度可能不大够，除了这个参数外，我们还可以对比位点和GTID。

![img](https://static001.geekbang.org/resource/image/00/c1/00110923007513e865d7f43a124887c1.png)

上图是`show slave status`的结果

Master_Log_File和Read_Master_Log_Pos 表示备库读到了主库的最新位点

Relay_Master_Log_File和Exec_Master_Log_pos 表示备库执行的最新位点

如果这个能对上，表示主库和备库的状态是一致的，这个后面的隐含逻辑是，备库读到的主库的最新位点，一定要是主库真正的最新位点。