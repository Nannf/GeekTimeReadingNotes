#### 概览

本文先是通过一个比较明显的错误理解**自增主键是连续的**出发，说明了自增主键不一定连续，其中很关键的就是，原本分配给一个事务使用的主键id，因为一些原因，导致事务执行失败，没有使用上分配的主键id。导致了主键id不连续。

紧接着作者提出了，既然事务执行失败，我们可以把分配给他的主键id回滚，不就能保证连续了吗？

我们对连续的自增主键产生了偏执，在多线程情况下，完成这个连续的功能，我们需要做很多操作，收效甚微，所以mysql并非不能完成自增主键的连续性，只是维护自增主键的连续需要的代价太高，而不为。

接着作者描述了自增主键锁相关的场景，并分析了在主备情况下，binlog_format=statement的时候，自增主键锁的释放时机，及背后的逻辑思量。



为了方便下文叙述，我们建表如下：

```mysql
CREATE TABLE `t` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `c` (`c`)
) ENGINE=InnoDB;
```

自增主键id，唯一索引c。



#### 自增主键的实现机制

##### 自增主键的值保存在哪

我们执行insert into t values(null, 1, 1)语句之后，在查看我们的表结构，我们发现AUTO_INCREMENT=2，表示下一个自增主键值是2，难道自增主键值是保存在表结构文件中的？

![img](https://static001.geekbang.org/resource/image/cb/ff/cb2637cada0201b18650f56875e94fff.png)

但是我们查看表结构的.frm文件，发现其中是不保存自增主键值的。

###### MyISAM引擎

自增主键值保存在数据文件中，数据文件保存在内存中。



###### InnoDB引擎

1. 5.7版本及以前
   - 每次重启都到表里获取最大的自增主键，然后再这个基础上加1
2. 8.0版本及以后
   - 保存再redolog中，每次重启时可以查询到上一次记录的自增主键的位置。

