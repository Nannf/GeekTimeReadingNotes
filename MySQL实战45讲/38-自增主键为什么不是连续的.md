#### 概览

本文先是通过一个比较明显的错误理解**自增主键是连续的**出发，说明了自增主键不一定连续，其中很关键的就是，原本分配给一个事务使用的主键id，因为一些原因，导致事务执行失败，没有使用上分配的主键id。导致了主键id不连续。

紧接着作者提出了，既然事务执行失败，我们可以把分配给他的主键id回滚，不就能保证连续了吗？

我们对连续的自增主键产生了偏执，在多线程情况下，完成这个连续的功能，我们需要做很多操作，收效甚微，所以mysql并非不能完成自增主键的连续性，只是维护自增主键的连续需要的代价太高，而不为。

接着作者描述了自增主键锁相关的场景，并分析了在主备情况下，binlog_format=statement的时候，自增主键锁的释放时机，及背后的逻辑思量。



为了方便下文叙述，我们建表如下：

```mysql
CREATE TABLE `t` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `c` (`c`)
) ENGINE=InnoDB;
```

自增主键id，唯一索引c。



#### 自增主键的实现机制

##### 自增主键的值保存在哪

我们执行insert into t values(null, 1, 1)语句之后，在查看我们的表结构，我们发现AUTO_INCREMENT=2，表示下一个自增主键值是2，难道自增主键值是保存在表结构文件中的？

![img](https://static001.geekbang.org/resource/image/cb/ff/cb2637cada0201b18650f56875e94fff.png)

但是我们查看表结构的.frm文件，发现其中是不保存自增主键值的。

###### MyISAM引擎

自增主键值保存在数据文件中，数据文件保存在内存中。



###### InnoDB引擎

1. 5.7版本及以前
   - 每次重启都到表里获取最大的自增主键，然后再这个基础上加1
2. 8.0版本及以后
   - 保存再redolog中，每次重启时可以查询到上一次记录的自增主键的位置。



看完了自增主键的保存，我们再来看下自增主键的值什么时候会修改。



##### 自增主键的修改逻辑

1. 如果插入时，未指定自增主键列的值，比如是0，null，或者干脆没有，那么程序会根据不同的存储引擎，不同的版本选择下一个值作为自增主键的值，这个我们在上面已经做过介绍
2. 如果插入指定了值，那么就会使用这个指定的值，前文所述，我们是可以删除一些字段的，比如现在的自增主键的值是11，但是前面的3-8全被删除了，我们是可以插入成功的，但是插入成功不会去修改这个11。
3. 如果当前的自增主键值是11，但是我插入了一条20，那么我们会找到下一个值，这个值不一定是21，有个下一个值的步长，默认是1，但是可以通过auto_increment_increment指定，假设我的步长是3，那么下一个值就是23.
4. 关于为什么需要有步长一说，是因为如果我们是双M架构，即两个服务都可以写数据，为了保证两个服务写的数据主键不冲突，我们就使用步长为2，然后每个实例的起始步长不一样，一个是从1，一个是从2，这样的话，两个实例插入的数据，一个是奇数，一个是偶数。



##### 自增主键为什么不设计成回滚的

我们知道，自增主键的值，是在插入之前数据准备的时候，就已经生成了，如果这个插入失败了，这个自增主键的值也就消失了。

这个失败无论执行失败，还是事务回滚都是一样的，那么如果有可能，我们可以实现主键id的回滚吗？

我们来看这样一个场景：

1. 事务A和事务B都要插入数据到表t中，多线程访问共享变量**自增主键值**，要加锁，假设A先获取到锁，得到值为2，B为3；
2. 事务B先插入成功，此时的自增主键值是4；
3. 但是A插入失败了，假设我们允许回滚，那么自增主键值，应该回滚为2
4. 然后下一个事务来获取到之后，可以成功插入，但是下下个事务来就发现有主键冲突

为了解决主键冲突，我们有两种思路

1. 每次进行插入操作之前都到表里去判断有没有这个主键，要到主键索引树上去查找
2. 把自增主键获取的时候的锁粒度变大，只有一个事务执行成功，即确切的保证整个事务id已经使用，我们才能接着申请，这会导致并发性能急剧下降。

出于性能考虑，自增主键只保证递增不保证连续。





##### 自增锁

上文我们知道，在事务需要获取自增主键的时候，出于线程安全考虑，我们需要加锁，这个锁就是自增主键锁，下文我们简称为自增锁。

###### 自增锁是事务锁吗

不是，我们刚刚的叙述看到，一个事务A只有再申请的时候，才获取锁，获取完了之后就释放了，不会等到事务运行结束才会释放锁。



###### 自增锁的历史

1. 5.1版本之前
   - 这个版本之前是语句锁，即事务锁，就是我们上面叙述的，当语句执行完成的时候才会释放
   - 非常影响并发。
2. 5.1.22版本之后
   - 新增了配置innodb_autoinc_lock_mode
     - 当为0时，跟5.1版本之前的表现一致，都是事务锁
     - 当为1时，普通的insert语句是获取完成之后直接释放，如果是 insert .. select 批量插入的还是事务锁
     - 当为2时，所有的语句都是申请完直接释放



有一个需要单独拿出来说一下，就是 insert ... select 语句，为什么是事务锁，而不是获取之后立马就返回，第一反应是，我又不知道select实际会查询出来多少，所以我并不清楚需要申请多少个。

但是倘若你申请100w个，岂不是要等你全部执行完，别的插入才能做？这个对并发的影响似乎太大了，所以我感觉这个不会实际再生产环境使用。

但是如何解决我们刚刚说的不清楚申请多少个id的问题呢？

我们需要插入的时候，在申请，第一次申请的时候给1个，第二次给2个，第三次给4个，每次是上一个的2倍。这样在最后一次申请的时候，可能出现主键id不连续的情况。

还有一个问题需要解决，就是如果我是为2的话，我们的binlog_format不能设置成statement，因为statement不会记录实际插入的值，所以我们在主库上执行的时候，如果有别的事务也在插入，导致我的这个事务不在连续，这样我在备库使用binlog还原的时候，我们就会出现主备不一致的场景。

![img](https://static001.geekbang.org/resource/image/e0/df/e0a69e151277de54a8262657e4ec89df.png)





综上，当我们不知道一次需要插入多少数据时，可以有两种解决思路

1. 直接使用事务锁
2. 每次申请的不够时，再次申请，但是需要binlog_format=row来配合。







