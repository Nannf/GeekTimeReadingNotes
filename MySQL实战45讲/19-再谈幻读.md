#### 前言

之前再说到事务隔离性的时候，就说到了幻读，当时说幻读是说我第一次查询的时候查询到一个集合M，在这个事务中，过了一会我又查询一次，查询出来的集合N，N中出现了M中没有的记录，此为幻读，当时我就在想，不能说你查的时候不让别人改吧，查询的不一样不是很正常吗，这哪能算问题呢？隐约记得当时百度的时候，提到了会使行锁失效啥的，这个我们就在这章的学习中一探究竟。



#### 概览

通读一遍文章之后，发现幻读确实有问题，问题就出在使用binlog恢复数据的时候，会和实际的不一致。而且只有可重复读隔离级别下才有的问题，而且幻读是只针对插入的新数据，并不包括修改的数据，基于此引入了间隙锁的概念，本文的行文思路如下：

1. 我首先要先明确什么叫幻读，为什么只有在可重复读的情况下有幻读的现象.
2. 幻读导致的问题，幻读一定的有问题的吗，这个确定是有的，我们会用一个具体的案例来分析出幻读的问题
3. 我们基于上面分析的问题，一步步给出解决方案，最终引出间隙锁
4. 间隙锁会导致并发度的降低，我们要分析下是否可以换一个事务隔离级别或者其他方式来解决幻读的问题



好的，让我们开始吧。

在叙述之前，为了方便我们后面的展开，我们需要基于一个特定的表来展开

```mysql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```



#### 幻读

##### 幻读的概念

![img](https://static001.geekbang.org/resource/image/5b/8b/5bc506e5884d21844126d26bbe6fa68b.png)

我们知道select ... for update是当前读，SessionB和SessionC是修改完之后就立马提交了，所以对SessionA而言，Q2和Q3都是可以看到的。

对会话A而言，在Q3的时候，查询到了T1时刻没有的(0,0,5)、(1,1,5)这两条数据，但是只有查到(1,1,5)这条记录的时候，才叫做幻读，这与我之前的认知不同，至于为什么新插入的才算幻读，简单的说是因为新插入的记录我行锁锁不到它。

我在前文中的叙述不太妥当，其实在可重复读的隔离级别下，是不会有幻读的，因为我事务A都看不到事务B和C对表的改动，只有**当前读**的时候才会有这个问题。



##### 幻读的问题

###### 行锁语义的失效

![img](https://static001.geekbang.org/resource/image/7a/07/7a9ffa90ac3cc78db6a51ff9b9075607.png)

**我们的叙述都先假设行锁只会锁住命中的那一行数据。**

在T1时刻，我们什么了所有d=5的行都会被我锁住，在这个时候，表里的(5,5,5)记录被锁住。其他的行都没有锁。

在T2时刻，我们把(0,0,0) --> （0,0,5），然后再把(0,0,5)->(0,5,5);这就与T1时刻申明的锁住d=5的所有行的行锁语义冲突。

同理T4时刻的时候，事务C的操作也违反了T1时刻事务A申明的行锁语义。



但是我觉得仅仅是语义的破坏的话并不会造成什么样的影响。



###### 数据一致性的问题。

![img](https://static001.geekbang.org/resource/image/dc/92/dcea7845ff0bdbee2622bf3c67d31d92.png)

假设我们执行的语句时序是这样的

最后执行完成之后，数据库中的状态是

(5,5,100),(0,5,5),(1,5,5);

但是事务A是在T6时刻才提交，如果我们的binlog使用的是statement存储的话会记录下如下的sql语句

```mysql
-- session B
update t set d = 5 where id = 0;
update t set c = 5 where id = 0;

-- session C
insert into t values(1,1,5);
update t set c = 5 where id = 1;

-- session A
update t set d = 100 where d = 5;
```

如果我们使用这个binlog来恢复的话，我们最终会得到如下的记录

(5,5,100),(0,5,100),(1,5,100);

这就是问题所在，如果我们让行锁只锁命中的那一行，就会有这个问题。当然如果binlog记录的是row就不会有这个问题。

这个问题出现的原因是因为我们之前的假设 ：**select * from t where d = 5 for update**,我们假设这种只锁了一行，是错误的。

我们假设扫描过程中碰到的行全部需要加锁。

我们按照这个新的假设再来看上述的执行序列。

我们发现sessionB会在执行第一条语句的时候就被阻塞，而session C和之前的并无二致。

因为我们并不可能对一个之前并不存在的记录加行锁。

这也是为什么幻读定义为新增记录的原因，也是幻读被单独拿出来说的原因。



###### 间隙锁

行锁的粒度虽然已经比较小了，但是没办法锁住新插入的行，在我们上文叙述的场景下，是会出现这种新插入的行导致的数据不一致的情况，为了解决这个问题，我们引入了间隙锁的概念。

间隙锁是什么跟什么之间的间隙，锁总要有个需要被锁住的实体，在间隙锁中，这个实体是什么呢？

1. 间隙锁只在RR事务隔离级别下有用
2. 是在RR级别下因为行锁解决不了数据一致性而引入的一种解决方案。
3. 说是锁住索引记录之间的间隔
   - 我们知道，扫描的时候是把所有扫描之后的数据都加上行锁，最极端的情况下是全表扫描，那就是全表都加上数据，此时为了防止出现之前说的



