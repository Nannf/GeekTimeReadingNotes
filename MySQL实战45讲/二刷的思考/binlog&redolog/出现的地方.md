#### 前言

本文的目的是为了梳理在整个mysql专栏中，binlog和redolog的出现章节，已经出现的目的。

如果可能的话，我会叙述背景。

当然每一种事物的存在都是一种解决方案，方案有其局限性，我们可以尝试站在当时开发者的角度去想一想，倘若我跟他易地而处，我会如何抉择。当然我的抉择一开始总是毫无头绪，因为我对要解决的问题不是那么的清晰，现状就是这样，我还是要去思考思考。



#### 出现地方集锦

##### 02-日志系统，一条更新语句是如何执行的

这是二位的初登场。二位都是日志，我们对比来看下。

- 出现先后顺序： binlog早于redolog，binlog是server层带的，redolog是Innodb存储引擎才有的，最开始时，mysql使用的时MyISAM引擎，后来因为这个引擎不能crash-safe（不能的原因是因为它的存储介质是内存，内存断电之后记录的内容就会消失），而redolog可以的原因是因为它是存储在磁盘上的，只要我返回给客户端是i写入成功，那么就一定还在磁盘上。）而逐渐被替代
- 写入速度：redolog是快于binlog的，原因在于redolog是顺序io，是再一块连续的磁盘空间是进行读写（可以理解为数组）这个也跟MySQL的另一个属性**WAL**有关，WAL = Write-Ahead Logging 就是说的redolog，先写日志，后写磁盘，准确的说二者都是写磁盘，但是顺序IO的速度明显优于随机IO，这个顺序IO我们在kafka上也会看到，这个我们不难猜测，单反涉及到磁盘读写的一个常见的优化手段就是顺序io。
- 空间大小：redolog是有限制的，由mysql服务时的启动参数所限定，是固定的，当空间使用完之后，会清除之前使用的空间（清除的方式是把那部分数据写到对应的数据页上），然后重新使用；binlog是可以追加写的，保留的时间根据存储内容的不同会有所不同。
- 存储内容：redolog是物理页上的修改，binlog是逻辑上的修改。具体而言，就是innodb引擎会把自己管理的磁盘变为一个个数据页，redolog的修改是针对数据页的，比如我在哪个数据页的哪个位置做了哪个修改，这就意味着，redolog迁移是没有任何意义的，这个是跟特定的mysql实例绑定的；而binlog存储的是逻辑，就说我把表t的字段ID=2的修改时间全部改为当前时间（后面我们知道binlog是由statement、row、mixed三种类型，但无论是哪种，都是一种逻辑上的）。



对比完二者的不同之后，一个问题就迎面而来，redolog的存在的原因，一是可以提高速度，但是之前是写内存的，速度应该比顺序io快的多，更主要的是crash-safe的能力，这个问题就是，什么是crash-safe，为什么binlog无法保证crash-safe，redolog是如何保证的。

这个我们后续再看，第一次我们不做这个大而全的梳理。

我们只有知道，crash-safe是mysql对外提供的两个保证：

- 如果客户端收到了事务提交成功的回复，那么就算服务器宕机也是可以保证事务成功写入的
- 如果客户端没有收到事务提交成功的回复，那么服务器宕机之后有可能回滚，也有可能成功写入，但是不会处于一个不一致的中间状态。

还有就是crash-safe是redolog和undolog以及binlog三个之间的配合共同完成的，作者在整篇文章中只字不提undolog，不知道为啥。

单是redolog和binlog都是无法完成crash-safe的。

我们来说说说二者之间的配合

![img](https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

- 因为我们要更新ID=2这一行，但是我们不知道ID这一行在不在内存中，所以执行器调用存储引擎的接口，获取ID=2这一行，因为ID是主键，直接使用主键索引树，找到ID=2所在的数据页，然后判断这个数据页在不在内存中，如果在就告诉执行器这一行已经在内存中了，如果不在就把这一行所在的数据页加载进内存中，然后通知执行器
- 执行器执行逻辑，把这一条记录的C+1，然后调用存储引擎的接口，告知这个改动
- 存储引擎先把这个改动写入内存中，这个更新是指更新内存中这个数据页的内容，这个时候这个数据页就已经是脏页了，然后写redolog，记录下我在哪个数据页的哪个位置做了什么改动，此时redolog处于prepare阶段，如果此时服务器断电，这个内存中的脏页没有刷新到磁盘上，因为binlog中没有记录，这个记录会被回滚
- 然后写binlog，如果是statement格式的binlog，就记录下操作的sql，如果是row格式的，就记录下修改前后的记录详情，如果binlog写完了，服务器断电了，因为redolog处于prepare状态，binlog也有了，此时就默认事务已经成功了，最后的一步告知动作其实无所谓了
- 最后提交事务，告知客户端我成功了，redolog的状态改为commit。



###### binlog相关的数据恢复

- binlog会记录所有修改数据库的语句，所以如果我们一条条重放binlog的内容的话，我们是可以拷贝一张表甚至一个库的，这就是备库和从库的执行逻辑。
- 如果我们误删了表或者进行了什么误操作，我们可以找到上一次的全量备份，然后恢复到那个状态之后，一条条的重放自那个全量备份之后的所有的binlog记录，直到我们误操作之前的那个时候。

数据恢复的挑战：

- binlog格式最好为row，这个主要是主备导致的数据不一致问题，具体的例子就是当我们delete ... limit 1的时候，会因为主备选择索引的不一致而导致的主备不一致问题。当然记录成row是方便恢复数据方便：
  - delete 如果是statement格式的我们除了记录一条delete语句什么都不会记录，但是如果我们记录了row，会把删除的语句全部记录下来，直接insert就好了
  - insert 这个两个之间的差别不大，直接删插入的就好了
  - update 这个类比delete
- row的问题就是这个玩意因为要记录所有的记录，比如我们删除一张不用的大表，我们会记录这个大表的所有记录
- 还有就是有的人列举的，insert时候主库使用一些函数（时间或者日期函数）或者自增主键，这个其实在binlog中都会把这些与当时执行环境相关的变量作为一个常量写在binlog中，这个不会导致主备不一致问题
- 不要手动的打开binlog去执行sql，使用工具会好些，因为binlog的格式和参数比我们想的复杂，自己做容易出错。
- 实际上我们上述理论能正确执行的前提是，我们发现的及时，没有业务基于我们的误操作之后的数据进行进一步的修改，这个才是最难的部分。

