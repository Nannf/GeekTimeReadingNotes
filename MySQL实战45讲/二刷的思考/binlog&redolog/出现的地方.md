#### 前言

本文的目的是为了梳理在整个mysql专栏中，binlog和redolog的出现章节，已经出现的目的。

如果可能的话，我会叙述背景。

当然每一种事物的存在都是一种解决方案，方案有其局限性，我们可以尝试站在当时开发者的角度去想一想，倘若我跟他易地而处，我会如何抉择。当然我的抉择一开始总是毫无头绪，因为我对要解决的问题不是那么的清晰，现状就是这样，我还是要去思考思考。



#### 出现地方集锦

##### 02-日志系统，一条更新语句是如何执行的

这是二位的初登场。二位都是日志，我们对比来看下。

- 出现先后顺序： binlog早于redolog，binlog是server层带的，redolog是Innodb存储引擎才有的，最开始时，mysql使用的时MyISAM引擎，后来因为这个引擎不能crash-safe（不能的原因是因为它的存储介质是内存，内存断电之后记录的内容就会消失），而redolog可以的原因是因为它是存储在磁盘上的，只要我返回给客户端是i写入成功，那么就一定还在磁盘上。）而逐渐被替代
- 写入速度：redolog是快于binlog的，原因在于redolog是顺序io，是再一块连续的磁盘空间是进行读写（可以理解为数组）这个也跟MySQL的另一个属性**WAL**有关，WAL = Write-Ahead Logging 就是说的redolog，先写日志，后写磁盘，准确的说二者都是写磁盘，但是顺序IO的速度明显优于随机IO，这个顺序IO我们在kafka上也会看到，这个我们不难猜测，单反涉及到磁盘读写的一个常见的优化手段就是顺序io。
- 空间大小：redolog是有限制的，由mysql服务时的启动参数所限定，是固定的，当空间使用完之后，会清除之前使用的空间（清除的方式是把那部分数据写到对应的数据页上），然后重新使用；binlog是可以追加写的，保留的时间根据存储内容的不同会有所不同。
- 存储内容：redolog是物理页上的修改，binlog是逻辑上的修改。具体而言，就是innodb引擎会把自己管理的磁盘变为一个个数据页，redolog的修改是针对数据页的，比如我在哪个数据页的哪个位置做了哪个修改，这就意味着，redolog迁移是没有任何意义的，这个是跟特定的mysql实例绑定的；而binlog存储的是逻辑，就说我把表t的字段ID=2的修改时间全部改为当前时间（后面我们知道binlog是由statement、row、mixed三种类型，但无论是哪种，都是一种逻辑上的）。



对比完二者的不同之后，一个问题就迎面而来，redolog的存在的原因，一是可以提高速度，但是之前是写内存的，速度应该比顺序io快的多，更主要的是crash-safe的能力，这个问题就是，什么是crash-safe，为什么binlog无法保证crash-safe，redolog是如何保证的。

binlog无法保证crash-safe是因为这个binlog的记录是可以被关闭的，当时在设计的时候就没打算让binlog做这个事情；

这个我们后续再看，第一次我们不做这个大而全的梳理。

我们只有知道，crash-safe是mysql对外提供的两个保证：

- 如果客户端收到了事务提交成功的回复，那么就算服务器宕机也是可以保证事务成功写入的
- 如果客户端没有收到事务提交成功的回复，那么服务器宕机之后有可能回滚，也有可能成功写入，但是不会处于一个不一致的中间状态。

还有就是crash-safe是redolog和undolog以及binlog三个之间的配合共同完成的，作者在整篇文章中只字不提undolog，不知道为啥。

单是redolog和binlog都是无法完成crash-safe的。

我们来说说说二者之间的配合

![img](https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

- 因为我们要更新ID=2这一行，但是我们不知道ID这一行在不在内存中，所以执行器调用存储引擎的接口，获取ID=2这一行，因为ID是主键，直接使用主键索引树，找到ID=2所在的数据页，然后判断这个数据页在不在内存中，如果在就告诉执行器这一行已经在内存中了，如果不在就把这一行所在的数据页加载进内存中，然后通知执行器
- 执行器执行逻辑，把这一条记录的C+1，然后调用存储引擎的接口，告知这个改动
- 存储引擎先把这个改动写入内存中，这个更新是指更新内存中这个数据页的内容，这个时候这个数据页就已经是脏页了，然后写redolog，记录下我在哪个数据页的哪个位置做了什么改动，此时redolog处于prepare阶段，如果此时服务器断电，这个内存中的脏页没有刷新到磁盘上，因为binlog中没有记录，这个记录会被回滚
- 然后写binlog，如果是statement格式的binlog，就记录下操作的sql，如果是row格式的，就记录下修改前后的记录详情，如果binlog写完了，服务器断电了，因为redolog处于prepare状态，binlog也有了，此时就默认事务已经成功了，最后的一步告知动作其实无所谓了
- 最后提交事务，告知客户端我成功了，redolog的状态改为commit。



###### binlog相关的数据恢复

- binlog会记录所有修改数据库的语句，所以如果我们一条条重放binlog的内容的话，我们是可以拷贝一张表甚至一个库的，这就是备库和从库的执行逻辑。
- 如果我们误删了表或者进行了什么误操作，我们可以找到上一次的全量备份，然后恢复到那个状态之后，一条条的重放自那个全量备份之后的所有的binlog记录，直到我们误操作之前的那个时候。

数据恢复的挑战：

- binlog格式最好为row，这个主要是主备导致的数据不一致问题，具体的例子就是当我们delete ... limit 1的时候，会因为主备选择索引的不一致而导致的主备不一致问题。当然记录成row是方便恢复数据方便：
  - delete 如果是statement格式的我们除了记录一条delete语句什么都不会记录，但是如果我们记录了row，会把删除的语句全部记录下来，直接insert就好了
  - insert 这个两个之间的差别不大，直接删插入的就好了
  - update 这个类比delete
- row的问题就是这个玩意因为要记录所有的记录，比如我们删除一张不用的大表，我们会记录这个大表的所有记录
- 还有就是有的人列举的，insert时候主库使用一些函数（时间或者日期函数）或者自增主键，这个其实在binlog中都会把这些与当时执行环境相关的变量作为一个常量写在binlog中，这个不会导致主备不一致问题
- 不要手动的打开binlog去执行sql，使用工具会好些，因为binlog的格式和参数比我们想的复杂，自己做容易出错。
- 实际上我们上述理论能正确执行的前提是，我们发现的及时，没有业务基于我们的误操作之后的数据进行进一步的修改，这个才是最难的部分。



##### 09-普通索引和唯一索引，应该如何选择

###### redolog & changebuffer

- 这两个机制都是对性能的一种优化，都是做磁盘写入操作的时候的一个优化，redolog的优化逻辑是采用顺序io，changebuffer的逻辑是先写内存，在不忙或者后续使用时才完成具体的写入操作（如果读多写多，这个就是负优化）
- changebuffer的运行机制是，如果我们要修改的数据不在内存中，我们可以把关于数据页的修改先缓存在内存中，等不忙的时候或者读取这条记录的时候我们再完成merge操作。
- redolog的运行机制是，一个操作关于哪个数据页（如果操作的数据页在内存中，会直接记录具体在某个数据页上进行了什么修改，如果操作的数据页不在内存中，会记录对应的changebuffer）的修改。
- 所以changebuffer是一种数据页不在redolog的特殊记录，正如下图的三所示。

![img](https://static001.geekbang.org/resource/image/98/a3/980a2b786f0ea7adabef2e64fb4c4ca3.png)



###### 加入changebuffer的更新流程

- server判断要操作的数据页在不在内存中，对已经在内存中的数据页直接更新，并记录redolog，对不在内存中的数据页，插入一条更新记录到changebuffer中，也写到redolog中，此时redolog处于prepare状态。
- 然后写binlog
- 最后redolog处于commit状态



###### 加入changebuffer的读取流程

- 如果要读取的数据已经在内存中，直接返回，此时的磁盘上可能不是最新的数据（更新的时候，这个数据页就已经在内存中）
- 如果不在的话，会从磁盘上加载数据页到内存中，到内存中之后，会和changebuffer的操作进行合并（其实这边的逻辑语焉不详，因为不是所有的磁盘都需要合并，其中有个判断逻辑，这个我们在下面给出了猜测），然后合并后的结果返回给

![img](https://static001.geekbang.org/resource/image/6d/8e/6dc743577af1dbcbb8550bddbfc5f98e.png)

##### 12-为什么我的MySQL会抖一下

我们在上面一节可以看出来，磁盘上的数据页不总是最新的；内存中的数据页总是最新的。

如果内存中数据页和磁盘上的数据页不一致的时候，我们称内存中的数据页为脏页。

当内存中的数据页刷新到磁盘上的时候，这个时候内存中的数据页被成为干净页。

"抖一下"的具体表现就是，数据库的执行时间会突然变慢。比如插入一条数据，或者更新一条数据。之前都是很快的，因为如果要更新的数据页在内存中，就只需修改内存，和redolog，如果不在，就写changebuffer，再把changebuffer的值写到redolog中，然后就返回，这些操作都不会涉及比较慢的磁盘io操作，但是redolog的空间是有限的，当达到一定阈值的时候，会触发刷脏页的动作(flush).

**抖一下的原因可能是mysql服务器在刷脏页**

###### 哪些场景会触发刷脏页

1. redolog写满了
   - redolog是有大小限制的
   - redolog记录了数据页的修改
2. 内存不足了
   - 内存有大小限制
   - 内存中也会记录脏页（这个脏的过程是这个页在修改的时候就在内存中，如果不在内存中，这个只会记录redolog和changebuffer）。
   - 内存页和数据页是一个东西吗？内存不一定全部存放的是数据，还有各种各样的缓存。我们可以简单的假设，当内存不足时，首先淘汰的是数据页，如果这个数据页是脏页，那么就触发flush操作
   - 但是我们知道redolog中也记录了这个记录，当这个页被加载的时候，会和redolog再进行一次合并吗？这边我想一定有一个逻辑，每一次的修改都是一个事务id，当我们把一个数据页加载到内存中判断需不需要和redolog合并肯定比较的是这个类事务id的东西，具体的应该要去看源码了。我们可以暂时这么假设。
3. mysql空闲的时候
   - 释放内存和redolog，其实内存中的脏页刷进磁盘后，redolog中的空间也可以释放了，不知道mysql有没有做这种操作
4. mysql正常关闭的时候



###### 所有的场景都对性能造成影响吗

其实只有一和二会有影响。我们来想两个场景对应的后果：

1. redolog写满导致的问题
   - 这个会让所有的修改操作全部暂停
2. 内存写满
   - 这种其实是正常情况，因为一个运行了一段时间的mysql实例，肯定会不停的从内存中加载数据页
   - 当一个查询需要淘汰很多的数据页的时候，就会导致性能问题，如果这个查询返回的表是一个特别冷门的表，会导致灾难性的后果，这里其实在后文我们知道，mysql做了优化，对内存进行了分代



当我回顾的时候，我发现，为什么redolog满了也会触发刷脏页，redolog记录的是什么，物理页上的修改，这个如果修改的物理页在内存中，记录的就是内存上的修改，如果不是，就是记录的changebuffer。

我们知道刷脏页其实是把磁盘落后的记录刷新的和内存一致。修改的其实不是内存，而是磁盘，当磁盘修改了之后，磁盘和内存就一致了，此时内存中的数据页就叫干净页了。

我们还知道，当内存中的数据页被淘汰的时候，如何进行flush呢？就是如何修正磁盘的数据页呢？redolog就是记录了这种修改，所以我猜测当内存页被淘汰的时候，使用的是redolog对磁盘页进行更新。

但是这又触发了一个新的问题，如果我们所有的更新都依赖于redolog的话，那么我们的页被刷新后，这部分redolog就没啥用了，那如何删除呢？



##### 15-答疑文章（一）日志和索引相关问题

先从最简单的故障恢复说起

![img](https://static001.geekbang.org/resource/image/ee/2a/ee9af616e05e4b853eba27048351f62a.jpg)



如果断点是在时刻A之前，那么肯定失败；

如果是在时刻A失败，重启时根据prepare找不到对应的binlog，回滚；

如果时刻B失败，重启时找到prepare状态的redolog，根据xid找到binlog，如果找得到就成功，找不到就回滚；

如果时刻B之后失败，不存在。

**其实数据一致性指的是备库使用binlog恢复的状态要和主库保持一致；**

如果从这个角度来分析问题，我们的目光就转向了另一个问题，就是如何确定binlog的完整性呢？

- statement格式的binlog最后会有一个COMMIT;
- row格式的binlog最后会有一个XID EVENT；
- 5.6.3 版本之后还有校验和

所以我们上面的关于时刻B的叙述应该修改为，如果时刻B失败，如果binlog是完整的，就执行，如果不是就不执行。

这也解释了为什么redolog之后为什么要加上binlog；

但是我们知道binlog是可以被取消的，如果不开启记录binlog，单独一个redolog是可以对客户端保证的；

但是考虑到binlog用来归档和主备，以及提供给别的三方程序做分析，所以binlog永远不会处于关闭状态；



我们分析到在不考虑binlog的场景下，redolog自己也可以完成对客户端的保证，为什么要带上binlog呢？

因为如果只有redolog的话，那么redolog写完之后，事务就已经提交了，此时没办法进行回滚，因为如果回滚的话会覆盖别的事务的修改；

但是如果binlog写入失败，会导致主备不一致；



再谈binlog的crash-safe能力；

binlog无法知道数据有没有真正的写到磁盘上，他只记录了一个逻辑上的概念，而不知道具体的数据页上的改动；这个是设计之初的考量，如果硬要说这个binlog可以恢复数据页，那就硬造了一个redolog出来，何必呢？

单独的redolog具备crash-safe能力，因为它记录了数据页的修改；





###### redolog存储的到底是什么

这个问题上文已经给出了解答，其实存储的是数据页中的修改；如果是正常运行的实例，如果对一个数据页进行修改，如果这个数据页在内存中，会直接修改，后面等待刷盘，把脏页刷掉，如果不在内存中会写入到change_buffer中，当然redolog中会记录change_buffer的修改。但是这个和redolog是没有什么关系的；

只有异常宕机的时候，程序检测到某个数据页是脏的，需要加载进内存中和redolog进行合并；

如果我们可以这样理解的话，其实我们可以发现，正常情况下，redolog的存在的意义就是异常时才有用；



如果我们按照这个思路理解下去，redolog存在的目的是为了快，数据页的修改



redolog_buffer 也是一块内存，主要是解决在一个事务的执行过程中，会有多条语句，只有事务commit的时候，才会写入redolog文件
