#### 前言

一般而言，我们使用的字符串里都是常用字符，是可以转换成ascii码排序的，我们在讨论时，可以先假定，字符串的排序和数字并无二致。

说是没有区别其实还是有的，因为字符串一般而言都是比较长的，比较占用空间，这也是本文出现的一个原因，当我们发现字符串很长的时候，我们仍然需要对它建立索引，因为不建立索引意味着全表扫描，会比较慢。

建议索引的空间占用又比较大。

这是一个矛盾，本文的目的就意在占用空间和查询时间之间找到一个平衡点。

一个显而易见的解决方案就是值截取字符串的一定长度作为索引，即**前缀索引**。

#### 前缀索引

> 以邮箱为例：1922757777@qq.com 1922756666@qq.com 
>
> 我们可以截取前6位作为索引 。

相对于全部字符串的索引而言，**前缀索引占的存储更小**。

但是，这让索引的区分度降低了，就上面两个例子发现索引树上的一样的数据比较多。

拿具体的查询而言，当索引树上有这种数据存在的时候，本来如果我们使用全字段索引的话，只需一次回表，加两次判断，扫描的行数是1.

但是如果是前缀索引，它会扫描2次磁盘，读取数据然后做判断。

这里引出了前缀索引的第一个缺点：

> 使用前缀索引时，如果前缀索引的长度选择不合适，那么会导致索引树上的重复数据较多，区分度降低，会增加扫描的行数，增加查询的时间。



记得我们之前说的覆盖索引，当查询需要返回的结果都在一个索引树上时，无需回表，就叫覆盖索引。

那么显然，前缀索引自动放弃了这种优化。

这里引出了前缀索引的第二个缺点：

> 前缀索引无法使用覆盖索引，必须回表。



**所以使用前缀索引的一个关键点就在于，我们要找到具有足够区分度的前缀索引长度，这样既节省了空间，又优化了查询速度。**

**索引选取的越长->相同数据页放下的索引数量越少->搜索的效率越低**



当然有些数据由于数据本身的规则导致，要想做到足够的区分度，必须要截取很长的字段，比如身份证号。我维护了一个市的户籍信息，如果在身份证上建立前缀索引，那为了使区分度足够，我们会截取很长的位数，这与使用全部字段当索引已经五五开了。



基于此，我们又提出了几种解决方法：

#### 倒序存储

> 适用于类似身份证这种，前面的数据一致性较高，但是后面的数据重复率较低的情况，这种倒序存储+前缀索引可以解决。

查询的时候，把查询的条件身份证号给倒转过来即可。

我们来分析下这种情况的不足：

1. 适用性不是很强，但是一旦遇到可以作为一个思路
2. 无法做范围查询，比如我想查找南京市，出生时间在某段时间内的所有人员，这种的倒序存储索引上都不会存这个信息。
3. 查询时会多调用一次翻转字符串的函数。



#### 增加hash字段

这个的处理方式和java中比较两个对象是否相同，先比较两个对象的hash码是否相同，如果不同，两个对象一定不同，但是两个相同，但是不能保证两个一定相同，还需调用equal来判断，因为不同对象hash码相同的概率很低，类似于均摊时间复杂度，我们可以默认时间复杂度是O(1).

