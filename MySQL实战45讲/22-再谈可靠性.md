#### 前言

本文的主体部分都在介绍binlog和redolog的落盘逻辑。

冲突的双方是速度和可靠性。

可靠性的讨论，我们先假设只要落到磁盘上，就可以保证数据一定不会丢失，当然磁盘也有坏道这些故障，在磁盘上也有raid算法来保证磁盘上数据的可靠性，这个不在本文的考虑范围内。

既然为了可靠性，数据一定要落盘，而落盘是因为随机写磁盘总是很慢的。

文件系统为了解决这个问题，新增了一个缓存，就是一个内存，不是cpu级别的缓存。

程序写内存是很快的。

在这个思路下，我们先试举两种极端情况。

1. 只考虑性能

   - 所有的操作，只在内存上，等系统空闲下来之后，在刷盘。

   问题

   - 内存的容量可能不够
   - 无法应对系统重启和服务重启

2. 只考虑可靠性

   - 每个操作都必须落盘

   问题

   - 随机操作磁盘非常慢。

本文的所有讨论就是在解决性能和可靠性之间的冲突，试图在两者之间找到一个平衡点满足我们的需求。



#### binlog的写入逻辑

写入，指的是写入到磁盘中。binlog不是顺序存储，是随机存储的，写入磁盘就意味着随机i/o，就意味着我们不能每条binlog语句都直接落盘。

不能直接落盘，又不像redolog那样有一块连续的空间来存储，我们只有考虑内存了，这个内存块名为**binlog Cache**。当我们遇到内存来作为临时存储的时候，我们总是要考虑到内存空间的有限性，当我们要存储的内容超过一定阈值的时候，我们不可避免的要借助磁盘。

一个事务binlog是不能被拆开的，无论多大，必须一次性写入。如果容许多阶段写入的话，那我们什么时候返回binlog写入成功呢？这是一个问题，接着就是根据binlog的语义我们还原时，我们要怎么去执行呢？难道我先执行事务A的一部分语句，然后执行事务B的一部分语句，如果是这样的话，事务之间的语句难免会相互影响，而导致数据的不一致（所有的数据不一致，都是语句实际执行的表的数据和使用binlog语句恢复数据库的数据不一致）。而你此时说，我们可以遍历所有的binlog，把一个事务的所有语句都找全了再执行，这跟一次性写入的效果不是一样的吗，你这并没有什么优化，而且还带来了很多额外的问题。

![img](https://static001.geekbang.org/resource/image/9e/3e/9ed86644d5f39efb0efec595abb92e3e.png)