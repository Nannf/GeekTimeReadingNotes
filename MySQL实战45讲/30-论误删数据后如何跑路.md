#### 删数据的种类

1. delete 删了表中的几行数据
2. drop/truncate table 删了某张表
3. drop database 删了某个库
4. 使用rm命令删了数据库实例



#### 高可用架构对误删数据有用吗

**没用**，相反高可用会执行主库的语句而把所有实例上的状态都变得和主库一致。



#### 误删行之后的跑路方法

##### 前提

binlog_format=row;

binlog_row_image=full;(这个不知道是不是我遗漏了没看到这个东西)



##### 修复步骤

这个我们在高可用一节说过，因为当binlog_format=row的时候，会记录出修改的具体的行。我们做相反的操作即可

- 如果是插入操作，我们改为删除
- 如果是删除操作，我们改为插入
- 如果是更新操作，我们调换更新前后的值
- 如果是多个操作结合，那么恢复顺序和执行顺序相反
  - delete insert update
  - update insert delete

###### 问题

1. 因为误删数据之后，业务可能在你删除数据的基础上做了一些判断，而让你的业务数据朝着不可预料的方向发展，这就引入了第二条建议
2. 不建议在主库直接恢复，至于原因是因为主库已经在误删数据的基础上进行了一些业务判断，如果你在主库上恢复，相当于二次污染了数据，让数据变得不可控
3. 即使是binlog_format=row 也无法解决trancate和drop语句的删除



##### 一些建议

我们从上面的误删操作存在的问题可以发现，一旦数据被误删，使得数据库处于一个不合法的状态，而这个状态又会引起程序的业务逻辑，从而影响后续程序对数据库数据的修改，一旦我们发现误删的时间过长，会导致整个数据回复到正常情况的难度加大。

我们需要一些防范于未然的手段

1. 所有上线的sql必须经过审计，这个要求我们在编码时最好能分门别类的对sql进行统一的管理。这个可以作为代码评审的一个方向。
2. 设置sql_safe_update=on，如这个参数的名称，当我们这样设置时，所有不加条件的修改和删除请求都将被拒绝，如果我们确实要删除全表，可以使用一些字段比如create_time>0这样来删除。



#### 误删库表

上文我们使用binlog_format=row加上一些恢复数据的程序可以对误删表中数据的情况进行恢复，但是truncate和drop是无效的，那我们如果使用了这两个语句删了表有没有方案解决呢？

##### 解决方案

全量备份+重放binlog。

我在今天12点半进行了误删库表的操作，发现后，立马找到上一次全量备份的备份文件，如果是一天一备的话，那就是今天凌晨0点的备份，我们获取到这个备份文件，搭建一个备库，重放这个备份文件，如果我们开启了GTID，那么我们把删除的那条事务的GTID加到列表中可以跳过，如果没有，那就需要把0点到12点半的数据按照删除语句执行前后进行分割，目的就是跳过那条语句。

这个用来恢复的实例不是备库，只是一个实例而已。

应用0点到12点半的binlog的工具是mysqlbinlog，这个只能单线程，比较慢。而且如果我们存在多个库，最多的优化只能是重放被我们误删表的那个库，库里所有的表的binlog都会被重放，不能针对到表级别。

上面就是整个思路的雏形，后面的所有方案都是对上面方案的重放binlog一个环节的速度的优化。

mysqlbinlog 只能把binlog的数据文件解析出来，然后逐个的到库里面去执行，这个步骤一听就慢。



作者给出了第一种优化方案：

1. 在用备份恢复出临时实例后，将这个临时实例设置成线上备库的从库
   - 在 start slave 之前，先通过执行﻿change replication filter replicate_do_table = (tbl_name)让临时库只同步误操作的表；
   - 可以使用并行复制技术

我的问题是：

作者轻描淡写的叙述了用备份恢复出临时实例之后，这步难道不是最耗时的吗？

全量的binlog备份，mysqlbinlog一行行解析，一个个重放，这都放完了剩下的不都是很简单的吗？

当然如果上一次全量备份时七天前的当我没说。

> 这个优化方案我看不太懂先放在这边把。



###### 延迟复制备库

核心思路是CHANGE MASTER TO MASTER_DELAY = N，让备库和主库之间有N秒的延迟，如果主库执行误操作之后，在N秒内被我们发现了，我们可以

1. stop slave
2. 把GTID加到备库列表中跳过语句
3. start slave

想法很好，两个问题：

1. 我们可能没那么及时发现
2. 如果主备意外切换，这个延迟会导致可用性下降。



##### 如何预防删除库表

1. 权限控制
2. 删表之前先重命名





#### rm 删除实例

这个可能导致数据的丢失，还没来得及同步，但是这个可以通过半同步复制的配置解决。

这个没啥影响，因为这个就相当于单机故障，在一主一备多从的场景下影响较小。







