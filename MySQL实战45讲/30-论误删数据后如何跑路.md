#### 删数据的种类

1. delete 删了表中的几行数据
2. drop/truncate table 删了某张表
3. drop database 删了某个库
4. 使用rm命令删了数据库实例



#### 高可用架构对误删数据有用吗

**没用**，相反高可用会执行主库的语句而把所有实例上的状态都变得和主库一致。



#### 误删行之后的跑路方法

##### 前提

binlog_format=row;

binlog_row_image=full;(这个不知道是不是我遗漏了没看到这个东西)



##### 修复步骤

这个我们在高可用一节说过，因为当binlog_format=row的时候，会记录出修改的具体的行。我们做相反的操作即可

- 如果是插入操作，我们改为删除
- 如果是删除操作，我们改为插入
- 如果是更新操作，我们调换更新前后的值
- 如果是多个操作结合，那么恢复顺序和执行顺序相反
  - delete insert update
  - update insert delete

###### 问题

1. 因为误删数据之后，业务可能在你删除数据的基础上做了一些判断，而让你的业务数据朝着不可预料的方向发展，这就引入了第二条建议
2. 不建议在主库直接恢复，至于原因是因为主库已经在误删数据的基础上进行了一些业务判断，如果你在主库上恢复，相当于二次污染了数据，让数据变得不可控
3. 即使是binlog_format=row 也无法解决trancate和drop语句的删除



##### 一些建议

我们从上面的误删操作存在的问题可以发现，一旦数据被误删，使得数据库处于一个不合法的状态，而这个状态又会引起程序的业务逻辑，从而影响后续程序对数据库数据的修改，一旦我们发现误删的时间过长，会导致整个数据回复到正常情况的难度加大。

我们需要一些防范于未然的手段

1. 所有上线的sql必须经过审计，这个要求我们在编码时最好能分门别类的对sql进行统一的管理。这个可以作为代码评审的一个方向。
2. 设置sql_safe_update=on，如这个参数的名称，当我们这样设置时，所有不加条件的修改和删除请求都将被拒绝，如果我们确实要删除全表，可以使用一些字段比如create_time>0这样来删除。



#### 误删库表

上文我们使用binlog_format=row加上一些恢复数据的程序可以对误删表中数据的情况进行恢复，但是truncate和drop是无效的，那我们如果使用了这两个语句删了表有没有方案解决呢？

##### 解决方案

全量备份+重放binlog。

我在今天12点半进行了误删库表的操作，发现后，立马找到上一次全量备份的备份文件，如果是一天一备的话，那就是今天凌晨0点的备份，我们获取到这个备份文件，搭建一个备库，重放这个备份文件，如果我们开启了GTID，那么我们把删除的那条事务的GTID加到列表中可以跳过，如果没有，那就需要把0点到12点半的数据按照删除语句执行前后进行分割，目的就是跳过那条语句。

这个用来恢复的实例不是备库，只是一个实例而已。

应用0点到12点半的binlog的工具是mysqlbinlog，这个只能单线程，比较慢。而且如果我们存在多个库，最多的优化只能是重放被我们误删表的那个库，库里所有的表的binlog都会被重放，不能针对到表级别。

上面就是整个思路的雏形，后面的所有方案都是对上面方案的重放binlog一个环节的速度的优化。



