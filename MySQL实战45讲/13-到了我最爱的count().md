#### 前言

之前大数据量的表的count(*)总是很慢，基于此，我们来探究下一个count(\*)指令的背后到底发生了什么。



#### count(*)是在哪层实现的

- 数据引擎层

这就意味着不同数据引擎关于count(*)的实现方式可能不同

MyISAM引擎是把count的结果放到磁盘上，查询时直接返回

- 这个如果带查询条件就会失效
- 不支持事务才能这样，但是如果在事务和count(*)的速度上选择一个，我会选择事务

InnoDB是一行一行遍历，然后判断，然后累加



##### InnoDB为什么要逐行累加呢

- 因为支持事务，那默认的可重复读这个事务可见性而言，每个查询连接在执行查询的时候，都跟数据库的实际状态无关了，我们没办法用一个值表示不同状态下的数量；



##### count(*)的优化

如果不加条件的count（*），那么我们选择哪颗索引树遍历都是一样的，不同的索引树的遍历速度不一样，这个主要受什么影响呢？如果多版本并发控制，使得每行的记录有版本的概念，那索引树上的有没有版本的概念呢？

**今天刚发现，原来是没有单独的数据页的，数据页其实就是聚簇索引的叶子节点存储的内容**，所以我们说的记录的版本其实就是聚簇索引的叶子节点对应的行记录的版本号，这边有个问题，就是非聚簇索引是否有版本号的概念呢？如果没有我觉得作者说的这个选择随便一个树遍历的方法就不正确，这边先存疑把，以后可能就会解答我的疑惑。



##### 不同计数方式总结

1. MyISAM的计数方式如果不加条件，不需要支持事务，返回的贼快
2. show table status 是根据索引数据页的不同的数量评估的，误差非差大
3. InnoDB逐行遍历，贼准确，但是有性能问题。





> mysql自带的功能好像并不能解决我们的问题，我们需要自己动手了。



#### 使用redis缓存计数

##### 大致说明

我们把表的数据量写入redis，每次增删的时候，修改这个值。

##### 局限性

- redis的值保存在内存里，如果不能及时同步到磁盘上，比如意外中断服务，那么我们保存在内存中没有及时同步
  - 但是考虑到这种情况发生的偶然性，而且每次我们重启之后只需重新进行一次count(*)的操作就可以恢复，这种不算问题
- 这种最大的问题和MyISAM一样，没办法解决多版本并发控制的问题
  - 详细的说无论我们先把redis的计数+1还是先插表结构，这其中都有一个时间差，假如这时候另一个连接读取数据的时候，会造成返回的数据和实际的数据量不一致的情况。
- 局限性的根源是不同的操作系统没办法实现分布式事务

![img](https://static001.geekbang.org/resource/image/5c/db/5c2f786beae1d8917cdc5033b7bf0bdb.png)

#### 使用一张计数表来计数

##### 大致说明

把redis换成了锁

之前使用redis的时候，我们没办法做多版本并发控制，但是如果写到表里，就可以做了，

就B而言，因为事务A没有提交，它读到的状态是一致的。

![img](https://static001.geekbang.org/resource/image/9e/e3/9e4170e2dfca3524eb5e92adb8647de3.png)



#### 不同形式的count的性能差异

##### 参赛选手

1. count(*)
2. count(1)
3. count(主键id)
4. count(某非主键字段)

以下的分析基于InnoDB引擎

##### count()函数的语义

- 是个聚合函数
- 可以接受不同的参数，上文的1，*，主键id，非主键字段都是参数
- 处理的输入是返回的结果集，处理的输出，对每个结果集进行遍历，对一条记录而言，如果记录中的参数值不为NULL，计数值加一，结果集中所有的记录全部处理完成之后，返回最终的累加值
  - 这个不为NULL只有某非主键字段有用
- 回想起第一节的基础架构，这些聚合函数都是在server层实现的
  - 这就意味着Server层会跟InnoDB要数据，InnoDB只会返回server层要的数据，比如count(id),InnoDB只会返回ID给server层



##### 我们逐个分析参赛选手都做了什么

###### count（id）

- InnoDB遍历整个表，拿到每条记录中的主键id，返回给server端，serverid判断是不可能为空，直接累加



###### count(1)

- InnoDB遍历整个表，但是不取值，server对返回的每一行，都放一个数字1进去，然后逐行累加
- count(1)比count(id)快的，因为不用去取值，也不用传输id



###### count(字段)

- 如果字段定义是为not null 把字段取出来，逐行累加
- 如果字段的定义为null，还要把字段的值取出来，判断不为null才累加



###### count(*)

- 这玩意是关系户，直接获胜



count(字段) < count(id) < count(1) ≈count(*)



#### 思考题

Q : 在刚刚讨论的方案中，我们用了事务来确保计数准确。由于事务可以保证中间结果不被别的事务读到，因此修改计数值和插入新记录的顺序是不影响逻辑结果的。但是，从并发系统性能的角度考虑，你觉得在这个事务序列里，应该先插入操作记录，还是应该先更新计数表呢？



A: 最后达成的结果都是一样的，那就是性能的区别了，性能的区别又涉及到锁，锁的获取有个原则，把那些经常被多个连接访问的表的获取放在最后，因为锁的获取在需要的时候就获取了，但是只有当事务结束才会释放，如果把一个经常被多个事务访问的表的锁的获取放在事务的一开始，就会导致别的事务阻塞。这边有个问题是insert语句会获取哪些锁，更新计数表会直接锁住整个表，导致所有的后续操作不能做，而插入时，别的事务还是可以对那个表进行操作的，基于此，我们觉得应该先插入操作记录，再更新计数表。









