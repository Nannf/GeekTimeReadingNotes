#### 前言

一年了，坚持提交了一年。





#### insert ... select 

这个会对原表select到的记录加next-key lock.

之所以加锁的原因呢？

主备不一致。主备不一致的原因是，当binlog_format=statement以及事务的隔离级别是RR的时候，不加锁会导致binlog的写入顺序不一致。

主库上的insert... select 在执行的时候，如果不加锁，那么源表是可以新增的，但是二者的写入binlog的顺序是不确定的，对主库而言，因为RR，是看不到新增的记录的，但是备库在执行的时候会看到。

这种方式的问题就是会影响原表，如果不加任何条件的复制，那么就是全表锁。

所以如果源表的压力不大，或者我们要复制的东西不多，还可以使用。

否则我们可以考虑把源表的数据全部转成文件，再解析文件入到库中。



为了方便定量描述，我们见表如下：

```mysql
create database db1;
use db1;

create table t(id int primary key, a int, b int, index(a))engine=innodb;
delimiter ;;
  create procedure idata()
  begin
    declare i int;
    set i=1;
    while(i<=1000)do
      insert into t values(i,i,i);
      set i=i+1;
    end while;
  end;;
delimiter ;
call idata();

create database db2;
create table db2.t like db1.t
```

假设我们现有需求如下：

> 把db1的表t中a>900的数据转储到db2的表t中。



#### mysqldump

```mysql
mysqldump -h$host -P$port -u$user --add-locks=0 --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where="a>900" --result-file=/client_tmp/t.sql
```

- –single-transaction: 不对源表加锁，使用一致性视图。START TRANSACTION WITH CONSISTENT SNAPSHOT
- –add-locks=0： 表示在生成的结果文件里不增加”Lock tables t write“
- –no-create-info: 表示不需要导出表结构
- –set-gtid-purged=off: 表示不输出GTID相关信息
- –result-file：指定输出文件的路径
- –skip-extended-insert： 这个没有在示例中给出，这个参数的作用就是一条insert语句只插入一条记录

生成的sql如下:

![img](https://static001.geekbang.org/resource/image/8a/de/8acdcefcaf5c9940570bf7e8f73dbdde.png)



生成了sql文件之后。

```mysql
mysql -h127.0.0.1 -P13000  -uroot db2 -e "source /client_tmp/t.sql"
```

使用上面的命令在db2上执行。

- source 是客户端命令，功能是
  - 打开sql文件，按照分号拆分成一条一条sql
  - 把sql发送到服务端执行





#### 导出csv文件

```mysql
select * from db1.t where a>900 into outfile '/server_tmp/t.csv';
```

- 这个是导出到mysql**服务端**的目录下，如果执行查询的客户端不在服务端的服务器上，那么是不会在客户端的对应路径下生成文件的。
- 生成的结果文件的路径受参数**secure_file_priv**的控制
  - empty ： 表示可以在任何目录路径下，这个是不安全的设置
  - 如果是一个表示路径的字符串，生成文件的路径只能是在这个路径下，或者子目录下
  - NULL：不允许使用这种语法
- 如果路径下有同名的文件，那么会执行出错
- 对数据文件中有换行，指标符的，会加上转义字符



```mysql
load data infile '/server_tmp/t.csv' into table db2.t;
```

生成文件后，可以使用load data 命令完成复制。

- 打开csv文件，以制表符为字段分割，以换行符为记录分割，解析数据
- 启动事务
- 判断每一行的字段数和db2.t是否相同，不相同直接回滚，相同则插入
- 重复上述步骤，直到全部执行完成



这个不似上文的mysqldump命令，生成的就是sql文件，如果binlog_format=statement的时候，放到备库重放是可以的。

但是这个load命令放到备库，备库会因为找不到这个文件而出错。所以如果要备库可以执行，主库的binlog势必要记录下csv文件的内容

- 主库执行完成后，把csv文件内容全写入binlog文件中
- 把load data命令改写成`load data local infile ‘/tmp/SQL_LOAD_MB-1-0’ INTO TABLE \`db2\`.\`t\``
- 把binlog传到备库
- 备库收到binlog文件之后
  - 把csv文件从binlog读取出来，写到备库的/tmp/SQL_LOAD_MB-1-0中
  - 执行load data命令

这里我们发现，load data，可以加local和不加local

1. 不加local表示读取的是服务端的指定目录下的文件，此时读取的文件必须在secure_file_priv限定的路径下
2. 加上local表示可以读取客户端任意路径下的文件，然后上传到服务端



csv方式是不会生成表结构的，我们仍需要一个表结构的文件

```mysql
mysqldump -h$host -P$port -u$user ---single-transaction  --set-gtid-purged=OFF db1 t --where="a>900" --tab=$secure_file_priv
```

- --table=$secure_file_priv表示在$secure_file_priv目录下 创建一个t.sql的表结构文件，然后创建一个t.txt文件，保存csv文件







