#### 前言

1.何谓“**抖**”

- 一条sql语句，正常执行的时候特别快，但是有时候会变得非常慢，这种慢是随机出现的，而且没办法复现。



#### 什么语句会变慢？

我们用常用的增删改查为例来逐个分析：

1. 增： 增加做了什么操作，写redolog,会写内存吗？我们来分析下，redolog是基于物理页的修改，如果插入一条数据时，是要计算出这个新增的数据应该插到那个数据页里，是否会具体插入呢？但是我们知道插入如果开启事务的话，事务是不会写磁盘的，是直接写redolog，加入插入100w条数据，每条都随机写磁盘，那基本没的完，我猜测，插入时并不写磁盘，而只是在内存中和redolog中记录这个插入的数据，等空闲时写入。

其他的三种类型我们等文章结束的时候再来分析。



我们以更新为例，当我们更新一条数据的时候，都涉及了哪些存储呢？

之前在分析一条更新语句是如何执行的时候，我们知道，数据是先写redolog，空闲时修改到磁盘上的，但是有个问题，就是假设我修改之后就读这条数据，那难道还要把这个数据页从磁盘上加载进内存，然后和redolog进行一次运算，才返回结果吗？

显然比较慢，这里还设计到changebuffer，其实这个会写到changebuffer中，当然如果当前的数据页在内存中，这个会直接修改数据页上的内容，并把修改同步到redolog中，但不会立即刷新到磁盘上。

这就导致了内存中的数据页上的数据和磁盘上的数据页的数据不一致的情况，这种不一致的页，我们称为**脏页**。

一直的页，我们称之为**干净页**

![img](https://static001.geekbang.org/resource/image/34/da/349cfab9e4f5d2a75e07b2132a301fda.jpeg)

因为我们一般而言，一个修改操作，最多只涉及一次磁盘文件的读取，一次顺序磁盘的写入，是不怎么耗时的。

但是比如redolog写满了，或者内存用完了，导致我们必须要把一部分数据写入磁盘的时候，这时候就会涉及到多个磁盘的随机访问，这个体现出来的就是那次的修改用的时间比平常慢的多。

