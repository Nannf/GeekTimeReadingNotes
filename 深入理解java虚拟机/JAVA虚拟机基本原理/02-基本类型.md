之前看专栏的评论，说这个专栏的内容和深入理解jvm重合。

实际看下来，这个专栏给出了给多实现上的精确的定义。这是我在深入理解jvm中没有看到的。

因为这个专栏的作者亦是oracle的高级研究员。

想想也是可笑，之前因为那个人的一句话，就放弃了这个专栏。或许我现在也是这样，会因为别人的评论当作自己的评论。

闲话不多谈，我们进入正题。



##### 基本类型的必要性

- 内存使用- int占用的内存必定比Integer小
- 执行效率- 直接使用int肯定比使用Integer快



##### boolean类型

- true 和 false 在编译之后，全是数值
- 在不人为修改字节码的情况下，true=1 false =0;

```java
if (a) {
    // ifeq
}
if (true == a) {
    // if_icmpne
}
```

这两种if的形式，转换成的字节是有区别的，

ifeq表示如果这个a不是0，那就执行。

if_icmpne 表示，这个a必须是1才执行。



##### 基本类型的默认值

- 全是0，只是表示方式不一样



##### 无符号

-  boolean & char

都是非负数



##### 存储越界

- 就跟我们之前说的boolean一样，我们可以使用字节码修改工具把出了0，1以外的值赋值给boolean的变量，我们亦可以把负数赋值给char



##### 浮点类型的0

- +0.0F & -0.0F
- 内存数值不同，前者是0，后者是符号位为1其他位全是0的
- 但是二者比较时是相等的。



##### NaN

- 标准NaN和非标准NaN
- 所有!=NaN的都是true
- 其他所有的比较全是false



##### 基本类型的大小

###### 方法的局部变量表

- float和double都是2个数组单元
- 其他所有的都是一个数组单元
- 数组单元在32位上是四个字节，在64位是8个字节，这个和他们本身的值域是大不相同的
- 估计是为了解决变长参数的问题



###### 其他

值域



##### boolean类型的存储

- hotspot
- 单值使用一个字节
- 数组直接使用的byte数组



##### 零扩展和符合扩展

- 背景就是jvm的算术运算全部依赖于操作数栈
- boolean、byte、char、short全部加载到操作数栈上，当作int类型来处理
- boolean和char是无符号的，所以只要在高位补0
- 剩下的都是有符号的，需要先在最高位补上符号



基本本节就是大开眼界环节，说到的掩码啊，零扩展啊。先看看吧。

