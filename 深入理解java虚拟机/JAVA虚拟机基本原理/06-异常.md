#### java异常概要

##### 两大要素

- 抛出异常
- 捕获异常

两大要素实现了程序的非正常转移。



##### 两种方式

- 显式抛出
  - 应用程序
  - throw关键字
- 隐式抛出
  - jvm
  - 如数组越界，会自动抛出异常



##### 三个代码块

- try
  - 标记下面的代码需要被异常监控
- catch
  - 跟在try块之后
  - 可以有多个
  - 由上到下挨个匹配
  - 上面的异常的范围不能比下面的大
- finally
  - 跟在try块之后，如果有catch，跟在catch块之后
  - 要执行一部分清理的代码，必须执行，但是不一定能执行完，如果finally块中发生了异常，还是会退出的
  - try块和catch块的return不影响finally块的执行



##### 异常分类

- 检查型异常
  - 程序必须给出处理
    - throws
    - catch
- 非检查型
  - Error
    - 这种属于严重问题，程序无需也没办法处置这一种异常
  - Runtime Exception
    - 运行时异常，这个编译时没办法知道

检查和非检查是指编译器能否检查的出来 --> 我们自定义异常的时候都定义成检查型异常，这样可以在最早的时候处理这种异常。



##### 异常构造

###### 轨迹栈(stack trace)

- 会逐一访问当前线程的Java栈帧，记录调试信息
  - 栈帧指向的方法的名称
  - 方法所在的类名、文件名
  - 代码的第几行触发了异常
- 新建异常的方法不会出现在轨迹栈中
- 标记为不可见的方法不会出现在轨迹栈中
- 轨迹栈的优化
  - 缓存异常实例
    - 异常实例的轨迹栈如何缓存呢？
    - 一个方法可以有不同的调用链，同样一个catch块中能抛出一个异常的地方可能不止一处
    - 所以这个优化带来的代价必然是不准确，或者内存和cpu的耗费都大
      - 内存耗费大的原因是因为上面说的类型如果要兼顾到的话，需要缓存很多的实例
      - cpu耗费大的原因是需要做比较，判断实例是否已经存在



#### 虚拟机如何捕获异常



