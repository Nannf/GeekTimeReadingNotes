#### 前言

老朋友了。所有的jvm面试题中这个是常客。

我也零星的记住了双亲委派模型这样的词汇。

我们再来会会这个老朋友。





#### 加载器的类型

##### 启动类加载器

- c++实现
- java中没有对应的对象
- 负责关键类的加载工作
  - jre/lib 目录下jar包中的类
  - jvm参数 -Xbootclasspath指定的类

##### 扩展类加载器

- ClassLoader的子类
- 由启动类加载器加载（父类是启动类加载器）
- 负责相对次要，但是通用的类
  - jre/lib/ext
  - 系统变量指定的java.ext.dirs

##### 应用类加载器

- 父类是扩展类加载器
- 加载应用程序中的类
  - jvm 参数 -cp/-classpath
  - 系统变量 java.class.path
  - 环境变量 CLASSPATH



##### 自定义类加载器

- 常见的场景是需要对一个加密的class文件进行类加载

jdk9之后有所修改。我们先不关注。



##### 类加载的对象

我们知道了这些加载器，我们加载的源头是什么。都是字节流。

java语言的类型

- 基本类型
- 引用类型
  - 类
  - 接口
  - 数组
  - 泛型参数

这就是java所有需要处理的数据类型了。

其中基本类型没有类，当遇到时，由虚拟机直接处理。

泛型会在编译后擦除，我们也无需处理。

数组也没有类文件，这也是虚拟机自动生成的。



所以需要加载的就是类和接口。

类和接口一般的存在形式就是class文件，这个会转换成字节流，被加载器加载进内存。

其他的比如程序可以生成满足格式的流文件作为



#### 加载过程

##### 加载

- 查找字节流，然后创建类的过程
  - 数组是虚拟机自动生成的
  - 其他的类是由类加载器完成加载



###### 双亲委派

- 加载器是有层级的
- 先由父类加载，父类扫描的目录下找不到对应的类的信息才由子类加载器加载



###### 类的唯一性判定

- 类的全类名
- 加载器的实例

同一个类，不同的加载器加载的，对虚拟机而言是两个类。





##### 链接





##### 初始化

