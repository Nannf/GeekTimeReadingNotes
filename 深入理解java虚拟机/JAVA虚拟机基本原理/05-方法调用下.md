#### 方法调用的根源

- 多态



多态带来了可扩展性的提升。但是相应的麻烦应运而来。

对jvm而言，如果一个对象调用了一个非私有的实例方法，那么这个对象多半顶着它实现的接口，或者它的父类的帽子。

只有当运行时，我们才能知道，具体应该执行哪个方法。



#### 方法表

##### 方法表存放的是什么

- 所有的非私有的实例方法
- 子类保护父类方法表中的所有内容
- 同样一个方法，父类和子类的索引是相同的





![img](https://static001.geekbang.org/resource/image/f1/c3/f1ff9dcb297a458981bd1d189a5b04c3.png)

jvm在实际运行的时候：

- 访问栈上的调用者
- 获取调用者的动态类型
- 获取该类型的方法表
- 读取方法表中的索引值（类加载，解析的时候，会把动态绑定的转换成方法表上方法的下标索引）对的目标方法



##### 内联缓存

###### 目的

加快上面的动态绑定操作，具体的方法就是记录下类型和方法之间的映射关系，当jvm识别到一个类型的对象需要调用某个方法时，会直接找到方法压入栈中，而不会再去获取动态类型，再读方法表这样的操作。



###### 如何实现

- 本质就是一个缓存，缓存就涉及到淘汰算法，以及空间换时间
- 当缓存淘汰的比率高得时候，我们不仅要重新使用方法表，还得写缓存。hotspot的默认方式就是放弃了这种优化。



##### 为什么是 invokeinterface & invokevirtual

- 无论是接口的方法也好，还是非私有的实例方法也罢，这些方法都有一个特性，就是可以被重写。这一点我们知道，如果一个接口的方法也好，非私有的实例方法也罢，一旦被final关键词修饰，那么它就不在能被重写，也就不会有动态绑定一说。
- 一旦可以被重写，就意味着，这个方法实际执行的是哪个版本的重写结果，取决于实际执行的对象的类型

理解完这点之后，我们发现剩下的invokestatic也好，invokespecial也好，都是能确定了一个特定的方法，我说的特定的意思指的是，我们在编写代码的时候就已经知道了，这个不应该是不确定的，这个是唯一确定的，我就是想调用那个方法。





#### 方法调用的小结

由重载和重写入手，分析了重载在虚拟机看来就是完全不同的两个方法，所以实际上我们讨论的都是重写带来的问题。

为什么重写会带来方法调用上的问题，就是因为重写带来了多态，加上反射，我们只有在实际运行的时候，才能真正知道需要调用的是哪个方法。

随后分析了5种方法调用的字节码指令。

- invokestatic、invokespecial 这两个指令不会在重写中出现，在编译器我们就可以知道
- invokeinterface、invokevirtual 这两个都是在调用可以被重写的方法时所使用
- invokedynamic，这个暂时还没有介绍



因为在类加载的时候，就要完成符号引用到实际引用的转变，但是因为虚方法的存在，导致了有些方法只有在运行时才能唯一确定，所以针对这种方法而言，符号引用的解析结果并不是一个实际的方法，而是一个方法表。

为了方便叙述，我们假设有个接口I，和两个实现类A&B,那么对这三个类而言，它们都维护了一个自己的方法表

- 方法表是个数组

- 方法表中维护的都是非私有的实例方法
- 子类方法表包含父类方法表的所有内容
- 同样的方法在子类和父类的下标索引一致

所以对这种需要在运行时才知道实际执行方法的类而言，指向的其实是这一批次的方法表，我理解的是一个map，map的key是具体的类型，map的value是每种具体类型的方法表数组。
