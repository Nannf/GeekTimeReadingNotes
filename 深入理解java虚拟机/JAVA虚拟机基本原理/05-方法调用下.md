#### 方法调用的根源

- 多态



多态带来了可扩展性的提升。但是相应的麻烦应运而来。

对jvm而言，如果一个对象调用了一个非私有的实例方法，那么这个对象多半顶着它实现的接口，或者它的父类的帽子。

只有当运行时，我们才能知道，具体应该执行哪个方法。

一个显而易见的解决措施就是，对一个对象，维护一个方法表。

方法表就是一个个的数组。

数组中记录了方法，记录了当前类及其祖先类的所有的非私有实例方法(可被重写)

且，同样一个方法的下标索引应该是一致的。

![img](https://static001.geekbang.org/resource/image/f1/c3/f1ff9dcb297a458981bd1d189a5b04c3.png)

jvm在实际运行的时候：

- 访问栈上的调用者
- 获取调用者的动态类型
- 获取该类型的方法表
- 读取方法表中的索引值（类加载，解析的时候，会把动态绑定的转换成方法表上方法的下标索引）对的目标方法



