#### 可变长参数的一个问题

```java

void invoke(Object obj, Object... args) { ... }
void invoke(String s, Object obj, Object... args) { ... }

invoke(null, 1);    // 调用第二个invoke方法
invoke(null, 1, 2); // 调用第二个invoke方法
invoke(null, new Object[]{1}); // 只有手动绕开可变长参数的语法糖，
                               // 才能调用第一个invoke方法

```

- 尽量不要重载可变长参数方法
- jvm是如何处置方法调用的呢？

我们假想一个问题，如果我们所有的方法的名称都保证不一样，那是不是就没有识别的问题了，直接根据名称就完事了。

之所以有这些问题就是因为有的方法的名称是一样的，且是合法的一样，比如重载和重写。

还有上面叙述的可变长参数的这类语法糖，方便了程序员的使用，也增加了jvm的工作。



#### 重载与重写

##### 重载

###### 重载方法的定义

- 同一个类
- 名字相同
- 参数不同（类型、数量、顺序）



###### 重载方法的识别时机

重载的方法，在编译时期就可以识别。



###### 重载方法的识别顺序

- 不考虑基本类型的拆装箱、不考虑可变长参数的方法选取
  - 经测试发现，定义两个相同名字的方法，参数只有一个，一个是基本类型，一个是对应的包装类型，发现编译没有报错
- 允许自动拆装箱，不允许可变长参数
- 两个都允许



###### 当在识别的三个阶段的任一阶段发现了多个匹配的方法时

- 我们发现在第一种的时候，这个方法是无二义的，这个识别阶段只会有至多一个匹配的方法
- 第二阶段开始，自动拆装箱就可以引发二义性了，此时的识别阶段至多两个匹配到的方法
- 第三阶段，此时理论上可以匹配到茫茫多的方法

此时jvm就会找到一个贴切的方法来执行。



###### 如何定义贴切

形式参数类型的继承关系。

- 当参数为null时，会选择子类，基本类型和包装类型时，会选择包装类型
- 当参数为基本类型就是基本类型，为包装类型就是包装类型



###### 当重载遇到继承

- 子类中定义了父类中同名方法
- 参数类型不同



##### 重写与隐藏

###### 重写

- 子类和父类的名称，参数，返回值全都一样
- 都是非静态的，非私有的

###### 隐藏

- 子类和父类的名称、参数、返回值全都一样
- 都是静态的,看看你的参数引用类型是什么，调用的就是谁的方法，因为静态的方法是属于类的

```java
Fruit fruit = new Apple();
fruit.name();
```

