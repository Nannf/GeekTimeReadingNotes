#### 可变长参数的一个问题

```java

void invoke(Object obj, Object... args) { ... }
void invoke(String s, Object obj, Object... args) { ... }

invoke(null, 1);    // 调用第二个invoke方法
invoke(null, 1, 2); // 调用第二个invoke方法
invoke(null, new Object[]{1}); // 只有手动绕开可变长参数的语法糖，
                               // 才能调用第一个invoke方法

```

- 尽量不要重载可变长参数方法
- jvm是如何处置方法调用的呢？

我们假想一个问题，如果我们所有的方法的名称都保证不一样，那是不是就没有识别的问题了，直接根据名称就完事了。

之所以有这些问题就是因为有的方法的名称是一样的，且是合法的一样，比如重载和重写。

还有上面叙述的可变长参数的这类语法糖，方便了程序员的使用，也增加了jvm的工作。



#### 重载与重写

##### 重载

###### 重载方法的定义

- 同一个类
- 名字相同
- 参数不同（类型、数量、顺序）



###### 重载方法的识别时机

重载的方法，在编译时期就可以识别。



###### 重载方法的识别顺序

- 不考虑基本类型的拆装箱、不考虑可变长参数的方法选取
  - 经测试发现，定义两个相同名字的方法，参数只有一个，一个是基本类型，一个是对应的包装类型，发现编译没有报错
- 允许自动拆装箱，不允许可变长参数
- 两个都允许



###### 当在识别的三个阶段的任一阶段发现了多个匹配的方法时

- 我们发现在第一种的时候，这个方法是无二义的，这个识别阶段只会有至多一个匹配的方法
- 第二阶段开始，自动拆装箱就可以引发二义性了，此时的识别阶段至多两个匹配到的方法
- 第三阶段，此时理论上可以匹配到茫茫多的方法

此时jvm就会找到一个贴切的方法来执行。



###### 如何定义贴切

形式参数类型的继承关系。

- 当参数为null时，会选择子类，基本类型和包装类型时，会选择包装类型
- 当参数为基本类型就是基本类型，为包装类型就是包装类型



###### 当重载遇到继承

- 子类中定义了父类中同名方法
- 参数类型不同



##### 重写与隐藏

###### 重写

- 子类和父类的名称，参数，返回值全都一样
- 都是非静态的，非私有的

###### 隐藏

- 子类和父类的名称、参数、返回值全都一样
- 都是静态的,看看你的参数引用类型是什么，调用的就是谁的方法，因为静态的方法是属于类的

```java
Fruit fruit = new Apple();
fruit.name();
```



#### 静态绑定与动态绑定

##### jvm如何确定一个唯一的方法

- 类名
- 方法名
- 方法描述符
  - 方法的参数类型
  - 返回类型

当有两个及以上方法的上述属性全都一致时，在验证时报错。即保证我们的字节流满足定义的需要。

这里我们看到了一个意料之外的朋友，返回类型，jvm是允许在同一个类中，方法名、参数全都相同，但是返回类型不同的方法，虽然我们在java语言中不能这么写。



##### 虚拟机判定重写

- 子类中定义了父类中同名的、非私有的、非静态的方法
- 参数类型和返回类型一致



###### 泛型时的重写判定

桥接方法登场。这个时我在看java核心技术的时候，看来好多遍的地方。

父类定义的参数在类型擦除后会变成Object。

因为虚拟机层面二者的都必须一致，所以才出现了一个中间的方法，这个方法的声明满足虚拟机的重写判定，会在这个方法中调用我们定义的方法。

```java
  class Father<T> {
        public void get(T obj) {
            System.out.println("father");
        }
    }

    class Son extends Father<Integer> {

        @Override
        public void get(Integer integer) {
            System.out.println("integer");
        }
    }
```

重载的方法，我们发现在编译的时候，就已经做好了区分，是静态的，所以又称静态绑定。

重写一般涉及多态，多态一般只有在运行时，我们才知道需要绑定什么方法，所以重写又称动态绑定。



##### 再谈静态与动态

我们在上面识别出了静态和动态的概念。

但是如果一个父类的重载方法被子类重写，那这个是静态还是动态，父类调用该方法和子类调用该方法的表现是不一样的。

所以我们区分动态和静态的主要是一个是在解析（把符合引用转变为实际引用）就能识别的目标方法。比如一般的方法。叫做静态绑定，把那些根据调用者的动态类型来识别目标方法的叫做动态绑定。



##### 虚拟机中方法调用的几种类型

1. invokestatic: 调用静态方法
2. invokespecial: 调用私有实例方法、构造器、使用super关键字调用父类的实例方法或构造器、所实现接口的默认方法
3. invokevirtual: 调用非私有实例方法
4. invokeinterface：调用接口的方法
5. invokedynamic: 调用动态方法

```java

interface 客户 {
  boolean isVIP();
}

class 商户 {
  public double 折后价格(double 原价, 客户 某客户) {
    return 原价 * 0.8d;
  }
}

class 奸商 extends 商户 {
  @Override
  public double 折后价格(double 原价, 客户 某客户) {
    if (某客户.isVIP()) {                         // invokeinterface      
      return 原价 * 价格歧视();                    // invokestatic
    } else {
      return super.折后价格(原价, 某客户);          // invokespecial
    }
  }
  public static double 价格歧视() {
    // 咱们的杀熟算法太粗暴了，应该将客户城市作为随机数生成器的种子。
    return new Random()                          // invokespecial
           .nextDouble()                         // invokevirtual
           + 0.8d;
  }
}
```

###### invokestatic

这个是调用静态方法的，这个方法的调用只跟调用的类有关，所以jvm是可以直接识别的，编译时就可以识别

###### invokespecial

- 私有实例，我们需要知道这个对象的类型才能识别调用哪个方法吗？我们没的选，只能调声明的那个类型的
- 构造器，这个不知道具体的类型都不能new
- super调用父类的非私有实例方法，这个可以简单的考虑成多态时的基类

以上两个jvm都是可以静态绑定的。



###### invokevirtual

调用非私有实例方法，一听就跟多态有关。

###### invokeinterface

这个也跟多态有关。



