我们想论证的就是，为什么业务处理时的线程池可以增加netty的响应速度



网络连接 ： EventLoop : 线程 = N ： 1 ： 1

这就意味着在netty中，多个网络连接会主要到同一个EventLoop上去。

一个EventLoop是一个线程在处理。

我们所说的线程池，就是在这一个线程的运行过程中，使用线程池。

如果一切都变得异步，那么使用线程池，在资源充足的情况下，无疑可以使处置速度加快。



EventLoopGroup  中有多个EventLoop;

至于是哪个EventLoop处置客户端的请求，使用的是轮询算法。











##### 线程模型与io模型的关系

- io模型决定了你的线程模型。
  - 最简单的方式就是一个客户端连接，一个服务端的线程处理
  - 但是当客户端增加起来之后，这个显然不可行了
  - 考虑到一个处理请求的绝大多数时间都是在等待io，可不可以使用一个线程处置多个客户端连接
  - 但是1.4之前的bio，当一个线程在写数据的时候，是阻塞的，这就意味着线程响应不了别的客户端的请求
  - 所以，nio的出现才让大用户量网络编程出现可能







###### 什么是阻塞？

- 阻塞是修饰io还是修饰线程？
  - 阻塞实际阻塞的是线程的执行
    - 对客户端而言，调用read之后，就阻塞在那边了，不能做其他的事情。
    - 对服务端而言，在write的时候，也阻塞在那了，做不了别的事情。