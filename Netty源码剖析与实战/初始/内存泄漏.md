##### 弱引用与内存泄漏

当强引用和弱引用同时引用一个对象时，这个对象会被回收吗？

答案是不会的，只有当这个强引用被回收了，这个弱引用才会被回收。

很多地方都会说，被弱引用引用的对象，当垃圾回收的时候，就会被立马回收，给我们造成一个错觉，就是只要被弱引用引用了，这个对象就已经离死不远了。

其实还有一种情况我们没有说明，就是弱引用和强引用的配合，发现这个对象什么时候被垃圾回收。

当强弱引用同时引用一个对象的时候，如果强引用还在，那么就算弱引用引用了这个对象，它也不会被回收。

这就是netty的弱引用策略。

netty中的内存泄漏都是针对ByteBuf的.



##### gc与内存泄漏

为什么gc之后还有内存泄漏的问题呢?

一个让人误解的逻辑就是:

- 内存泄漏要得这个对象被回收才能检测
- 对象被回收了为什么还有内存泄漏问题.

这就涉及到一个堆外直接内存的概念.

jvm可以申请堆外内存,并且有个对象可以访问到这个堆外的内存.在netty中这个对象就是ByteBuf

当这个对象不使用的时候,会触发垃圾回收操作.

我们知道关于堆外内存的申请和释放要成对出现.

这里就引出了引用计数法.当这个对象被gc的时候,如果这个引用不为0,说明了什么,说明了没有调release方法,这个值一定是大于等于0的,因为当等于0的时候,就会直接触发回收操作.











