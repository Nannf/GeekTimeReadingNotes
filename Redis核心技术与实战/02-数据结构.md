##### 键值数据库如何存储？

- 哈希表



##### 存储的过程？

- 根据key计算hash值，和hash桶 的个数取模得到最终的存放数组



##### 时间复杂度

- 粗略的说是O(1)
- 但是这是建立在hash桶无限大，hash函数较好的场景之下
  - hash冲突在所难免
  - 当发生冲突时，有开放寻址和链表法两种，redis选择了后者，后面的链表会优化成红黑树
- 当哈希表中的数据达到一定阈值之后，会触发扩容操作，扩容之后所有的数据都要根据新的hash桶的个数进行rehash
  - 这步其实是关键所在，rehash时到底做了什么，以及rehash如何解决并发访问问题
  - redis使用了两个hash桶，以及渐进rehash操作作为解决方案





##### rehash

- 两个hash桶，当一个hash的容量超过负载因子时，触发rehash操作
  - 此时如果我们一次性的把原先的hash桶中的数据全部rehash到新的hash桶中，一个不可避免的操作就是暂停所有的写操作，我们得保证操作时的一个一致性快照，才能保证没有遗漏
  - 或者参照mysql的onlineDDL,使用一个链表记录下在rehash期间所有的修改，然后再rehash完成后逐个再rehash
  - 因为hash桶其实是一个数组，所以最后的数组拷贝的工作
- 为了避免一次性的rehash造成了性能骤降，所以当达到一定阈值后，其后的每一次修改，都会把一个哈希桶的数据rehash到另一个桶中，这样当有新的节点插入的时候，当取模之后发现是已经rehash过的桶会直接插入到新的hash桶中





该篇的时间复杂度分析不是很妥当，结合数据结构与算法之美一章可以更好的掌握。

当然阅读源码是最好的选择。

我决定先把这些放放，先大致浏览个大概，然后再来深入研究。

如果我后续的学习过程中发现有些东西必须深入理解数据结构才能进行，那么我们再来研究。





#### 压缩列表

- 类似数组
- 连续内存空间
- ![img](https://static001.geekbang.org/resource/image/49/b5/49fd8d46eb94f463ace98717f11c2cb5.jpg)

压缩的目的是用来降低空间损耗。

这里的降低是相较于传统的数组而言。

传统的数组的每个元素的长度是一样的。以上图为例，我们每个存储单元的大小应该是最大的元素的长度。



#### 双向链表

```java
class ListNode{
    ListNode prev;
    ListNode next;
    Object value;
}

class List {
    ListNode head;
    ListNode tail;
    long len;
}
```







