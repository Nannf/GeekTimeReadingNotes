我们假定redis中的数据都来源于数据库

- 数据库查询慢
- 数据库的性能有瓶颈
- 缓存淘汰的数据并不能简单的查库查出来
- 我们需要把redis的数据持久化到磁盘上
  - 解决了查询数据库慢的问题
  - 解决了缓存数据淘汰之后的调教问题



##### AOF

append only file



- aof就是一个持久化机制





#### 持久化

##### 时机

- 执行前 or 执行后
  - 执行后的好处是不用去花时间检测指令执行的正确与否
  - 执行后的坏处是，非原子操作，如果没有在别的地方进行保存，会导致数据丢失



##### 写盘的时机

- 每次执行完之后就同步写
  - 牺牲了主线程的响应性能
  - 可靠性相对较高

- 定期写
  - 提升了主线程的响应性能
  - 牺牲了部分的可靠性

- os随机写
  - 相较定期写，性能更高
  - 不可控，造成了更高的可靠性



##### 重写优化

- 重写优化的前提是，多条语句对数据进行了修改，我们可以用最终的数据状态来重写aof文件
- 重写优化的背景是，数据量大之后，aof文件过大，会导致新增写入的速度变慢，也会导致os对大文件的不支持
- 重写优化的挑战是，如何在对主线程影响尽量小的场景下完成重写优化，类似于mysql的onlineDDL
  - 一个很常见的解决措施就是一个一致性快照，然后记录拷贝期间的所有修改



这种其实类似于mysql的binlog



